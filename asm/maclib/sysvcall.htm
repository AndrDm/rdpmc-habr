<!doctype html><html lang='en'><head>
<meta http-equiv='Content-Type' content='text/html; charset=utf-8'/>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=2.0, user-scalable=yes'>
<meta name='robots' content='ALL,FOLLOW'/>
<meta name='description' content='sysvcall.htm macro library'/>
<meta name='version' content='20250318'/>
<meta name='author' content='Pavel vitsoft Šrubař'/>
<link rel='stylesheet' href='../euroasm.css' type='text/css'/>
<link rel='shortcut icon' href='../favicon.ico'/>
<title>sysvcall.htm macro library</title>
</head>
<body class='MACLIB' id='top'><div class='HEADMENU'><table>
<tr><td rowspan='2' title='&euro;ASM - assembler and linker'><img src='../favicon.ico' alt='EuroAssembler' />
<td><a href='../index.htm' title='Alphabetical index of all &euro;ASM elements, directives and instructions'>Index</a></td>
<td><a href='../eadoc/' class='EADOC' title='Documentation of EuroAssembler'>Manual</a></td>
<td><a href='https://euroassembler.eu/download/' title='History &amp; download of the latest and previous versions'>Download</a></td>
<td><a href='../easource/' class='EASOURCE' title='Source files of EuroAssembler itself'>Source</a></td>
<td><a href='../maclib/' class='MACLIB' title='Macro libraries shipped with &euro;ASM'>Macros</a></td>
<td rowspan='2' title='Find the searched token in any text file on this site'>
<form method='post' action='../search.php' enctype='multipart/form-data' accept-charset='utf-8'>
<input type='text' id='q' placeholder='Searched word(s)' name='q' value=''/>
<br/><label title='Check the box to find the expression even if it is surrounded by other letters | digits.'>
<input type='checkbox' name='EW'/><small>Embedded word</small></label>
<br/><label title='Check the box for case-insensitive search.'>
<input type='checkbox' name='CI'/><small>Case ins.</small></label>
<input type='submit' title='Search for the specified word|expression in all site files.' name='find' value='Search'/>
</form></td></tr><tr>
<td><a href='../sitemap.htm' title='List of directories and files on this site'>Sitemap</a></td>
<td><a href='../eadoc/links.htm' class='EADOC' title='References and external links to resources used in EuroAssembler developement'>Links</a></td>
<td><a href='https://euroassembler.eu/forum/' title='Discussion forum concerning EuroAssembler'>Forum</a></td>
<td><a href='../eatests/' class='EATESTS' title='Program snippets for testing the function of &euro;ASM'>Tests</a></td>
<td><a href='../objlib/' class='OBJLIB' title='Skeletons and sample objects and projects shipped with &euro;ASM'>Projects</a></td>
</tr></table></div>
<!--Contents above the marker {!==/HEADMENU==} was generated by "generate.php".-->
<!--/HEADMENU-->
<h1>sysvcall.htm
<br/><i>Macros</i>
<br/><a href="#ClearLocalVar">ClearLocalVar</a>
<br/><a href="#EndProcedure">EndProcedure</a>
<br/><a href="#Invoke">Invoke</a>
<br/><a href="#LocalVar">LocalVar</a>
<br/><a href="#Procedure">Procedure</a>
<br/><a href="#Uses">Uses</a>
</h1>
<p>This file can be included to <strong>64bit programs</strong> written in EuroAssembler.
<!---->The library contains macroinstructions <code>Procedure, EndProcedure, Invoke
</code> which extend generic (pseudo)instructions <code>PROC, ENDPROC, CALL</code> in calling convention defined by
<dfn>System V Application Binary Interface in AMD64 architecture</dfn>
<a class="EXTL" href="../eadoc/links.htm#SystemV">[SystemV]
</a>, where the arguments are transferred to the function in registers. If there is no enough registers,
<!---->the remaining arguments are pushed on stack, starting with the last, and the stack is restored by the caller after return.
<br/>Machine stack is OWORD aligned before the CALL is performed.
<br/>The first 6 arguments are provided in registers RDI,RSI,RDX,RCX,R8,R9 (or in XMM0..XMM7
<!---->when they are floating-point numbers). Callee-save registers are RBX,RBP,RSP,R12..R15.
<!---->All other registers may be destroyed by the invoked function.
<br/>Such calling convention is used in Linux and Unix based operation systems.</p>
<p>This library implements <strong>simplified subset of System V convention</strong>, where the invoked procedure
<!---->has not more than 6 integer and 8 floating-point arguments (no argument is transferred via machine stack),
<!---->only one (scalar) FP value is transferred in the lower 32 or 64 bits of XMM.
<br/>Macros from this library cannot be used for functions which have more than 6 integer arguments,
<!---->more than 8 floating-point arguments, which require transfer in YMM or ZMM register,
<!---->which require stack alignment better than 16.</p>
<p>The block of code defined between macros <a href="#Procedure">Procedure</a>&nbsp;..&nbsp;<a href="#EndProcedure">EndProcedure
</a> can be called by macro <a href="#Invoke">Invoke</a> or as a callback procedure from library functions.</p>
<p>Macro <a href="#Invoke">Invoke</a> can be also used to call functions from third-party static or dynamically
<!---->linked libraries. For invocation of Linux kernel functions it's necessary to use specialized macro
<a class="EXT" href="linabi.htm#LinABI">LinABI</a> because of differences in the register used for transfer of 4th argument
<!---->and because LinABI uses SYSCALL instead of CALL.</p>
<p>Macro <a class="#Invoke">Invoke</a> takes care of <strong>stack alignment</strong> to OWORD just before execution of instruction
<code>CALL Function</code>.
<dl id="FastCallFrame"><dt>Example</dt><dd>Definition of procedure MyProc with five parameters,
<!---->where Par1, Par4, Par5 are integer|pointers, and Par2,Par3 are floats.
<!---->MyProc uses two GP registers RBX and R12 an two local stack variables with sizes 8 and 16:</dd>
<dd class="PRE"><!---->MyProc Procedure Par1,Par2,Par3,Par4,Par5
<!---->       ; Parameters Par1..Par5 should be loaded in RDI,XMM0,XMM1,RSI,RDX, respectively, when MyProc is invoked.
<!---->       Uses RBX,R12     ; These callee-save registers should be enumerated here, if they are used. They will be restored in EndProcedure.
<!----> LocV1 LocalVar         ; Reserve local stack variable with default size 8.
<!----> LocV2 LocalVar Size=16 ; Reserve another variable.
<!---->       ClearLocalVar    ; This fills all local stack variables with 0.
<!---->          ; Local variables are available by formal name prefixed with <kbd>%</kbd>, e.g.
<!---->          MOV [%LocV1],RDI ; Copy Par1 to the local variable.
<!---->          ; Programmer should emit instructions of the <b>MyProc body</b> here
<!---->          ;   and load the result of MyProc into return-register (RAX or XMM0).
<!---->    EndProcedure MyProc ; This macro discards local variables, pops used callee-save registers,
<!---->                        ;    pops RBP and returns below Invoke statement at run-time.
</dd>
<dd><p>The following diagram shows the stack frame created by invoking MyProc defined in the example above.
<blockquote>Macros of sysvcall convention will create and update the following &quot;global&quot; %variables at asm-time:
<br/><code>%ArgC_MyProc   %SETA 5</code> (number of arguments),
<br/><code>%Uses_MyProc   %SET R12,RBX</code> (list of used callee-saved registers),
<br/><code>%LvSize_MyProc %SETA 8+16</code> (total size of local stack-variables),
<br/><code>%LocV1 %SET RBP-24</code> (1st local stack variable),
<br/><code>%LocV2 %SET RBP-40</code> (2nd local stack variable),
</blockquote></dd>
<dd class="PRE"><!---->                        <abbr> RSP after the step #.
<!---->                                &#x2502;
<!---->                                &#x2502;  Stack </abbr>
<!---->         &#x250C;                    0.&gt;&#x250C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2510;&lt;15.                        &#x2510;
<!---->         &#x2502;1.PUSH RSP             &#x2502;origRSP&#x2502;  15.POP RSP                &#x2502;  Invoke
<!----> Invoke  &#x2502;                    1.&gt;&#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;                            &#x251C; epilogue
<!---->prologue &#x2524;2.PUSH RSP;ADD [RSP],8 &#x2502;origRSP&#x2502;                            &#x2518;
<!---->         &#x2502;   OWORD-aligned&gt;   2.&gt;&#x251C;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2524;&lt;14.                        &#x2510;
<!---->         &#x2502;3.CALL MyProc          &#x2502;return &#x2502;  14.RET                    &#x2502;
<!---->         &#x2514;                    3.&gt;&#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;&lt;13.                        &#x2502;
<!---->Procedure&#x2524;4.PUSH RBP;MOV RBP,RSP &#x2502;origRBP&#x2502;  13.POP RBP                &#x2502;
<!---->         &#x250C;                    4.&gt;&#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;&lt;12.                        &#x2502;
<!----> Uses    &#x2524;5.PUSH RBX             &#x2502; RBX   &#x2502;  12.POP RBX                &#x2502;
<!---->         &#x2502;                    5.&gt;&#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;&lt;11.                        &#x251C;EndProcedure
<!---->         &#x2502;6.PUSH R12             &#x2502; R12   &#x2502;  11.POP R12                &#x2502;
<!---->         &#x250C;                    6.&gt;&#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;&lt;10.                        &#x2502;
<!---->         &#x2502;7.SUB RSP,8            &#x2502; LocV1 &#x2502;  10.ADD RSP,8+16           &#x2502;
<!---->         &#x2502;                    7.&gt;&#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;                            &#x2502;
<!---->LocalVar &#x2524;                       &#x2502;       &#x2502;                            &#x2502;
<!---->         &#x2502;                       &#x2502; LocV2 &#x2502;                            &#x2502;
<!---->         &#x2502;8.SUB RSP,16           &#x2502;       &#x2502;                            &#x2502;
<!---->         &#x2514;                    8.&gt;&#x2514;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2518;&lt;9.                         &#x2518;
<!---->
<!---->                               9. MyProc body
</dd></dl>
<br class="CLEAR"/><pre>
sysvcall HEAD
</pre>
<dl id="Procedure"><dt><a href="#top">&uarr; Procedure</a> Operand1, Operand2,,,</dt>
<dd><p>This macro <dfn>Procedure</dfn> declares simplified 64bit System V procedure prologue.
<br/>Using of the macro Procedure requires the corresponding <a href="#EndProcedure">EndProcedure
</a> be used in the same program.</p>
<dt>Input</dt><dd>Label of <b>Procedure</b> statement is mandatory,
<!----> it gives the procedure a callable name.
<br/><b>Operand*</b> is the list of formal names for arguments passed to the procedure.
<!---->Those formal names are not used, arguments are expected in registers only.
</dd>
<dt>Output</dt><dd>Macroinstruction will define public symbol with procedure name.
<br/>It does not push registers (except for RBP). Programmer is responsible for saving and restoring
<!---->callee-save registers RBX, R12..R15 if they are used in procedure body.
<!---->This can be done either manually, or with macro <a href="#Uses">Uses</a>.
<br/>RBP must not be changed while the procedure body uses preprocessing %variables referring
<!---->the temporary stack local variables defined with
<a href="#LocalVar">LocalVar</a>.</dd>
<dt>Example</dt><dd class="PRE">
<!---->Move Procedure Source,Destination,Size  ; Declaration of procedure Move and its formal arguments.
<!---->; Arguments are in RDI, RSI, RDX.
<!---->      XCHG RSI,RDI                      ; Source to RSI, Destination to RDI.
<!---->      MOV RCX,RDX                       ; Size.
<!---->      REP MOVSB                         ; Perform the actual copy.
<!---->     EndProcedure Move                  ; Return from the procedure Move.
<!---->
<!---->Macro <code>Move Procedure</code> in the previous example will assign
<!---->%ArgC_Move   %SET 3      ; This %variable propagates to the corresponding macro <code>EndProcedure Move</code>.
<!---->%Uses_Move   %SET        ; This %variable propagates to the macro Uses and EndProcedure.
<!---->%LvSize_Move %SETA 0     ; This %variable propagates to the macro LocalVar and EndProcedure.
<!---->
<!---->   Invoke Move, RSI, OutBuffer, SIZE# OutBuffer  ; Example of procedure invocation.
</dd></dl><pre>
Procedure %MACRO FormalName1, FormalName2,,,,
LblCheck    %IF "%:" === ""
              %ERROR ID=5921, 'Macro "Procedure" requires a label.'
              %EXITMACRO Procedure
            %ENDIF LblCheck
%%ArgC_%:   %SETX %#                   ; Initialize with number of arguments.
%%Uses_%:   %SETX                      ; Initialize as empty list.
%%LvSize_%: %SETX 0                    ; Initialize as zero.
%:::        PROC %=*, NESTINGCHECK=OFF ; Open the namespace and define entry symbol from macro label <code>%:</code> as GLOBAL.
            PUSH RBP
            MOV RBP,RSP                ; Initialize the frame pointer.
          %ENDMACRO Procedure
</pre>

<dl id="Uses"><dt><a href="#top">&uarr; Uses</a> Register1, Register2,,,,</dt>
<dd><p>Macro <dfn>Uses</dfn> specifies which callee-save registers does the Procedure use,
<!---->so they are pushed on stack here (and they will be restored in <a href="#EndProcedure">EndProcedure
</a> epilogue).</p>
<blockquote>Calling convention macros in 16bit and 32bit mode could save/restore all eight GPR
<!---->with a single PUSHA/POPA. This instruction is not available in 64bit mode, so we will use this macro instead.
</blockquote>
<p>Macro Uses can be used in 64bit mode only, right after the statement <a href="#Procedure">Procedure
</a> and before local stack variables are defined with <a href="#LocalVar">LocalVar</a>.</p>
<p>Callee-save registers RBX,,R12..R15 should be enumerated here
<!---->if they are actually used in Procedure..EndProcedure block.
<br/>Callee-save registers RBP,RSP should not be mentioned here, they are always saved automatically in Procedure prologue.
<br/>It is useless to enumerate all other registers here,
<!---->because the caller of our Procedure cannot expect them to be preserved.
<br/>Registers which return the result may not be enumerated here, because they wouldn't return the expected value after their restoration.</p>
</dd>
<dt>Input</dt><dd><b>Register*</b> is GPR register.</dd>
<dt>Output</dt><dd>Macro will push all enumerated registers on stack
<!---->and assign their list to a unique %variable named <code>%Uses_<em>ProcedureName</em>
</code> in reversed order. This %variable will be used by EndProcedure for restoration of callee-save registers.</dd>
</dl><pre>
Uses %MACRO Register1,Register2,...
InProcCheck   %IF "%^PROC" === ""
                %ERROR ID=5926,'Macro "%0" is unexpected here.'
              %ENDIF InProcCheck
%Uses         %SET2 %%Uses_%^PROC
reg           %FOR %*
                %IF REGTYPE#(%reg) = 'Q' ; General-purpose 64bit register.
                  PUSHQ %reg
%Uses             %SET %reg,%Uses        ; Accumulate register names in reversed order.
                %ELSE
                  %ERROR ID=5927,'Macro "Uses" does not support operand "%reg".'
                %ENDIF
              %ENDFOR reg
%%Uses_%^PROC %SETX %Uses
            %ENDMACRO Uses
</pre>


<dl id="LocalVar"><dt><a href="#top">&uarr; LocalVar</a> Size=8</dt>
<dd>Macro <dfn>LocalVar</dfn> reserves and declares local memory variable with the given Size allocated on machine stack
<!---->and assigns its name to a preprocessing %variable which has its name derived from the label of macro LocalVar.
<br/>It can only be used inside <code>Procedure..EndProcedure</code> block.</dd>
<dt>Input</dt><dd>Plain identifier must be defined as a label of
<b>LocalVar</b> statement. It does not need to be unique in the program
<!---->because it does not declare assembly symbol. The name will be
<!----> prefixed with <kbd>%</kbd> and used as preprocessing %variable
<!---->for addressing the memory variable withing the procedure body.
<br/><b>Size=</b>8 specifies how many bytes should be reserved for the local stack variable.
<!---->The Size is automatically rounded up to the nearest multiple of 8.</dd>
<dt>Output</dt><dd>Macro will define a preprocessing %variable with
<!---->the name which was defined as the label but it is now prefixed with percent sign.
<!---->Then it will emit machine instruction <code>SUB RSP,%Size</code>
<!---->to reserve room on the machine stack.
<br/>Macro LocalVar also maintains the &quot;global&quot; preprocessing %variable
<code>%LvSize_<em>ProcedureName</em></code> which was initialized in macro <a href="#Procedure">Procedure
</a> and which will be used for zeroing local variables in
<a href="#ClearLocalVar">ClearLocalVar</a> and for discarding local variables in
<a href="#EndProcedure">EndProcedure</a>.</dd>
<dt>Example</dt><dd class="PRE">
<!---->ProcName: Procedure Param1    ; This example uses two local stack variables with sizes 8 and 1K.
<!---->           Uses RBX           ; Saved callee-save register is now available at <code>RBP-8</code>.
<!----> BlockSize LocalVar           ; <code>%BlockSize</code> is now assigned with <code>RBP-16</code> (8+8).
<!----> Block     LocalVar Size=1024 ; <code>%Block</code> is now assigned with <code>RBP-1040</code> (8+8+1024).
<!---->           ClearLocalVar      ; Fill %Block and %BlockSize with 0.
<!---->           MOV [%BlockSize],1K, DATA=QWORD
<!---->           LEA RBX,[%Block]
<!---->           ; more instructions...
<!---->          EndProcedure ProcName</dd>
</dl>
<pre>
LocalVar      %MACRO Size=8
InProcCheck     %IF "%^PROC" === ""
                  %ERROR ID=5926,'Macro "%0" is unexpected here.'
                  %EXITMACRO LocalVar
                %ENDIF InProcCheck
LblCheck        %IF "%:" === ""
                  %ERROR ID=5922, 'Macro "%0" requires a label.'
                  %EXITMACRO LocalVar
                %ENDIF
OrdCheck        %IF %#
                  %ERROR ID=5923, 'Macro "%0" does not expect ordinal parameters.'
                %ENDIF
%:              %COMMENT                          ; This empty comment block makes the label of macro void,
                %ENDCOMMENT %:                    ;   so it does not declare a symbol.
%ThisLvSize     %SETA (%Size + 7) & ~7            ; Round up to the nearest multiple of 8.
%GlbLvSize      %SET2 %%LvSize_%^PROC+%ThisLvSize ; Increase the total size of previously defined local variables.
%%LvSize_%^PROC %SETX %GlbLvSize                  ; Update the "global" %variable.
                SUB RSP, %ThisLvSize              ; Stack memory allocation.
%ThisUses       %SET2 %%Uses_%^PROC               ; Retrieve the list of used registers.
%ThisLen        %SETL %ThisUses                   ; Number of registers pushed by macro Uses.
%%%:            %SETX RBP-8*%ThisLen-(%GlbLvSize) ; Assign formal %name to the id <kbd>%:</kbd> specified as LocalVar label.
   %ENDMACRO LocalVar
</pre>

<dl id="ClearLocalVar">
<dt><a href="#top">&uarr; ClearLocalVar</a></dt>
<dd>This macro zeroes all variables on stack previously declared with
<a href="#LocalVar">LocalVar</a>. ClearLocalVar should be expanded
<!---->right after the last LocalVar declarations, before any stack operations are made.
<blockquote>We could as well decide to initialize each local variable individually, e.g.
<code>MOVQ [%MyLocalVar],0</code>,
<!---->and in this case the macro ClearLocalVar will not be used in the Procedure body at all.
</blockquote></dd>
<dt>Input</dt><dd>Macro does not use explicit parameters.
<!---->The cleared memory is pointed to with <code>RSP</code>,
<!---->its size is specified with &quot;global&quot; variable
<code>%LvSize_<em>ProcedureName</em></code>.</dd>
<dt>Output</dt><dd><b>RAX=</b>0
</dd></dl><pre>
ClearLocalVar %MACRO
InProcCheck %IF "%^PROC" === ""
              %ERROR ID=5926,'Macro "%0" is unexpected here.'
              %EXITMACRO ClearLocalVar
            %ENDIF
%GlbLvSize  %SET2 %%LvSize_%^PROC
            %IF %GlbLvSize  ; Do nothing if no LocalVar was used in this Procedure (%GlbLvSize=0).
              PUSH RCX,RDI
               LEA RDI,[RSP+2*8] ; Skip pushed RCX,RDI.
               MOV ECX,%GlbLvSize / 8
               XOR EAX,EAX
               REP STOSQ
              POP RDI,RCX
            %ENDIF
          %ENDMACRO ClearLocalVar
</pre>

<dl id="EndProcedure">
<dt><a href="#top">&uarr; EndProcedure</a> ProcName</dt>
<dd><p>Macro <dfn>EndProcedure</dfn> terminates context of the previously opened
<a href="#Procedure">Procedure
</a>. This epilogue of System V convention will</p><ul>
<li> discard local variables defined by <a href="#LocalVar">LocalVar</a> using machine instructions
<code>MOV RSP,RBP</code>,</li>
<li>restore callee-save registers saved by <a href="#Uses">Uses</a> with <code>POP registers</code>,</li>
<li>restore caller's frame pointer with <code>POP RBP</code> and then</li>
<li>return with near <code>RET</code> to the parent code
<!---->which the Procedure was invoked from.</li></ul>
<blockquote> Programmer should never use explicit machine instruction <code>RET</code>
 <!----> to return from the block defined with <code>Procedure .. EndProcedure</code>.
 <br/>If premature return is required, jump to the label of <code>EndProcedure
</code> statement instead.</blockquote>
</dd>
<dt>Input</dt><dd>
<b>ProcName</b> This macroinstruction requires exactly one operand
<!---->which is identical with the label of previous corresponding
<code>Procedure</code> statement.</dd>
<dt>Output</dt><dd>Stack frame is released, current process returns below
<code>Invoke</code> statement.</dd></dl><pre>
EndProcedure %MACRO ProcName
OpCheck    %IF %# <> 1
             %ERROR ID=5924, 'Macro "EndProcedure" requires one operand.'
             %EXITMACRO EndProcedure
           %ENDIF
%NameStrip %SET %ProcName
Decolonize %WHILE "%NameStrip[%&]" === ":" ; Get rid of trailing colon(s), if used.
%NameStrip   %SET %NameStrip[1..%&-1]
           %ENDWHILE Decolonize
NestCheck  %IF "%NameStrip" !=== "%^PROC"
             %ERROR ID=5925, 'Nesting mismatch, "%ProcName Procedure" missing.'
             %EXITMACRO EndProcedure
           %ENDIF NestCheck
%GlbLvSize %SET2 %%LvSize_%^PROC
           %IF %GlbLvSize
             ADD RSP,%GlbLvSize            ; Discard local variables.
           %ENDIF
%ThisUses  %SET2 %%Uses_%^PROC
           %IF "%ThisUses" <> ""
             POP %ThisUses                 ; Callee-save registers saved by macro Uses.
           %ENDIF
           POP RBP                         ; Restore caller's frame pointer.
           RET                             ; Return below Invoke which called %ProcName.
           ENDP %ProcName, NESTINGCHECK=OFF
         %ENDMACRO EndProcedure
</pre>

<dl id="Invoke"><dt><a href="#top">&uarr; Invoke</a> ProcName, Arg1, Arg2,,,</dt>
<dd><p>Macro <dfn>Invoke</dfn> is a replacement of standard CALL instruction which can pass parameters
<!----> to the Procedure in <strong>simplified System V convention
</strong>.
<p>Invoke walks through the list of arguments, starting with the first, and loads them either to
<!---->RDI,RSI,RDX,RCX,R8,R9 when they are integer, or to XMM0..XMM7 when they are floating-point.
<br/>Argument is treated as floating point when it is SIMD register or when it ends with suffix
<kbd>#SS</kbd> or <kbd>#SD</kbd>.</p>
<p>Stack pointer will be OWORD aligned before the CALL instruction is performed.
<br/>Epilogue of macro Invoke restores RSP to its original value.</p>
<dt>Input</dt><dd><b>ProcName</b> is the name of invoked procedure. This can be a function from
<!---->statically linked library or it can be
<!---->a block defined with Procedure, EndProcedure from this FastCall macrolibrary.
<br/><b>Arg*</b> can be a SIMD register or anything what can be copied to 64bit GPR:<ul>
<li>XMM register with floating-point value in its lower bits, for instance <code>XMM15</code>,</li>
<li>64bit GP register with integer value or pointer, for instance <code>RCX</code>,</li>
<li>immediate integer value, for instance <code>0</code> or <code>-11</code>,</li>
<li>numeric symbol, for instance <code>GMEM_FIXED</code>,</li>
<li>literal or address symbol, for instance <code>="Hello, world!"</code> or <code>MyCallback:</code>.</li>
<li>64bit memory variable, for instance <code>[RBP+32]</code> or <code>[MyTable+RSI]</code> or <code>[=Q 22.5]#SD</code>.</li>
</ul>It is programmer's responsibility to provide exactly that many arguments as is specified in Function documentation.
<br/>Any argument may be suffixed with type specificator <code>#SS</code> or <code>#SD</code> (case insensitive),
<!---->which signalizes that it represents floating-point value in <em>Scalar Single</em> or
<em>Scalar Double</em> precision format, and that it should be therefore passed to the Function in XMM register instead of GPR.
<br/>Suffix is not necessary with XMM register (argument passed in XMM is always assumed to contain floating-point number).
<br/><b>Fastmode=Yes</b> This keyword is tolerated for compatibility with other
<!---->macroinstructions, but it is ignored. Robust expansion mode is not supported by this macro.
</dd>
<dt>Output</dt><dd>Registers are set as returned from the invoked Function.
<br/><b>RBX,RBP,RSP,R12..R15</b> are preserved (callee-save registers).
<br/>Other SIMD and GPR are undefined.
</dd></dl><pre>
Invoke %MACRO Function, Arg1, Arg2,,, Fastmode=Yes
       PUSH RSP                            ; Store original stack pointer value (equilibrum).
       TEST SPL,1000b                      ; Test stack OWORD alignment at run-time.
FaEv   %IF %# & 1b                         ; If the number of Function arguments is 0,2,4,6,8,10,,(even),
         JZ .Invoke%.:                     ;   store 2nd copy of equilibrum when RSP is OWORD-unaligned.
       %ELSE FaEv                          ; If the number of arguments is 1,3,5,7,9,11,,, (odd),
         JNZ .Invoke%.:                    ;   store 2nd copy of equilibrum when RSP is OWORD-aligned.
       %ENDIF FaEv
       PUSH RSP                            ; Store and update 2nd copy of original RSP (equilibrum).
       ADDQ [RSP],8                        ; Those two instructions aren't executed if RSP was properly aligned.
.Invoke%.:
%GPR   %SET RDI,RSI,RDX,RCX,R8,R9          ; Enumerate registers for transfer of integer|pointer values.
%SIMD  %SET  XMM0,XMM1,XMM2,XMM3, \        ; Enumerate registers for transfer of floating-point values.
             XMM4,XMM5,XMM6,XMM7
%ArgNr %SETA 2                             ; Start with the 2nd operand, i.e. the 1st Function argument.
Arg     %WHILE %ArgNr <= %#
%Arg      %SET %*{%ArgNr}                  ; <b>Transfer all Function arguments</b>, start with the first one.
%suffix   %SET Q                           ; %suffix of MOV will be Q, SS or SD (MOVQ, MOVSS or MOVSD).
          %IF '%Arg[%&-2..%&-1]'=='#S'     ; If suffix #SS or #SD is present in argument notation,
%suffix     %SET %Arg[%&-1..%&]            ;  let %suffix be SS or SD
%Arg        %SET %Arg[1..%&-3]             ;  and remove it from the argument.
          %ENDIF                           ; %Arg may be GPR,SIMD,imm@abs,ptr@rel,[mem@abs],[mem@rel].
FaSc      %IF TYPE#(SEGMENT#(%Arg)) = 'N'  ; %Arg is not relocatable (scalar). It can be GPR,SIMD,imm@abs,[mem@abs].
FaScRg      %IF TYPE#(%Arg) = 'R'          ; %Arg is a GP or SIMD register.
FaScRgXm      %IF REGTYPE#(%Arg) = 'X'
                %IF "%SIMD{1}" !== "%Arg"  ; %Arg is XMM. Skip when it's already there.
                  MOV%suffix %SIMD{1},%Arg ; Copy SIMD %Arg to the first available SIMD (XMM0..XMM7).
%SIMD             %SET %SIMD{2..}          ; Remove the used register from the list.
                %ENDIF
              %ELSE FaScRgXm               ; %Arg is GPR.
                %IF "%GPR{1}" !== "%Arg"   ; Skip when it's already there.
                  MOV %GPR{1},%Arg         ; Copy GPR to the first available GPR from the list RDI,RSI,RDX,RCX,R8,R9.
%GPR              %SET %GPR{2..}           ; Remove the used register from the list.
                %ENDIF
              %ENDIF FaScRgXm
            %ELSE FaScRg                   ; %Arg is scalar immediate or [mem], e.g. 1 or [RBP+16].
FaScIm        %IF '%suffix' === 'Q'
                MOV %GPR{1},%Arg           ; %Arg is integer value.
%GPR            %SET %GPR{2..}             ; Remove the used register from the list.
              %ELSE FaScIm
                MOV%suffix %SIMD{1},%Arg   ; %Arg is FP value, e g. [RSI].
%SIMD             %SET %SIMD{2..}          ; Remove the used register from the list.
              %ENDIF FaScIm
            %ENDIF FaScRg
          %ELSE FaSc                       ; %Arg is relocatable (vector), e.g. Symbol or [Symbol+RSI].
FaVeM       %IF '%Arg[1]' === '['          ; Argument is passed by value, via this GPR.
              LEA %GPR{1},%Arg
              MOV %GPR{1},[%GPR{1}]        ; Dereference the argument value, transfer the value.
%GPR          %SET %GPR{2..}               ; Remove the used register from the list.
            %ELSE FaVeM                    ; Argument is passed by reference, e.g. Symbol.
              LEA %GPR{1},[%Arg]           ; Transfer the pointer.
%GPR          %SET %GPR{2..}               ; Remove the used register from the list.
            %ENDIF FaVeM
          %ENDIF FaSc
%ArgNr    %SETA %ArgNr + 1                 ; The next argument.
        %ENDWHILE Arg
        CALL %Function                     ; <b>Call the function</b>.
        POP RSP                            ; Restore RSP to equilibrum from 1st or 2nd copy.
      %ENDMACRO Invoke
</pre>

<pre>
  ENDHEAD sysvcall
</pre>
<!--TAILMENU-->
<!--Contents below the marker {!==TAILMENU==} was generated by "generate.php".-->
<br class='CLEAR'/><a id='bottom' href='#top'>&#x25B2;Back to the top&#x25B2;</a>
</body></html>
