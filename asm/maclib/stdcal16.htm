<!doctype html><html lang='en'><head>
<meta http-equiv='Content-Type' content='text/html; charset=utf-8'/>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=2.0, user-scalable=yes'>
<meta name='robots' content='ALL,FOLLOW'/>
<meta name='description' content='stdcal16.htm macro library'/>
<meta name='version' content='20250318'/>
<meta name='author' content='Pavel vitsoft Šrubař'/>
<link rel='stylesheet' href='../euroasm.css' type='text/css'/>
<link rel='shortcut icon' href='../favicon.ico'/>
<title>stdcal16.htm macro library</title>
</head>
<body class='MACLIB' id='top'><div class='HEADMENU'><table>
<tr><td rowspan='2' title='&euro;ASM - assembler and linker'><img src='../favicon.ico' alt='EuroAssembler' />
<td><a href='../index.htm' title='Alphabetical index of all &euro;ASM elements, directives and instructions'>Index</a></td>
<td><a href='../eadoc/' class='EADOC' title='Documentation of EuroAssembler'>Manual</a></td>
<td><a href='https://euroassembler.eu/download/' title='History &amp; download of the latest and previous versions'>Download</a></td>
<td><a href='../easource/' class='EASOURCE' title='Source files of EuroAssembler itself'>Source</a></td>
<td><a href='../maclib/' class='MACLIB' title='Macro libraries shipped with &euro;ASM'>Macros</a></td>
<td rowspan='2' title='Find the searched token in any text file on this site'>
<form method='post' action='../search.php' enctype='multipart/form-data' accept-charset='utf-8'>
<input type='text' id='q' placeholder='Searched word(s)' name='q' value=''/>
<br/><label title='Check the box to find the expression even if it is surrounded by other letters | digits.'>
<input type='checkbox' name='EW'/><small>Embedded word</small></label>
<br/><label title='Check the box for case-insensitive search.'>
<input type='checkbox' name='CI'/><small>Case ins.</small></label>
<input type='submit' title='Search for the specified word|expression in all site files.' name='find' value='Search'/>
</form></td></tr><tr>
<td><a href='../sitemap.htm' title='List of directories and files on this site'>Sitemap</a></td>
<td><a href='../eadoc/links.htm' class='EADOC' title='References and external links to resources used in EuroAssembler developement'>Links</a></td>
<td><a href='https://euroassembler.eu/forum/' title='Discussion forum concerning EuroAssembler'>Forum</a></td>
<td><a href='../eatests/' class='EATESTS' title='Program snippets for testing the function of &euro;ASM'>Tests</a></td>
<td><a href='../objlib/' class='OBJLIB' title='Skeletons and sample objects and projects shipped with &euro;ASM'>Projects</a></td>
</tr></table></div>
<!--Contents above the marker {!==/HEADMENU==} was generated by "generate.php".-->
<!--/HEADMENU-->
<h1>stdcal16.htm
<br/><i>Enumeration</i>
<br/><a href="#pcStdCall16">%StdCall16</a>
<br/><i>Macros</i>
<br/><a href="#ClearLocalVar">ClearLocalVar</a>
<br/><a href="#EndProcedure">EndProcedure</a>
<br/><a href="#Invoke">Invoke</a>
<br/><a href="#LocalVar">LocalVar</a>
<br/><a href="#Procedure">Procedure</a>
</h1>
<p>This file can be included to <strong>16bit programs</strong> written in EuroAssembler.
<!---->The library contains <strong>OS-independent</strong> macroinstructions
<code>Procedure, EndProcedure, Invoke</code> which extend generic pseudoinstructions
<code>PROC, ENDPROC, CALL</code>.</p>
<p>Macroinstructions <code>Procedure</code> and <code>EndProcedure</code> hide the prologue and epilogue of
<dfn>standard call</dfn> <a class="EXTL" href="../eadoc/links.htm#CallingConv">calling convention
</a>, where the arguments are pushed backwards and they are removed by the called procedure.</p>
<p>All GP registers are calee-saved by the Procedure. Result value of the invokation can be returned
<!---->from procedure by copying the value to stack-variables, such as
<code>%ReturnAX</code>, which is defined by <a href="#pcStdCall16">%StdCall16</a> as <code>BP+14</code>.
<p>  Macroinstructions in this library comunicate with one another
<!----> at assembly time using the preprocessing %variables
<code>%LvSize_<em>ProcName</em></code> (total size of all stack-variables) and
<code>ArgC_<em>ProcName</em></code> (number of procedure parameters).
<!----> Individualization of global %variable names allows to nest procedure definitions in one another.</p>
<br class="CLEAR"/><pre>
stdcal16 HEAD
</pre>
<dl id="pcStdCall16"><dt><a href="#top">&uarr; %StdCall16</a></dt>
<dd><p>Implementation of standard call convention in &euro;ASM
<!---->uses formal %names for accessing
<!---->Procedure parameters, local stack-memory variables and
<!---->all eight general-purpose registers saved on stack.</p>
<p>The following example shows the stack frame created by invoking Procedure with the name
<em>MyFn</em> which has three parameters and uses two local stack variables
<!---->with sizes 2 and 4. Prologue of <code>MyFn Procedure Param1, Param2, Param3
</code> will assign &quot;global&quot; %variables
<code>%ArgC_MyFn %SETA 3</code> and <code>%LvSize_MyFn %SETA 2+4
</code>, they can be used in macros <a href="#LocalVar">LocalVar</a>,
<a href="#ClearLocalVar">ClearLocalVar</a> and by epilogue in
<code>EndProcedure MyFn </code> during
<code> Invoke MyFn, Param1, Param2, Param3</code>.</dd>
<dd class="PRE">
<!---->MyFn Procedure Param1, Param2, Param3
<!---->LocV1 LocalVar        ; Reserve local stack variable with default size 2.
<!---->LocV2 LocalVar Size=4 ; Reserve another variable.
<!---->      ; MyFn body can use formal names Param1, Param2, Param3, LocV1, LocV2
<!---->      ;   to access its parameters and local stack variables by prefixing
<!---->      ;   the formal name with <kbd>%</kbd>, for instance
<!---->      MOV AX,[%Param1]
<!---->      MOV [%LocV1],AX
<!---->      ; Macro EndProcedure discards local variables, restores all GPR and returns below Invoke, removing the pushed arguments.
<!---->     EndProcedure MyFn
</dd><dd class="PRE">                       <abbr>SP after the step.</abbr>
<!---->                        <abbr>&#x2502;</abbr>
<!----> Prologue in 8 steps    <abbr>&#x2502;</abbr> Stack frame       Epilogue in 3 steps
<!---->                        <abbr>&#x2502;</abbr>
<!---->                      0.&gt;&#x250C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2510;&lt;12.continue below Invoke
<!---->1.PUSH Param3            &#x2502; %Param3  &#x2502;
<!---->                      1.&gt;&#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;
<!---->2.PUSH Param2            &#x2502; %Param2  &#x2502;
<!---->                      2.&gt;&#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;
<!---->3.PUSH Param1            &#x2502; %Param1  &#x2502;
<!---->                      3.&gt;&#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;
<!---->4.CALL Function          &#x2502; return   &#x2502;    12.RET 3*2
<!---->                      4.&gt;&#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;&lt;11.
<!---->5.PUSHAW                 &#x2502;%ReturnAX &#x2502;
<!---->                         &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;
<!---->                         &#x2502;%ReturnCX &#x2502;
<!---->                         &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;
<!---->                         &#x2502;%ReturnDX &#x2502;
<!---->                         &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;
<!---->                         &#x2502;%ReturnBX &#x2502;
<!---->                         &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;
<!---->                         &#x2502;%ReturnSP &#x2502;
<!---->                         &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;
<!---->                         &#x2502;%ReturnBP &#x2502;
<!---->                         &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;
<!---->                         &#x2502;%ReturnSI &#x2502;
<!---->                         &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;
<!---->6.MOV BP,SP              &#x2502;%ReturnDI &#x2502;     11.POPAW
<!---->                    5.6.&gt;&#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;&lt;10.
<!---->7.SUB SP,2               &#x2502; %LocV1   &#x2502;
<!---->                      7.&gt;&#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;
<!---->                         &#x2502;          &#x2502;
<!---->                         &#x2502;          &#x2502;
<!---->8.SUB SP,4               &#x2502; %LocV2   &#x2502;     10.MOV SP,BP
<!---->                      8.&gt;&#x2514;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2518;&lt;9.
<!---->
<!---->                      9.Function body
</dd></dl>
<pre>
; Formal %names assignment:
%Par8     %SET BP+32
%Par7     %SET BP+30
%Par6     %SET BP+28
%Par5     %SET BP+26
%Par4     %SET BP+24
%Par3     %SET BP+22
%Par2     %SET BP+20
%Par1     %SET BP+18
%ReturnAX %SET BP+14
%ReturnCX %SET BP+12
%ReturnDX %SET BP+10
%ReturnBX %SET BP+08
%ReturnSP %SET BP+06
%ReturnBP %SET BP+04
%ReturnSI %SET BP+02
%ReturnDI %SET BP+00
</pre>

 <dl id="Procedure"><dt><a href="#top">&uarr; Procedure</a> Operand1, Operand2,,,</dt>
<dd>This macro declares 16bit StdCall-procedure prolog which, unlike ordinary pseudoinstruction
<!---->PROC, accepts ordinal operands.
<br/>Macro operands will be assigned to preprocessing %variables
<!---->using the operand formal name prefixed with a percent sign.</dd>
<dt>Input</dt><dd>Label of <b>Procedure</b> statement is mandatory,
<!----> it gives the procedure an invokable name.
<br/><b>Operand*</b> is argument passed to the procedure. It can be anything pushable as WORD.
<!---->Number of operands is not limited.</dd>
<dt>Output</dt><dd>Macroinstruction will define global symbol, assign formal operands to %variables
<!---->and emit machine instructions <code>PUSHAW</code> and
<code>MOV BP,SP</code> as the procedure prolog.</dd>
<dt>Example</dt><dd class="PRE">Move Procedure Source,Destination,Size
<!---->    MOV SI,[%Source]
<!---->    MOV DI,[%Destination]
<!---->    MOV CX,[%Size]
<!---->    REP MOVSB
<!---->  EndProcedure Move
<!---->
<!---->  ; Procedure "Move" declared above can be invoked with three arguments, for instance
<!---->  Invoke Move, Greeting, Target, SIZE# Greeting
</dd><dd>Macro Procedure in the previous example will assign</dd>
<dd class="PRE">%ArgC_Move      %SET 3     ; This %variable propagates to macro EndProcedure and tells how many parameters should be discarded.
<!---->%LvSize_Move    %SETA 0    ; This %variable propagates to macros LocalVar and ClearLocalVar, if they're used in procedure body.
<!---->%Source         %SET BP+18 ; These are formal %variables of all operands.
<!---->%Destination    %SET BP+20
<!---->%Size           %SET BP+22
</dd></dl><pre>
Procedure %MACRO Operands ; Prologue of standard calling convention procedure.
LblCheck    %IF "%:" === ""
              %ERROR ID=5921, 'Macro "Procedure" requires a label.'
              %EXITMACRO Procedure
            %ENDIF LblCheck
%%ArgC_%:   %SETX %#
%%LvSize_%: %SETX 0
ArgNr       %FOR 1..%#, STEP= +1
%%%*{%ArgNr}  %SETX BP+(16+%ArgNr*2)
            %ENDFOR ArgNr
%:::        PROC %=*, NESTINGCHECK=OFF
            PUSHAW
            MOV BP,SP
          %ENDMACRO Procedure
</pre>

<dl id="LocalVar"><dt><a href="#top">&uarr; LocalVar</a> Size=2</dt>
<dd>reserves and declares local memory variable with the given Size allocated on machine stack.Example:</dd>
<dd class="PRE">ProcName: Procedure Arg1,Arg2,Arg3
<!---->  BlockSize LocalVar         ; %BlockSize is now assigned with <code>BP-2</code>
<!---->  Block     LocalVar Size=1K ; %Block is now <code>BP-1026</code>.
<!---->            ClearLocalVar    ; Fill Block and BlockSize with 0.
<!---->            MOV [%BlockSize],1K, DATA=WORD
<!---->            LEA DI,[%Block]  ; DI is now offset of Block in segment SS.
<!---->             ...
<!---->          EndProcedure ProcName</dd>
<dt>Input</dt><dd>Plain identifier must be defined as a label of
<b>LocalVar</b> statement. It does not need to be unique in the program
<!---->because it does not declare assembly symbol. The name will be
<!----> prefixed with <kbd>%</kbd> and used as preprocessing %variable
<!---->for addressing parameters withing the procedure body.
<br/><b>Size=</b>2 specifies how many bytes should be reserved for the local variable.
<!---->It is rounded up to WORD internally.</dd>
<dt>Output</dt><dd>Macro will define a preprocessing %variable with
<!---->the name which was defined as the label but it is now prefixed with percent sign.
<!---->Then it will emit machine instruction <code>SUB SP,%Size</code>
<!---->to reserve room on the machine stack.
<br/>Macro LocalVar also maintains the &quot;global&quot; variable
<code>%LvSize_<em>ProcName</em></code> which was initialized in macro <code>Procedure</code>.</dd></dl>
<pre>
LocalVar      %MACRO Size=2
LblCheck        %IF "%:"==""
                  %ERROR ID=5922, 'Macro "LocalVar" requires a label.'
                  %EXITMACRO LocalVar
                %ENDIF LblCheck
SizeCheck       %IF %#
                  %ERROR ID=5923, 'Macro "LocalVar" does not expect ordinal parameters.'
                  %EXITMACRO LocalVar
                %ENDIF SizeCheck
%:              %COMMENT                          ; This makes the label of macro invocation void
                %ENDCOMMENT %:                    ;  so it does not declare a symbol.
%ThisLvSize     %SETA (%Size + 1) & ~1            ; Round up to WORD.
%GlbLvSize      %SET2 %%LvSize_%^PROC+%ThisLvSize ; Accumulate total size of all LocalVar.
%%LvSize_%^PROC %SETX %GlbLvSize                  ; Update the &quot;global&quot; variable.
                SUB SP, %ThisLvSize               ; Allocate room on stack.
%%%:            %SETX BP-(%GlbLvSize)             ; Assign formal %name to the id specified with LocalVar label.
             %ENDMACRO LocalVar
</pre>

<dl id="ClearLocalVar">
<dt><a href="#top">&uarr; ClearLocalVar</a></dt>
<dd>This macro zeroes all variables on stack previously declared with
<a href="#LocalVar">LocalVar</a>. ClearLocalVar should be expanded
<!---->right after LocalVar declarations, before any stack operations are made.
<blockquote>We could as well decide to initialize each local variable individually,
<!---->in this case the macro ClearLocalVar will not be used in the Procedure body at all.
</blockquote></dd>
<dt>Input</dt><dd>Macro does not use explicit parameters.
<!---->Pointer to the cleared memory is specified with
<code>SS:SP</code>, cleared size is specified with &quot;global&quot; variable
<code>%LvSize_<em>ProcName</em></code>.</dd>
<dt>Output</dt><dd><b>AX=CX=</b>0,
<br/><b>DI</b>= SP + %LvSize_<em>ProcName</em></dd></dl><pre>
ClearLocalVar %MACRO
%GlbLvSize %SET2 %%LvSize_%^PROC
           %IF %GlbLvSize
             MOV DI,SP
             MOV CX,(%GlbLvSize) / 2
             PUSH ES,SS
               POP ES
               XOR AX,AX
               CLD
               REP STOSW
             POP ES
           %ENDIF
        %ENDMACRO ClearLocalVar
</pre>

<dl id="EndProcedure">
<dt><a href="#top">&uarr; EndProcedure</a> ProcName</dt>
<dd><p>Macro <dfn>EndProcedure</dfn> terminates context of the previously opened
<a href="#Procedure">Procedure
</a>. This epilogue of StdCall convention will discard local variables defined with
<a href="#LocalVar">LocalVar</a> (using machine instruction
<code>MOV SP,BP</code>), restore all GP registers (using
<code>POPAW</code>) and then return to the parent code
<!---->which the Procedure was Invoked from (using <code>RET 2*%ArgC_<em>ProcName</em></code>).
<br/>Operands pushed on stack in the <b>Invoke</b> statement
<!----> will be discarded here by this <b>EndProcedure</b> macro.
<br/>All registers are preserved throughout the procedure invocation
<!---->unless the procedure changed their stored value
<!---->on the stack frame (writing to <code>[%ReturnAX]</code> for instance).
<br/>CPU flags are not preserved, <b>EndProcedure</b> returns
<!---->with the same flag values which were set at the
<b>EndProcedure</b> entry.</p>
<blockquote> Programmer should never use explicit machine instruction <code>RET</code>
 <!----> to return from the block defined with <code>Procedure .. EndProcedure
</code>.  If premature return is required, jump to the label of <code>EndProcedure
</code> statement instead.</blockquote>
</dd>
<dt>Input</dt><dd>
<b>ProcName</b> This macroinstruction requires exactly one operand
<!---->which is identical with the label of previous corresponding
<code>Procedure</code> statement.</dd>
<dt>Output</dt><dd>Stack frame is released, current process returns below
<code>Invoke</code> statement.</dd></dl><pre>
EndProcedure %MACRO ProcName
OpCheck    %IF "%ProcName" === ""
             %ERROR ID=5924, 'Macro "EndProcedure" requires one operand.'
             %EXITMACRO EndProcedure
           %ENDIF OpCheck
%NameStrip %SET %ProcName
           %WHILE "%ProcNameStrip[%&]" === ":"
             %ProcNameStrip %SET %ProcNameStrip[1..%&-1] ; Get rid of trailing colons.
           %ENDWHILE
%ArgC      %SET2 %%ArgC_%NameStrip
NestChck   %IF "%ArgC" === ""
             %ERROR ID=5925, '"%ProcName Procedure" statement missing.'
             %EXITMACRO EndProcedure
           %ENDIF NestChck
           MOV SP,BP
           POPAW
           RET 2 * (%ArgC)
           ENDP %ProcName, NESTINGCHECK=OFF
         %ENDMACRO EndProcedure
</pre>

<dl id="Invoke"><dt><a href="#top">&uarr; Invoke</a> ProcName, Arg1, Arg2, ...</dt>
<dd><dfn>Invoke</dfn> is a replacement of standard CALL instruction which can pass parameters
<!----> to the Procedure. Arguments are pushed on stack as WORDs,
<!----> starting from the last. The procedure is then called
<!----> and it is responsible for removing pushed arguments from stack.
<br/>It is necessary to Invoke a procedure with exactly the same number
<!---->of arguments which were declared by the <a href="#Procedure">Procedure</a> macro.</dd>
<dt>Input</dt><dd><b>ProcName</b> The first operand is the name of invoked procedure.
<br/><b>Arg*</b> is a list of Procedure arguments.</dd>
<dt>Output</dt><dd>The returned registers and flags depend on the
<!---->invoked Procedure. By default all registers are preserved unless
<!---->they return some value.</dd>
</dl><pre>
Invoke %MACRO ProcName, Arguments
ArgCheck %IF "%ProcName" === ""
           %ERROR ID=5926, 'Macro "Invoke" requires the name of called Procedure.'
           %EXITMACRO Invoke
         %ENDIF ArgCheck
ArgNr    %FOR %#..2, STEP= -1
           PUSHW %*{%ArgNr}
         %ENDFOR ArgNr
         CALL %ProcName
       %ENDMACRO Invoke
</pre><pre>
  ENDHEAD stdcal16
</pre><!--TAILMENU-->
<!--Contents below the marker {!==TAILMENU==} was generated by "generate.php".-->
<br class='CLEAR'/><a id='bottom' href='#top'>&#x25B2;Back to the top&#x25B2;</a>
</body></html>
