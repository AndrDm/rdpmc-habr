<!doctype html><html lang='en'><head>
<meta http-equiv='Content-Type' content='text/html; charset=utf-8'/>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=2.0, user-scalable=yes'>
<meta name='robots' content='ALL,FOLLOW'/>
<meta name='description' content='winabi.htm macro library'/>
<meta name='version' content='20250318'/>
<meta name='author' content='Pavel vitsoft Šrubař'/>
<link rel='stylesheet' href='../euroasm.css' type='text/css'/>
<link rel='shortcut icon' href='../favicon.ico'/>
<title>winabi.htm macro library</title>
</head>
<body class='MACLIB' id='top'><div class='HEADMENU'><table>
<tr><td rowspan='2' title='&euro;ASM - assembler and linker'><img src='../favicon.ico' alt='EuroAssembler' />
<td><a href='../index.htm' title='Alphabetical index of all &euro;ASM elements, directives and instructions'>Index</a></td>
<td><a href='../eadoc/' class='EADOC' title='Documentation of EuroAssembler'>Manual</a></td>
<td><a href='https://euroassembler.eu/download/' title='History &amp; download of the latest and previous versions'>Download</a></td>
<td><a href='../easource/' class='EASOURCE' title='Source files of EuroAssembler itself'>Source</a></td>
<td><a href='../maclib/' class='MACLIB' title='Macro libraries shipped with &euro;ASM'>Macros</a></td>
<td rowspan='2' title='Find the searched token in any text file on this site'>
<form method='post' action='../search.php' enctype='multipart/form-data' accept-charset='utf-8'>
<input type='text' id='q' placeholder='Searched word(s)' name='q' value=''/>
<br/><label title='Check the box to find the expression even if it is surrounded by other letters | digits.'>
<input type='checkbox' name='EW'/><small>Embedded word</small></label>
<br/><label title='Check the box for case-insensitive search.'>
<input type='checkbox' name='CI'/><small>Case ins.</small></label>
<input type='submit' title='Search for the specified word|expression in all site files.' name='find' value='Search'/>
</form></td></tr><tr>
<td><a href='../sitemap.htm' title='List of directories and files on this site'>Sitemap</a></td>
<td><a href='../eadoc/links.htm' class='EADOC' title='References and external links to resources used in EuroAssembler developement'>Links</a></td>
<td><a href='https://euroassembler.eu/forum/' title='Discussion forum concerning EuroAssembler'>Forum</a></td>
<td><a href='../eatests/' class='EATESTS' title='Program snippets for testing the function of &euro;ASM'>Tests</a></td>
<td><a href='../objlib/' class='OBJLIB' title='Skeletons and sample objects and projects shipped with &euro;ASM'>Projects</a></td>
</tr></table></div>
<!--Contents above the marker {!==/HEADMENU==} was generated by "generate.php".-->
<!--/HEADMENU-->
<h1>winabi.htm
<br/><i>Macros</i>
<br/><a href="#GetArg">GetArg</a>
<br/><a href="#GetArgCount">GetArgCount</a>
<br/><a href="#MemAlloc">MemAlloc</a>
<br/><a href="#MemFree">MemFree</a>
<br/><a href="#PutArg">PutArg</a>
<br/><a href="#PutEnv">PutEnv</a>
<br/><a href="#StdInput">StdInput</a>
<br/><a href="#StdOutput">StdOutput</a>
<br/><a href="#TerminateProgram">TerminateProgram</a>
<br/><a href="#WinABI">WinABI</a>
</h1>
<p>MS Windows x64 Application Binary Interface macros.</p>
<p>This library contains macros for some basic OS interactions:
<!---->retrieving environment and command-line arguments, standard I/O, program termination, invocation of
<strong>64bit MS Windows Application Binary Interface</strong> as specified in
<a class="EXTL" href="../eadoc/links.htm#WinABI64">[WinABI64]</a>.</p>
<p>Programming interface macros represent elegant way of interaction with operating system
<!---->using only one single statement. Otherwise we would have to push or load appropriate registers
<!---->with argument values in the right order, store caller-save registers,
<!---->manually arrange stack alignment, call the imported function and finally restore the stack.</p>
<blockquote>Most macro names in this 64bit library <q>winabi.htm</q> are identical with
<!---->macros from 32bit library <a class="EXT" href="winapi.htm">winapi.htm
</a> and other API libraries. If you really need to include both libraries in one common source file,
<!---->definitions of those macros should be forgotten before inclusion of the other library with
<code>%DROPMACRO GetArg,GetArgCount,GetEnv,StdInput,StdOutput,TerminateProgram</code> or with
<code>%DROPMACRO *</code> in order to prevent warning
<kbd>W2512 Overwriting macro "!1S" previously defined at !2@</kbd>.</blockquote>

<br clear="all">
<pre>
winabi HEAD
       INCLUDEHEAD1 winansi.htm  ; Make sure that <a class="EXT" href="winansi.htm">%WinANSI</a> is available before WinABI invocation.
</pre>

<dl id="WinABI"><dt><a href="#top">&uarr; WinABI</a> &nbsp; Function, Argument1, Argument2,,,Unicode=%^UNICODE, Lib=, Fastmode=No</dt>
<dd><p>Macroinstruction <dfn>WinABI</dfn> invokes Function exported from MS Windows 64bit by
<a class="EXTL" href="../eadoc/links.htm#WindowsAPI">[WindowsAPI]</a> &nbsp; in the <dfn>FastCall
</dfn> calling convention compatible with
<a class="EXTL" href="../eadoc/links.htm#WinABI64">[WinABI64]</a>.</p>
<p> Ambiguous functions, which have both ANSI and WIDE variant, may be specified
<!---->with or without explicit suffix <kbd>A</kbd> or <kbd>W</kbd>.
<br/>Function may also be provided as a GPR with address of the function (pointer to its thunk in [.idata]).</p>
<p>The macro is similar to FastCall's <a class="EXT" href="fastcall.htm#Invoke">Invoke
</a> with two differences:</p><ol><li>If the Function name occurs on the
<a class="EXT" href="winansi.htm#WinANSI">%WinANSI</a> list, it will be suffixed with <kbd>A</kbd> or
<kbd>W</kbd>, depending on current <a class="EXT" href="../eadoc/index.htm#UNICODEeq">%Unicode</a> value.</li>
<li>The Function name will be declared as imported from library <code>Lib=</code>.</li></ol>
<p>WinABI functions require <em>Direction Flag</em> be zero on input and they do not change its value.
<br/>64bit Windows functions do not keep the original contents of flags, RCX, RDX, R8..R11,XMM0..XMM5,
<!---->but when this macro WinABI is invoked with keyword <code>Fastmode=No
</code> (default), it preserves all XMML and GP registers except for RAX and XMM0.</p>
<p>According to FastCall convention, arguments are pushed backwards on stack as QWORDs,
<!----> starting from the last to the fifth. The first four parameters are loaded to RCX, RDX, R8, R9
<!---->and not pushed on stack. Nevertheless, room for the first four arguments is always reserved on stack
<!---->(so called <em>shadow space</em>) even when the invoked function has less than four arguments.
<br/>When the Function expects argument in floating-point format instead of integer, pointer or immediate,
<!---->the first four arguments are loaded to XMM0, XMM1, XMM2, XMM3 rather than to GPR.
<br/>Stack pointer will be OWORD aligned before the CALL instruction is performed.</p>
<p>Invoked function does not remove arguments from stack, it terminates with a simple near RET.
<!---->Epilogue of macro WinABI restores RSP to its original value.</p>
<dt>Input</dt><dd><b>Function</b> is the name of invoked WinAPI procedure imported from system DLL
<br/>Function may also be provided in the form of GPR containing the entry address of the function
<!---->(pointer to its thunk in [.idata] section). Import from DLL by ordinal number is not supported.
<br/><b>Arg*</b> can be a SIMD register or anything pushable:<ul>
<li>XMM register with floating-point value in its lower bits, for instance <code>XMM15</code>,</li>
<li>64bit GP register with integer value or pointer, for instance <code>RBX</code>,</li>
<li>segment register <code>FS</code> or <code>GS</code>,</li>
<li>32bit immediate integer value (it will be sign-extended by CPU), for instance
<code>0</code> or <code>-11</code>,</li>
<li>numeric symbol, for instance <code>GMEM_FIXED</code>,</li>
<li>literal or address symbol, for instance <code>="Hello, world!"</code> or <code>MyCallback:</code>.</li>
<li>64bit memory variable, for instance <code>[RBP+32]</code> or <code>[MyTable+RSI]</code> or <code>[=Q 22.5]#SD</code>.</li>
</ul>It is programmer's responsibility to provide exactly that many arguments as is specified in WinAPI documentation.
<br/>Any argument may be suffixed with type specificator <code>#SS</code> or <code>#SD</code> (case insensitive),
<!---->which signalizes that it represents floating-point value in <em>Scalar Single</em> or
<em>Scalar Double</em> precision format, and that it should be therefore passed to the Function in XMM register instead of GPR.
<br/>Suffix is not necessary with XMM register (argument passed in XMM is always assumed to contain floating-point number).
<br/>Suffix is not necessary when Fastmode=No, because the robust version transfers the first four arguments
<!---->simultaneously in SIMD and GP registers anyway, no matter if they are float or integer.
<br/>Suffix is not necessary in 5th and higher arguments in both modes (they are passed via machine stack regardless of their type).
<br/><b>Unicode=%^UNICODE</b> is an <a class="EXT" href="../eadoc/#BooleansExt">extended Boolean
</a> switch which specifies if ANSI or WIDE variant of Function should be called. By default it
<!---->copies the option set by <code>EUROASM UNICODE=</code>.
<br/><b>Lib=</b> is the name of dynamic linked library (quoted or unquoted, always without path)
<!---->which exports the invoked Function. This keyword may be empty or omitted <ul><li>if the library is
<q>kernel32.dll</q>, or</li><li>if the Function is explicitly declared somewhere in the program, e.g. with
<code>IMPORT Function, Lib=user32.dll</code>, or</li>
<li>if the Function is declared in some import library linked to the program. Example of such library is
<q>objlib\winapi.lib</q> created by the script <a class="EXT" href="../prowin32/dll2lib.htm">dll2lib.htm</a>.
</li></ul>
<b>Fastmode=No</b> is an <a class="EXT" href="../eadoc/#BooleansExt">extended Boolean</a> switch. When it's
<em>false</em> or omitted (default),
<!---->the WinABI macro preserves all registers except for RAX and XMM0 which return the result of Function,
<!---->similary to other robust macros from EuroAssembler libraries.
<br/>Although Microsoft ABI specifies fastcall convention with floating-point parameters %1..%4
<!---->delivered in XMM0, XMM1, XMM2, XMM3, and with parameters %1..%4 of all other types delivered in RCX, RDX, R8, R9,
<!---->arguments of WinABI in robust mode (Fastmode=No) may be supplied in those registers too in arbitrary order, for instance
<code> WinABI MessageBox,RDX,R8,R8,MB_OK</code>.
<br/><b>Fastmode=Yes</b> is the macro expansion mode where Invoke | WinABI does not preserve caller-save registers and
<!---->it loads the first four arguments directly to
<code>XMM0, XMM1, XMM2, XMM3</code> when they are floating-point values, and to
<code>RCX, RDX, R8, R9</code> in all other cases, so the invokation is faster.
<!---->Registers RCX, RDX, R8, R9, XMM0..XMM3 cannot be used as macro arguments,
<!---->because they are being overwritten in prologue. Or they should be only used in the exact ABI-specified order, e.g.
<code>WinABI Function, RCX, XMM1, R8, XMM3</code>.
<!---->Similary, registers RCX, RDX, R8, R9 cannot be used instead of Function name in fast mode. Use other GPR, e.g.
<code><br/>IMPORT WriteConsoleW,Lib=kernel32.dll
<br/>LEA RDI, [WriteConsoleW]
<br/>WinABI Fastmode=Yes, RDI, RBX, Message, SIZE# Message, WrittenChars, 0</code>
</dd>
<dt>Output</dt><dd><b>RAX, XMM0, RFlags</b> are set as returned from the invoked Function.
<br/><b>RBX,RBP,RSP,RSI,RDI,R12..R15,XMM6..XMM15</b> are preserved (callee-save registers).
<br/>Other XMM and GPR are preserved only if Fastmode=No.</dd>
<dt>Depends on</dt><dd><a class="EXT" href="winansi.htm#WinANSI">WinANSI</a></dd>
<dt>Documentation</dt><dd>Windows functions are documented in
<a class="EXTL" href="../eadoc/links.htm#WindowsSDK">[WindowsSDK]</a> and in
<a class="EXTL" href="../eadoc/links.htm#WindowsAPI">[WindowsAPI]</a>.
<br/>Microsoft FastCall convention is described in
<a class="EXTL" href="../eadoc/links.htm#WinABI64">[WinABI64]</a> and
<a class="EXTL" href="../eadoc/links.htm#MSx64Conv">[MSx64Conv]</a>.</dd>
<dt>Example</dt><dd>Expansion of WinABI invokation of the function CreateFile with seven arguments in both modes:
<code> WinABI CreateFileA, FileName, GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0</code>
 <samp>|                          | ; <b>Fast Version</b>.
<!---->|00000000:                 |   WinABI CreateFileA, FileName, GENERIC_READ, FILE_SHARE_READ, 0, \
<!---->|00000000:                 |                       OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,0, Fastmode=Yes
<!---->|00000000:54               +          PUSH RSP                    ; Store original stack pointer value (equilibrum).
<!---->|00000001:40F6C408         +          TEST SPL,1000b              ; Test RSP OWORD alignment at run-time.
<!---->|00000005:7506             +          JNZ .WinABI1:
<!---->|00000007:54               +          PUSH RSP                    ; Store and update 2nd copy of original RSP (equilibrum).
<!---->|00000008:4883042408       +          ADDQ [RSP],8                ; Those two instructions aren't executed if RSP was properly aligned.
<!---->|0000000D:                 + .WinABI1:
<!---->|0000000D:6A00             +          PUSHQ 0                     ; Push 7th argument.
<!---->|0000000F:6880000000       +          PUSHQ FILE_ATTRIBUTE_NORMAL ; Push 6th argument.
<!---->|00000014:6A03             +          PUSHQ OPEN_EXISTING         ; Push 5th argument.
<!---->|00000016:41B900000000     +          MOV R9,0                    ; Load 4th argument.
<!---->|0000001C:41B801000000     +          MOV R8,FILE_SHARE_READ      ; Load 3rd argument.
<!---->|00000022:BA00000080       +          MOV RDX,GENERIC_READ        ; Load 2nd argument.
<!---->|00000027:488D0D(00000000) +          LEA RCX,[FileName]          ; Load 1st argument.
<!---->|0000002E:4883EC20         +          SUB RSP,4*8                 ; Make room for <b>shadow space in fast mode</b>. RSP is OWORD-aligned.
<!---->|00000032:E8(00000000)     +          CALL CreateFileA            ; <b>Call the imported function</b>.
<!---->|00000037:488D642438       +          LEA RSP,[RSP+7*8]           ; Discard transferred arguments, keep RFlags.
<!---->|0000003C:5C               +          POP RSP                     ; Restore RSP to equilibrum from 1st or 2nd copy.
<!---->|0000003D:                 | ; WinABI in fast mode occupies 61 bytes of code.
</samp>
<samp>|00000000:                 | ; <b>Robust version</b>.
<!---->|00000000:                 |   WinABI CreateFileA, FileName, GENERIC_READ, FILE_SHARE_READ, 0, \
<!---->|00000000:                 |                       OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,0, Fastmode=No
<!---->|00000000:6A00             +          PUSHQ 0                     ; Push 7th argument.
<!---->|00000002:6880000000       +          PUSHQ FILE_ATTRIBUTE_NORMAL ; Push 6th argument
<!---->|00000007:6A03             +          PUSHQ OPEN_EXISTING         ; Push 5th argument
<!---->|00000009:6A00             +          PUSHQ 0                     ; Push 4th argument
<!---->|0000000B:6A01             +          PUSHQ FILE_SHARE_READ       ; Push 3rd argument
<!---->|0000000D:6800000080       +          PUSHQ GENERIC_READ          ; Push 2nd argument
<!---->|00000012:50               +          PUSH RAX                    ; Alloc 1st argument on stack.
<!---->|00000013:488D05(00000000) +          LEA RAX,[FileName]          ; Load 1st argument.
<!---->|0000001A:48870424         +          XCHG RAX,[RSP]              ; Transfer the pointer without clobbering RAX.
<!---->|0000001E:6A07             +          PUSHQ 7                     ; Push the number of arguments.
<!---->|00000020:488D05(00000000) +          LEA RAX,[CreateFileA]       ; Load the function address (pointer to its thunk in [.idata]).
<!---->|00000027:E805000000       +          CALL WinABI@RT              ; <b>Call the runtime</b> with function in RAX.
<!---->|0000002C:488D642440       +          LEA RSP,[RSP+8*8]           ; Restore stack to equilibrum, preserving RFlags.
<!---->|00000031:                 | ; WinABI in robust mode occupies 49 bytes of code (plus 190 bytes of runtime code, once per program).
</samp></dd>
<dt>Remark</dt><dd>Macro WinABI can be expanded in one of two modes:
<ul><li><strong>Fast</strong> where the first four arguments are loaded directly to fixed registers
<!---->according to ABI specification and all scratch registers are destroyed.
<!---->Arguments %1..%4 are copied to transfer registers with <code>MOV reg,value</code>(5 bytes).
<!---->64bit pointers are transferred by the help of temporary register with
<code>LEA reg,[address]</code> using RIP-relative addressing (7 bytes) resolvable at link time.</li>
<li><strong>Robust</strong> mode uses its own runtime procedure
<!---->for preservation of scratch registers and allows to use them
<!---->for passing of arguments in arbitrary order. Small scalar arguments are copied
<!---->to the transfer registers with <code>PUSH value ; POP reg</code> (2+1 bytes).</li></ul>
<p>Selection of the mode depends on optimisation criterion:<ul>
<li>If you optimise for speed, use Fastmode=Yes.</li>
<li>If you optimise for programmer's convenience, use Fastmode=No.</li>
<li>If you optimise for code size, it depends on the number and type of arguments:</li></ul>
<table><caption>Examples of a few typical OS invocations and their emitted sizes in bytes:</caption>
<tr><th>Example of Windows function invocation</th><th>Number<br/>of args</th>
<th>WinABI<br/>Fastmode=Yes</th><th>WinABI<br/>Fastmode=No</th></tr>
<tr><td><code>GetCursor</code></td><td>0</td><td>28</td><td>19</td></tr>
<tr><td><code>SetArcDirection, [hDC], AD_CLOCKWISE</code></td><td>2</td><td>43</td><td>36</td></tr>
<tr><td><code>MessageBox, NULL, Text, Caption, MB_OK</code></td><td>4</td><td>53</td><td>47</td></tr>
<tr><td><code>AngleArc, [hDC], 100, 120, R9, [StartAngle]#SS, XMM14#SS</code></td><td>6</td><td>74</td><td>65</td></tr>
<tr><td><code>CreateFile, FileName, GENERIC_READ, FILE_SHARE_READ, 0, \
<br/> OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0</code></td><td>7</td><td>61</td><td>49</td></tr>
</table><p>Robust variant of WinABI is often shorter, but it emits 190 additional bytes
<!---->of runtime procedure (only once in a program), so it is profitable when we have
<!---->more than cca twenty Windows invocations in the program. Robust variant may also spare
<!---->some push/pops because it doesn't change any scratch registers.</p>
<blockquote>When you want to switch on the Fastmode for all WinABI invokations, you don't have to append
<code>,Fastmode=Yes</code> to every invokation of <code>WinABI</code> or <code>Invoke
</code>, if you set preprocessing variable %Fastmode in the beginning of your program:
<code>%Fastmode %SETB On</code>.</blockquote>
</dd>
<dt id="WinABI_StackAlignment">Stack alignment</dt><dd>Fastcall convention requires that stack-pointer RSP should be OWORD (16 bytes) aligned
<!---->before the function is called. In fast mode this is provided by pushing RSP once or twice in macro prologue.
<br/>Robust mode postpones the actual function call to its runtime procedure Invoke@RT, so the RSP alignment
<!---->takes place there.</dd>
<dt>Stack layout of WinABI and Invoke when Fastmode=Yes</dt><dd class="PRE"> WinABI Function, Arg1,Arg2,Arg3,Arg4,Arg5,Arg6,Fastmode=Yes
<!----> &#x250C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2510;
<!----> &#x2502;OrigRSP &#x2502; &lt;&#x2500;&#x2500;Only present if RSP was OWORD unaligned.
<!----> &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;
<!----> &#x2502;OrigRSP &#x2502;
<!----> &#x255E;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2561; &lt;&#x2550;&#x2550;RSP is OWORD aligned here.
<!----> &#x2502; Arg6   &#x2502;
<!----> &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;
<!----> &#x2502; Arg5   &#x2502;
<!----> &#x255E;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2561;  &#x2510;
<!----> &#x2502; undef  &#x2502;  &#x2502;
<!----> &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;  &#x2502;
<!----> &#x2502; undef  &#x2502;  &#x251C;&#x2500;Shadow space.
<!----> &#x255E;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2561;  &#x2502;
<!----> &#x2502; undef  &#x2502;  &#x2502;
<!----> &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;  &#x2502;
<!----> &#x2502; undef  &#x2502;  &#x2502;
<!----> &#x255E;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2561;  &#x2518;
<!----> &#x2502; return &#x2502;
<!----> &#x2514;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2518;
</dd>

<dt>Stack layout of WinABI and Invoke when Fastmode=No</dt><dd class="PRE"> WinABI Function, Arg1,Arg2,Arg3,Arg4,Arg5,Arg6,Fastmode=No
<!----> &#x250C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2510;  &#x2510;
<!----> &#x2502; Arg6   &#x2502;  &#x2502;
<!----> &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;  &#x2502;
<!----> &#x2502; Arg5   &#x2502;  &#x2502;
<!----> &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;  &#x2502;
<!----> &#x2502; Arg4   &#x2502;  &#x2502;
<!----> &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;  &#x2502;
<!----> &#x2502; Arg3   &#x2502;  &#x251C;&#x2500;Frame of Invoke@RT.
<!----> &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;  &#x2502;
<!----> &#x2502; Arg2   &#x2502;  &#x2502;
<!----> &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;  &#x2502;
<!----> &#x2502; Arg1   &#x2502;  &#x2502;
<!----> &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;  &#x2502;
<!----> &#x2502;NrOfArg &#x2502;  &#x2502;   NrOfArg=6 in this example.
<!----> &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;  &#x2518;
<!----> &#x2502;RET(@RT)&#x2502;
<!----> &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;  &#x2510;
<!----> &#x2502; RSI    &#x2502;  &#x2502;
<!----> &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;  &#x2502;
<!----> &#x2502; RDI    &#x2502;  &#x2502;
<!----> &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;  &#x2502;
<!----> &#x2502; R12    &#x2502;  &#x2502;
<!----> &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;  &#x2502;
<!----> &#x2502; RCX    &#x2502;  &#x2502;
<!----> &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;  &#x2502;
<!----> &#x2502; RDX    &#x2502;  &#x2502;
<!----> &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;  &#x2502;
<!----> &#x2502; R8     &#x2502;  &#x2502;
<!----> &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;  &#x2502;
<!----> &#x2502; R9     &#x2502;  &#x2502;
<!----> &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;  &#x2502;
<!----> &#x2502; R10    &#x2502;  &#x2502;
<!----> &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;  &#x2502;
<!----> &#x2502; R11    &#x2502;  &#x251C;&#x2500;Local stack
<!----> &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;  &#x2502; of Invoke@RT.
<!----> &#x2502; XMM1L  &#x2502;  &#x2502;
<!----> &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;  &#x2502;
<!----> &#x2502; XMM2L  &#x2502;  &#x2502;
<!----> &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;  &#x2502;
<!----> &#x2502; XMM3L  &#x2502;  &#x2502;
<!----> &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;  &#x2502;
<!----> &#x2502; XMM4L  &#x2502;  &#x2502;
<!----> &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;  &#x2502;
<!----> &#x2502; XMM5L  &#x2502;  &#x2502;
<!----> &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;  &#x2502;  &#x2510;
<!----> &#x2502;(align) &#x2502;  &#x2502;  &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;Only present if RSP is OWORD-unaligned.
<!----> &#x255E;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2561;  &#x2518;  &#x2518;  &#x2500;&#x2510;
<!----> &#x2502; Arg6   &#x2502;         &#x2502;
<!----> &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;         &#x2502;
<!----> &#x2502; Arg5   &#x2502;         &#x2502;
<!----> &#x255E;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2561; &#x2510;       &#x2502;
<!----> &#x2502; Arg4   &#x2502; &#x2502;       &#x2502;
<!----> &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524; &#x2502;       &#x251C;&#x2500;Frame of Function.
<!----> &#x2502; Arg3   &#x2502; &#x2502;       &#x2502;
<!----> &#x255E;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2561; &#x251C;Shadow &#x2502;
<!----> &#x2502; Arg2   &#x2502; &#x2502; space &#x2502;
<!----> &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524; &#x2502;       &#x2502;
<!----> &#x2502; Arg1   &#x2502; &#x2502;       &#x2502;
<!----> &#x255E;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2561; &#x2518;      &#x2500;&#x2518; &lt;&#x2550;&#x2550; RSP is OWORD-aligned here.
<!----> &#x2502;RET(API)&#x2502;
<!----> &#x2514;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2518;
</dd></dl>
<pre>
WinABI %MACRO Function, Arg1, Arg2,,, Fastmode=%Fastmode, Unicode=%^UNICODE, Lib=
%Fast   %SETB %Fastmode
%Robust %SETB ! %Fast
Fa      %IF %Fast                       ; <b>Align stack in fast mode</b> only.
          PUSH RSP                      ; Store original stack pointer value (equilibrum).
          TEST SPL,1000b                ; Test stack OWORD alignment at run-time.
FaEv      %IF %# & 1b || %# <= 5        ;>If the number of Function arguments is 0,1,2,3,4,6,8,10,,(even),
            JZ .WinABI%.:               ;   store 2nd copy of equilibrum when RSP is OWORD-unaligned.
          %ELSE FaEv                    ; If the number of arguments is 5,7,9,11,,, (odd),
            JNZ .WinABI%.:              ;   store 2nd copy of equilibrum when RSP is OWORD-aligned.
          %ENDIF FaEv
          PUSH RSP                      ; Store and update 2nd copy of original RSP (equilibrum).
          ADDQ [RSP],8                  ; Those two instructions aren't executed if RSP was properly aligned.
.WinABI%.:
        %ENDIF Fa
%GPR    %SET  RCX,RDX,R8,R9             ; Enumerate registers for transfer of integer|pointer values.
%SIMD   %SET  XMM0,XMM1,XMM2,XMM3       ; Enumerate registers for transfer of floating-point values.
%ArgNr  %SETA %#                        ; Number of macro ordinals, i.e. number of Function arguments + 1.
Arg     %WHILE %ArgNr > 1
%Arg     %SET %*{%ArgNr}                ; <b>Transfer all Function arguments</b>, start with the last one.
%ArgNr   %SETA %ArgNr-1                 ; %ArgNr is now the ordinal Nr of Function argument (,,3,2,1).
%suffix  %SET Q                         ; %suffix of MOV will be Q, SS or SD (MOVQ, MOVSS or MOVSD).
         %IF '%Arg[%&-2..%&-1]'=='#S'   ; If suffix #SS or #SD is present in argument notation,
%suffix    %SET %Arg[%&-1..%&]          ;  let %suffix be SS or SD
%Arg       %SET %Arg[1..%&-3]           ;  and remove it from the argument.
         %ENDIF                         ; %Arg may be GPR,SIMD,imm@abs,ptr@rel,[mem@abs],[mem@rel].
Rb       %IF %ArgNr>4 || %Robust        ; <b>Transfer %Arg via stack</b>.
RbSc       %IF TYPE#(SEGMENT#(%Arg))='N'; %Arg is not relocatable (scalar).
RbScRg       %IF TYPE#(%Arg)='R'        ; It can be GPR,SIMD,imm@abs,[mem@abs].
RbScRgXm       %IF REGTYPE#(%Arg)='X'   ; %Arg is a GP or SIMD register.
                 SUB RSP,8
                 MOV%suffix [RSP],%Arg  ; %Arg is a SIMD register.
               %ELSE RbScRgXm
                 PUSHQ %Arg             ; %Arg is a GP register.
               %ENDIF RbScRgXm
             %ELSE RbScRg               ; %Arg it not a register.
               PUSHQ %Arg               ; %Arg is scalar immediate or [mem], e.g. 1 or [RBP+16].
             %ENDIF RbScRg
           %ELSE RbSc                   ; %Arg is relocatable (vector), e.g. Symbol or [Symbol+RSI].
RbVeM        %IF '%Arg[1]' === '['      ; Argument is passed by value, via a temporary GPR.
               PUSH RAX                 ; Original contents of the borrowed RAX must be kept.
               LEA RAX,%Arg             ; Use relative addressing frame for relocatable %Arg.
               MOV RAX,[RAX]            ; Dereference the argument value.
               XCHG RAX,[RSP]           ; Transfer the value.
             %ELSE RbVeM                ; Relocatable argument is passed by reference, e.g. Symbol.
               PUSH RAX                 ; Original contents of the borrowed RAX must be kept.
               LEA RAX,[%Arg]           ; Use relative addressing frame for relocatable %Arg.
               XCHG RAX,[RSP]           ; Transfer the pointer.
             %ENDIF RbVeM
           %ENDIF RbSc
         %ELSE Rb                       ; Fastmode=Yes and %ArgNr=4,3,2,1. <b>Transfer via registers</b>.
FaSc       %IF TYPE#(SEGMENT#(%Arg))='N'; %Arg is not relocatable (scalar).
FaScRg       %IF TYPE#(%Arg)='R'        ; It can be GPR,SIMD,imm@abs,[mem@abs].
FaScRgXm       %IF REGTYPE#(%Arg)='X'   ; %Arg is a GP or SIMD register.
                 %IF "%SIMD{%ArgNr}" !== "%Arg"  ; %Arg is XMM. Skip when it's already there.
                   MOV%suffix %SIMD{%ArgNr},%Arg ; Copy SIMD %Arg to other SIMD (XMM0..XMM3).
                 %ENDIF
               %ELSE FaScRgXm           ; %Arg is GPR.
                 %IF "%GPR{%ArgNr}" !== "%Arg"   ; Skip when it's already there.
                    MOV %GPR{%ArgNr},%Arg        ; Copy GPR to other GPR (R9,R8,RDX,RCX).
                 %ENDIF
               %ENDIF FaScRgXm
             %ELSE FaScRg               ; %Arg is scalar immediate or [mem], e.g. 1 or [RBP+16].
FaScIm         %IF '%suffix' === 'Q'
                 MOV %GPR{%ArgNr},%Arg  ; %Arg is integer value.
               %ELSE FaScIm
                 MOV%suffix %SIMD{%ArgNr},%Arg ; %Arg is FP value, e g. [RSI].
               %ENDIF FaScIm
             %ENDIF FaScRg
           %ELSE FaSc                   ; %Arg is relocatable (vector), e.g. Symbol or [Symbol+RSI].
FaVeM        %IF '%Arg[1]' === '['      ; Argument is passed by value, via this GPR.
               LEA %GPR{%ArgNr},%Arg
               MOV %GPR{%ArgNr},[%GPR{%ArgNr}] ; Dereference the argument value, transfer the value.
             %ELSE FaVeM                ; Argument is passed by reference, e.g. Symbol.
               LEA %GPR{%ArgNr},[%Arg]  ; Transfer the pointer.
             %ENDIF FaVeM
           %ENDIF FaSc
         %ENDIF Rb
        %ENDWHILE Arg                   ; All arguments are loaded|pushed.
%sfx    %SET                            ; <kbd>A</kbd> or <kbd>W</kbd> Function suffix. Empty by default.
reg     %IF REGTYPE# %Function = 'Q'    ; Function was specified as 64bit GPR.
          %IF "%Function"=="RCX"||"%Function"=="RDX"||"%Function"=="R8"||"%Function"=="R9"
            %ERROR ID=5956,'%0 function cannot be supplied in scratch register %Function when Fastmode=Yes.'
            %EXITMACRO Invoke
          %ENDIF
        %ELSE reg                       ; Function was specified by name.
fn        %FOR %WinANSI
found       %IF '%fn' === '%Function'
              %IF %Unicode
%sfx            %SETC 'W'
              %ELSE
%sfx            %SETC 'A'
              %ENDIF
              %EXITFOR fn               ; No need for further examination of the list.
            %ENDIF found
          %ENDFOR fn                    ; %sfx is now A or W or empty.
          IMPORT %Function%sfx, Lib=%Lib
        %ENDIF reg
Fa      %IF %Fast
          SUB RSP,4*8                   ; Make room for <b>shadow space in fast mode</b>. RSP is OWORD-aligned.
          CALL %Function%sfx            ; <b>Call the function</b> in fast mode.
          %IF %# > 5
            LEA RSP,[RSP+8*(%#-1)]      ; Discard transferred arguments, keep RFlags.
          %ELSE
            LEA RSP,[RSP+8*4]           ; Discard transferred arguments, keep RFlags.
          %ENDIF
          POP RSP                       ; Restore RSP to equilibrum from 1st or 2nd copy.
        %ELSE Fa                        ; In <b>robust mode</b> use helper runtime procedure WinABI@RT.
          PUSHQ %#-1                    ; Push the number of Function arguments.
RbRg      %IF REGTYPE# %Function = 'Q'  ; Function was specified as 64bit GPR.
            %IF '%Function' !== 'RAX'   ; Skip if it's already in RAX.
              MOV RAX,%Function
            %ENDIF
          %ELSE RbRg
            LEA RAX,[%Function%sfx]     ; RVA of the Function (pointer to its thunk in [.idata]).
          %ENDIF RbRg
          CALL WinABI@RT                ; Arguments+their number are on stack. Function is in RAX.
          LEA RSP,[RSP + 8 * %#]        ; Restore stack to equilibrum, preserving RFlags.
WinABI@RT: PROC1                        ; Macro emits the <b>runtime subroutine</b>, which is expanded only once in program.
            PUSH RSI,RDI,R12            ; Calee-save registers used by WinABI@RT procedure.
            PUSH RCX,RDX,R8,R9,R10,R11  ; Robust version preserves scratch GP registers.
            MOVQ RDX,XMM1
            MOVQ  R8,XMM2
            MOVQ  R9,XMM3
            MOVQ R10,XMM4
            MOVQ R11,XMM5
            PUSH RDX,R8,R9,R10,R11      ; Robust version preserves scratch SIMD registers.
            MOV ECX,[RSP+15*8]          ; Number of Function arguments.
            LEA RSI,[RSP+16*8]          ; Pointer to %Arg1 in WinABI@RT stack frame.
            CMP ECX,4                   ; Number of arguments is 0|1|2|3|4|5|6...
            JAE .AtLeast4:
            MOV CL,4                    ; Number is saturated to 4|4|4|4|4|5|6...
  .AtLeast4:MOV R12,RSP                 ; Save (perhaps unaligned) RSP to callee-preserved register.
            ; <b>Align stack pointer</b> as dictated by ABI specification.
            MOV EDX,ECX                 ; Saturated number of operands (4,5,6,,,).
            SHL EDX,3                   ; RDX bit 3 is set if saturated number of arguments is odd (5,7,9,,).
            XOR EDX,ESP                 ; RDX will be 8 when number of arguments is even and RSP is OWORD unaligned,
            AND EDX,0000_1000b          ;   or when it's odd and RSP is already OWORD aligned. Otherwise RDX=0.
            SUB RSP,RDX                 ; Align RSP to OWORD.
            ; <b>Copy ECX arguments from RSI to the callee's shadow space</b>.
            MOV EDX,ECX
            SHL EDX,3
            SUB RSP,RDX                 ; Alloc Function frame (<b>shadow space</b> + possible other arguments).
            MOV RDI,RSP                 ; RSP is OWORD aligned at this moment.
            REP MOVSQ                   ; Copy all pushed arguments.
            ; <b>Load first four arguments to GP registers</b>.
            MOVQ RCX,[RSP+00]
            MOVQ RDX,[RSP+08]
            MOVQ R8, [RSP+16]
            MOVQ R9, [RSP+24]
            ; <b>Copy first four arguments to SIMD registers</b> (for the case they were floating-point).
            MOVQ XMM0,RCX
            MOVQ XMM1,RDX
            MOVQ XMM2,R8
            MOVQ XMM3,R9
            CALL RAX                    ; <b>Call the Function</b> in robust mode.
            MOV RSP,R12                 ; Discard Function frame plus possible stack-alignment stuff.
            POP R11,R10,R9,R8,RDX
            MOVQ XMM5,R11
            MOVQ XMM4,R10
            MOVQ XMM3,R9
            MOVQ XMM2,R8
            MOVQ XMM1,RDX               ; Restore SIMD scratch registers.
            POP R11,R10,R9,R8,RDX,RCX   ; Restore GP scratch registers.
            POP R12,RDI,RSI             ; Restore used callee-save registers.
            RET
           ENDP1 WinABI@RT:
        %ENDIF  Fa
      %ENDMACRO WinABI
</pre>

<dl id="MemAlloc"><dt><a href="#top">&uarr; MemAlloc &nbsp;</a> Size</dt>
<dd>Macro <dfn>MemAlloc</dfn> allocates memory from Windows.</dd>
<dt>Input</dt><dd><b>Size</b> is the size of allocated memory in bytes.
<!--->It will be rounded up to the multiply of pagesize (64&nbsp;KiB).</dd>
<dt>Output</dt><dd><b>CF</b>=0,
<br><b>RAX</b> is pointer to the first byte of the allocated memory.</dd>
<dt>Error</dt><dd><b>CF</b>=1
<br/><b>RAX=</b>0</dd>
<dt>Depends on</dt><dd><a href="#WinABI">WinABI</a></dd>
<dt>See also</dt><dd><a href="#MemFree">MemFree</a></dd><pre>
MemAlloc %MACRO Size
     WinABI VirtualAlloc, 0, %Size, MEM_COMMIT, PAGE_EXECUTE_READWRITE, Fastmode=no
     CMP RAX,1
    %ENDMACRO MemAlloc
</pre>

<dl id="MemFree"><dt><a href="#top">&uarr; MemFree &nbsp;</a> Address</dt>
<dd>Macro <dfn>MemFree</dfn> unallocates memory from Windows.</dd>
<dt>Input</dt><dd><b>Address</b> as returned from <a href="#MemAlloc">MemAlloc</a> which allocated it.</dd>
<dt>Output</dt><dd><b>CF</b>=0,
<br><b>RAX</b>=0</dd>
<dt>Error</dt><dd><b>CF</b>=1
<br/><b>RAX</b> &gt; 0</dd>
<dt>Depends on</dt><dd><a href="#WinABI">WinABI</a></dd>
<dt>See also</dt><dd><a href="#MemAlloc">MemAlloc</a></dd><pre>
MemFree %MACRO Address, Size
     WinABI VirtualFree, %Address, 0, MEM_RELEASE, Fastmode=no
     CMP RAX,1
    %ENDMACRO MemFree
</pre>

<dl id="GetArg"><dt><a href="#top">&uarr; GetArg &nbsp; ArgNumber, Unicode=%^UNICODE</a></dt>
<dd><p>Macro <dfn>GetArg</dfn> retrieves ArgNumber-th parameter provided on command line.
<br/>Parameters on the command line may be separated with unquoted
<!---->white spaces or commas. Single apostrophe cannot be used as quote.
<br/>Macro returns the executable name itself when ArgNumber is 0.
<!---->It is taken verbatim from the console window or, if launched
<!---->from Explorer, it may be expanded to a full pathname.</p>
<p>The returned argument is not zero terminated and it is not writable.
<!---->Make a copy in local memory if you need to modify it.
<!---->Quotes surrounding the argument are returned, too.</p>
<p>Value of <code>EUROASM UNICODE=</code> option specifies whether the returned string will be ANSI or WIDE.</p></dd>
<dt>Input</dt><dd><b>ArgNumber</b> (64bit register or memory or immediate number) is ordinal number of the required
<!---->parameter. The 0-th parameter is the executable file name itself.
<br/><b>Unicode=</b>%^UNICODE is Boolean keyword specifying if the returned string should be ANSI or WIDE.</dd>
<dt>Output</dt><dd><b>CF</b>=0,
<br><b>RSI</b> is pointer to the first character of argument,
<br><b>RCX</b> is the size of argument in bytes.</dd>
<dt>Error</dt><dd><b>CF</b>=1 if odd number of quotes or if requested argument was not provided.
<br/><b>RSI=RCX=</b>0</dd>
<dt>Depends on</dt><dd><a href="#WinABI">WinABI</a></dd>
<dt>Tested by</dt><dd><a href="../prowin64/twinabi.htm">twinabi.htm</a></dd>
<dt>Example</dt><dd class="PRE"> GetArg 1 ; Assume that our program should specify a filename.
<!----> JC .BadArgument:       ; Report error if no file was provided.
<!----> StripQuotes RSI,RCX    ; Get rid of quotes if they were used.
<!----> MOV RDI,InputFileName$ ; Room for the filename.
<!----> REP MOVSB              ; Copy the filename.
<!----> SUB AL,AL
<!----> STOSB                  ; Zero terminate the string.</dd></dl><pre>
GetArg %MACRO ArgNumber, Unicode=%^UNICODE
          PUSHQ %ArgNumber
AorW      %IF %Unicode
             CALL GetArgWin64W@RT   ; WIDE variant.
GetArgWin64W@RT: PROC1
    PUSHQ RAX,RDX,RSI,RDI,R8,R9,R10,R11
    WinABI GetCommandLineW, Fastmode=Yes
    MOV RSI,RAX      ; RSI = parser pointer.
    MOV RDI,RAX      ; RDI = end of current Arg.
    MOV R8,RAX       ; R8  = begin of current Arg.
    XOR ECX,ECX      ; RCX = current Arg ordinal.
    MOV R10,[RSP+72] ; R10 = requested Arg ordinal.
    MOV [RSP+40],RCX ; %ReturnRSI.
    DEC RCX
    CMP  R10,RCX     ; Requested ordinal is -1 when GetArg is invoked from GetArgCount.
    ADC  R10,0       ; Correction for the 0-th string on cmd-line.
    XOR EAX,EAX
    CMP EAX,ESI
    STC
    JZ .90:           ; If GetCommandLine returned FALSE.
    REPNE SCASW
    LEA RDX,[RDI-2]   ; RDX = end of command line.
    XOR ECX,ECX       ; RCX = current Arg ordinal.
.10:MOV RDI,RSI       ; RDI = brutto end of current argument.
    CMP RCX,R10
    JAE .50:          ; Jump if requested ordinal was just found.
.20:CMP RSI,RDX
    JNB .50:          ; If no more arguments available.
    LODSW
    CMP AX,' '
    JBE .20:
    SUB RSI,2
    INC RCX
    MOV R8,RSI       ; R8 is brutto beginning of RCX-th argument.
    MOV RDI,RSI
.30:CMP RSI,RDX
    JNB .10:
    LODSW
    CMP AX,'"'
    JNE .40:
.35:CMP RSI,RDX      ; Inside quotes look for ending quote.
    CMC
    JC .90:          ; Syntax error - unpaired quotes.
    LODSW
    CMP AX,'"'
    JNE .35:
    JMP .30:
.40:CMP AX,','
    JE .10:
    CMP AX,' '
    JA .30:
.45:CMP RSI,RDX
    JNB .10:
    LODSW
    CMP AX,' '
    JNA .45:
    CMP AX,','
    JE .10:
    SUB RSI,2
    JMP .10:
.50:CMP  R10,-1       ; Test if invoked from GetArgCount with ArgNr= -1.
    JNE .60:
    DEC RCX           ; Omit the 0-th argument (the executable itself).
    JMP .90:
.60:CMP RCX,R10
    MOV RCX,0
    STC
    JNE .90:          ; Return with CF and RCX=0 when the requested Arg is not provided.
    MOV RSI,R8        ; Brutto RCX-th argument found at RSI..RDI. Trim spaces and commas.
.65:CMP RSI,RDI
    JNB .75:
    LODSW
    CMP AX,' '
    JBE .65:
    CMP AX,','
    JE .65:
    SUB RSI,2
.70:SUB RDI,2
    MOV AX,[RDI]
    CMP AX,' '
    JBE .70:
    CMP AX,','
    JE .70:
    ADD RDI,2         ; Netto argument is now at RSI..RDI.
.75 MOV [RSP+40],RSI  ; %ReturnRSI.
    SUB RDI,RSI
    JC .80:
    MOV RCX,RDI
.80:CLC
.90:POPQ R11,R10,R9,R8,RDI,RSI,RDX,RAX
    RET 1*8
  ENDP1 GetArgWin64W@RT
     %ELSE AorW
       CALL GetArgWin64A@RT
GetArgWin64A@RT: PROC1 ; Stdcalled with %Param1=ArgNumber.
    PUSHQ RAX,RDX,RSI,RDI,R8,R9,R10,R11
    WinABI GetCommandLineA, Fastmode=Yes
    MOV RSI,RAX      ; RSI = parser pointer.
    MOV RDI,RAX      ; RDI = end of current Arg.
    MOV R8,RAX       ; R8  = begin of current Arg.
    XOR ECX,ECX      ; RCX = current Arg ordinal.
    MOV R10,[RSP+72] ; R10 = requested Arg ordinal.
    MOV [RSP+40],RCX ; %ReturnRSI.
    DEC RCX
    CMP R10,RCX      ; Requested ordinal is -1 when GetArg is invoked from GetArgCount.
    ADC R10,0        ; Correction for the 0-th string on cmd-line.
    XOR EAX,EAX
    CMP EAX,ESI
    STC
    JZ .90:           ; If GetCommandLine returned FALSE.
    REPNE SCASB
    LEA RDX,[RDI-1]   ; RDX = end of command line.
    XOR ECX,ECX       ; RCX = current Arg ordinal.
.10:MOV RDI,RSI       ; RDI = brutto end of current argument.
    CMP RCX,R10
    JAE .50:          ; Jump if requested ordinal was just found.
.20:CMP RSI,RDX
    JNB .50:          ; If no more arguments available.
    LODSB
    CMP AL,' '
    JBE .20:
    DEC RSI
    INC RCX
    MOV R8,RSI        ; R8 is brutto beginning of RCX-th argument.
    MOV RDI,RSI
.30:CMP RSI,RDX
    JNB .10:
    LODSB
    CMP AL,'"'
    JNE .40:
.35:CMP RSI,RDX       ; Inside quotes look for ending quote.
    CMC
    JC .90:           ; Syntax error - unpaired quotes.
    LODSB
    CMP AL,'"'
    JNE .35:
    JMP .30:
.40:CMP AL,','
    JE .10:
    CMP AL,' '
    JA .30:
.45:CMP RSI,RDX
    JNB .10:
    LODSB
    CMP AL,' '
    JNA .45:
    CMP AL,','
    JE .10:
    DEC RSI
    JMP .10:
.50:CMP R10,-1        ; Test if invoked from GetArgCount with ArgNr= -1.
    JNE .60:
    DEC RCX           ; Omit the 0-th argument (the executable itself).
    JMP .90:
.60:CMP RCX,R10
    MOV RCX,0
    STC
    JNE .90:          ; Return with CF and RCX=0 when the requested Arg is not provided.
    MOV RSI,R8        ; Brutto RCX-th argument found at RSI..RDI. Trim spaces and commas.
.65:CMP RSI,RDI
    JNB .75:
    LODSB
    CMP AL,' '
    JBE .65:
    CMP AL,','
    JE .65:
    DEC RSI
.70:DEC RDI
    MOV AL,[RDI]
    CMP AL,' '
    JBE .70:
    CMP AL,','
    JE .70:
    INC RDI           ; Netto argument is now at RSI..RDI.
.75 MOV [RSP+40],RSI  ; %ReturnRSI.
    SUB RDI,RSI
    JC .80:
    MOV RCX,RDI
.80:CLC
.90:POPQ R11,R10,R9,R8,RDI,RSI,RDX,RAX
    RET 8
  ENDP1 GetArgWin64A@RT
     %ENDIF AorW
%ENDMACRO GetArg
</pre>


<dl id="GetArgCount"><dt><a href="#top">&uarr; GetArgCount</a></dt>
<dd>counts arguments provided on the command line of the executed program.
<!---->Arguments may be separated with unquoted spaces or commas.
<!---->Multiple white spaces are treated like a single space.
<!---->Comma-separated empty arguments are counted, too.
<!---->Single apostrophe cannot be used as a quote.</dd>
<dt>Input</dt><dd> is taken from the command line which launched the program.</dd>
<dt>Output</dt><dd><b>CF=</b>0
<br/><b>RCX</b>=number of arguments on the command line which launched the program.
<dt>Error</dt><dd><b>CF</b>=1 if odd number of quotes detected.</dd>
<dt>Depends on</dt><dd><a href="#GetArg">GetArg</a></dd>
<dt>Tested by</dt><dd><a href="../prowin64/twinabi.htm">twinabi.htm</a></dd>
<dt>Example</dt><dd>All examples of the command lines below will return RCX=4.
<div class="PRE"> Program.exe arg1 arg2 arg3 arg4
<!----> Program.exe arg1,arg2,   ,arg4
<!----> Program.exe ,   ,    ,   ,    ,
<!----> Program.exe arg1, "arg2,arg2" arg3 arg4</div></dd>
</dl> <pre>
GetArgCount %MACRO
       GetArg -1, Unicode=%^UNICODE
     %ENDMACRO GetArgCount
</pre>

<dl id="PutArg"><dt><a href="#top">&uarr; PutArg</a> &nbsp; ArgNumber, BufPtr, BufSize, IgnoreCase=Yes, Unicode=%^UNICODE</dt>
<dd><p>Macro <dfn>PutArg</dfn> retrieves ArgNumber-th argument from command-line
<!---->and copies its content to the memory specified by
<em>BufPtr, BufSize,</em>, including the NUL character at its end.</p></dd>
<dt>Input</dt><dd><b>ArgNumber</b> is ordinal number of the required parameter.
<!---->The 0-th parameter specifies the executable file itself.
<!---->ArgNr can be immediate number, 64bit GPR or memory variable.
<br/><b>BufPtr</b> is pointer to the caller-reserved memory for the argument value.
<br/><b>BufSize</b> is size of the reserved memory in bytes. This 3rd parameter may be omitted,
<code>SIZE# %BufPtr</code> will be used instead.
<br/><b>Unicode=</b>%^UNICODE is <a class="EXT" href="../eadoc/index.htm#BooleansExt">extended Boolean
</a> value specifying if the string written to BufPtr should be ANSI or WIDE.
<!---->By default it copies the value specified by <code>EUROASM UNICODE=</code>.
<blockquote>When the argument value expects e.g. not more than 10 characters and <code>UNICODE=Yes</code>,
<!---->you should reserve BufSize at least 22&nbsp;bytes (10+1&nbsp;WIDE characters).
<br/>In &euro;ASM you can define the output buffer as <code>OutBuffer D (11 &gt;&gt; %^UNICODE) * BYTE
</code>, which will assemble as <code>OutBuffer D 11 * BYTE</code> when <code>UNICODE=0</code> and as
<code>OutBuffer D (11 &lt;&lt; 1) * BYTE</code> when <code>UNICODE= -1</code>, always reserving room for 10+1 characters.
</blockquote>
</dd>
<dt>Output</dt><dd><b>CF=0</b> if the requested ASCIIZ value was successfully copied to Buffer.
<br/><b>RCX=</b>number of bytes written to BufPtr, without the terminating NUL character.
<br/>RCX=0 when the ArgNumber-th argument does not exist.
</dd>
<dt>Error</dt><dd><b>CF=1</b> if the value size overflowed BufSize
<!---->and is therefore incomplete and not zero-terminated.
<br/><b>RCX=</b>number of bytes written to BufPtr (never above BufSize).</dd>
<dt>Tested by</dt><dd><a href="../prowin64/twinabi.htm">twinabi.htm</a></dd>
<dt>Depends on</dt><dd><a href="#GetArg">GetArg</a></dd>
<dt>Example</dt><dd class="PRE"> ; This example works with both ANSI and WIDE strings.
<!---->EUROASM UNICODE=On ; or UNICODE=Off, no further intervention is necessary.
<!---->[.bss]
<!---->FileName$ DB (260 >> %^UNICODE) * BYTE ; Reserve 260 or 520 bytes.
<!---->[.text]
<!---->  PutArg 1,FileName$
</dd>
</dl><pre>
PutArg %MACRO ArgNumber, BufPtr, BufSize, Unicode=%^UNICODE
sized?  %IF %# = 2
mem?      %IF %^PASS > 1 && TYPE#(SEGMENT# %BufPtr) != 'A'
            %ERROR ID=5814, 'Please specify the size of output buffer.'
            %EXITMACRO PutArg
          %ELSE mem?  ; BufPtr is specified as a memory variable with size.
%PutArgSize %SETA SIZE# %BufPtr
           %ENDIF mem?
        %ELSE sized?  ; BufSize is explicitly specified.
%PutArgSize %SET %BufSize
        %ENDIF sized?
        PUSH RDX,RSI,RDI
          %IF "%BufPtr[1]"==="["
            MOV RDI,%BufPtr
          %ELSE
            %IF "%BufPtr" !== "RDI"
              LEA RDI,[%BufPtr]
            %ENDIF
          %ENDIF
          XOR EDX,EDX
          %IF %Unicode
            MOV [RDI],DL
          %ELSE
            MOV [RDI],DX
          %ENDIF
          GetArg %ArgNumber, Unicode=%^Unicode
          JC PutArgY%.:
          MOV EDX,%PutArgSize
          INC ECX
          %IF %Unicode
            INC ECX
          %ENDIF
          CMP EDX,ECX
          JAE PutArgX%.:
          MOV ECX,EDX
          REP MOVSB
          JMP PutArgY%.:
PutArgX%.:DEC ECX
          %IF %Unicode
            DEC ECX
            MOV EDX,ECX
            REP MOVSB
            MOV [EDI],CX
          %ELSE
            MOV EDX,ECX
            REP MOVSB
            MOV [EDI],CL
          %ENDIF
PutArgY%.:MOV ECX,EDX
         POP RDI,RSI,RDX
       %ENDMACRO PutArg
</pre>

<dl id="PutEnv"><dt><a href="#top">&uarr; PutEnv</a> &nbsp; EnvName$, BufPtr, BufSize, IgnoreCase=Yes, Unicode=%^UNICODE</dt>
<dd><p>Macro <dfn>PutEnv</dfn> retrieves environment-variable with zero-terminated name
<em>EnvName$</em> at run-time, and copies its content to the memory specified by
<em>BufPtr, BufSize,</em>, including the NUL character at its end.</p></dd>
<dt>Input</dt><dd><b>EnvName$</b> is pointer to zero-terminated string
<!---->with environment-variable name (ANSI or WIDE).
<br/><b>BufPtr</b> is pointer to the caller-reserved memory for the variable value.
<br/><b>BufSize</b> is size of the reserved memory in bytes. This 3rd parameter may be omitted,
<code>SIZE# %BufPtr</code> will be used instead.
<br/><b>IgnoreCase=</b>Yes is <a class="EXT" href="../eadoc/index.htm#BooleansExt">extended Boolean
</a> value specifying if PutEnv should search for EnvName$ case-insensitively.
<br/><b>Unicode=</b>%^UNICODE is <a class="EXT" href="../eadoc/index.htm#BooleansExt">extended Boolean
</a> value specifying if EnvName$ and the string written to BufPtr
<!---->are both ANSI or WIDE. By default it copies the value specified by <code>EUROASM UNICODE=</code>.
<blockquote>When the environment value expects e.g. not more than 10 characters and <code>UNICODE=Yes</code>,
<!---->you should reserve BufSize at least 22&nbsp;bytes (10+1&nbsp;WIDE characters).
<br/>In &euro;ASM you can define the output buffer as <code>OutBuffer D (11 &gt;&gt; %^UNICODE) * BYTE
</code>, which will assemble as <code>OutBuffer D 11 * BYTE</code> when <code>UNICODE=0</code> and as
<code>OutBuffer D (11 &lt;&lt; 1) * BYTE</code> when <code>UNICODE= -1</code>, always reserving room for 10+1 characters.
</blockquote>
</dd>
<dt>Output</dt><dd><b>CF=0</b> if the requested ASCIIZ value was successfully copied to Buffer.
<br/><b>RCX=</b>number of bytes written to BufPtr, without the terminating NUL character.
<br/>RCX=0 when the environment variable is empty or does not exist.
</dd>
<dt>Error</dt><dd><b>CF=1</b> if the value size overflowed BufSize and is therefore incomplete.
<br/><b>RCX=</b>number of bytes written to BufPtr (never above BufSize).</dd>
<dt>Tested by</dt><dd><a href="../prowin64/twinabi.htm">twinabi.htm</a></dd>
<dt>Example</dt><dd class="PRE"> ; This example works with both ANSI and WIDE strings.
<!---->EUROASM UNICODE=On ; or UNICODE=Off, no further intervention is necessary.
<!---->[.bss]
<!---->TempDir$ DB (260 >> %^UNICODE) * BYTE ; Reserve 260 or 520 bytes.
<!---->[.text]
<!---->  PutEnv ="TEMP",TempDir$ ; Retrieve TEMP to TempDir$.
<!---->  LEA RDI,[TempDir$ + RCX]
<!---->  MOV RSI, ="\Cache.tmp"  ; Netto 10 characters.
<!---->  MOV ECX, (10+1) >> %^UNICODE  ; Size of the literal ="\Cache.tmp" in bytes.
<!---->  REP MOVSB               ; Append the cache file name to TempDir$ name.
<!---->; TempDir$ now contains WIDE or ANSI string e.g. "C:\TMP\Cache.tmp",0.
</dd>
</dl><pre>
PutEnv %MACRO EnvName$, BufPtr, BufSize, IgnoreCase=Yes, Unicode=%^UNICODE
sized?  %IF %# = 2
mem?      %IF %^PASS > 1 && TYPE#(SEGMENT# %BufPtr) != 'A'
            %ERROR ID=5814, 'Please specify the size of output buffer.'
            %EXITMACRO PutEnv
          %ELSE mem?  ; BufPtr is specified as a memory variable with size.
%PutEnvSize %SETA SIZE# %BufPtr
           %ENDIF mem?
        %ELSE sized?  ; BufSize is explicitly specified.
%PutEnvSize %SET %BufSize
        %ENDIF sized?
%PutEnvCase %SETB %IgnoreCase
        PUSHQ %PutEnvCase, %PutEnvSize, %BufPtr, %EnvName$
ansi?   %IF %Unicode
          CALL PutEnvWin64W@RT:
PutEnvWin64W@RT:PROC1
        XOR ECX,ECX
        PUSH RAX,RBX,RCX,RDX,RBP,RSI,RDI,R8
         MOV RBP,RSP
         XOR EAX,EAX
         MOV RDX,[RBP+10*8]   ; BufPtr.
         MOV RDI,[RSP+9*8]    ; EnvName$.
         MOV [RDX],AX         ; Prepare for the case when EnvName$ not found.
         NOT RCX
         MOV RSI,RDI
         REPNE SCASW
         NOT RCX
         MOV EDX,ECX          ; RDX=size of EnvName$ in unichars including the terminating NUL.
         LEA EDI,[2*RCX+7]
         AND EDI,-8           ; Round RDI up to DWORD.
         SUB RSP,RDI          ; Room for lowercase EnvName$.
         MOV RDI,RSP
.10:     LODSW
         CMP AX,'A'
         JB .20:
         CMP AX,'Z'
         JA .20:
         OR AL,'x'^'X'        ; Convert character to lowercase.
.20:     STOSW
         DEC ECX
         JNZ .10:
         WinABI GetEnvironmentStringsW,Fastmode=No
         MOV R8,RAX           ; Environment block.
         MOV RBX,RAX
.30:     MOV RDI,RBX
         XOR ECX,ECX
         XOR EAX,EAX
         NOT RCX
         MOV RSI,RDI
         CMP [RDI],AX         ; Test the end of environment block.
         JZ .90:              ; Return with RCX=0, CF=0, ZF=1.
         REPNE SCASW
         MOV RBX,RDI
         NOT RCX              ; RSI..RDI is ASCIIZ string EnvName=EnvVal, brutto size in unichars=RCX.
         MOV RDI,RSI
         MOV AX,'='
         REPNE SCASW
         JNE .30:
         SUB RDI,RSI
         SHR EDI,1
         CMP EDI,EDX
         JNE .30:
         LEA ECX,[EDI-1]      ; RCX is unichar-size of netto string EnvName.
         TESTB [RBP+12*8],1   ; PutEnvCase.
         JNZ .40:
         MOV RDI,[RBP+9*8]    ; EnvName$ - case sensitive search.
         REP CMPSW
         JNE .30:
         JMP .70:
.40:     MOV RDI,RSP          ; Case insensitive search.
.50:     LODSW
         CMP AX,'A'
         JB .60:
         CMP AX,'Z'
         JA .60:
         OR AL,'x'^'X'        ; Convert character to lowercase.
.60:     CMP AX,[RDI]
         JNE .30:
         ADD RDI,2
         DEC ECX
         JNZ .50:
.70:     ADD RSI,2            ; EnvName was found. RSI is now ASCIIZ EnvVal.
         MOV RDI,RSI
         XOR ECX,ECX
         XOR EAX,EAX
         NOT RCX
         REPNE SCASW
         SUB RDI,RSI          ; EDI= required-by-value brutto size of EnvVal in bytes.
         SUB EDI,2
         MOV [RBP+5*8],RDI    ; Return RCX=netto size of EnvVal in bytes.
         ADD RDI,2
         MOV RCX,[RBP+11*8]   ; BufSize. EnvVal allocated-by-user brutto size in bytes.
         CMP ECX,EDI
         XCHG ECX,EDI
         JAE .80:
         XCHG EDI,ECX
.80:     MOV RDI,[RBP+10*8]    ; BufPtr.
          REP MOVSB
.90:      PUSHFQ
           WinABI FreeEnvironmentStringsW, R8, Fastmode=No
          POPFQ
          MOV RSP,RBP
         POP R8,RDI,RSI,RBP,RDX,RCX,RBX,RAX
         RET 4*8
        ENDP1 PutEnvWin64W@RT:
       %ELSE ansi?
          CALL PutEnvWin64A@RT:
PutEnvWin64A@RT: PROC1
        XOR ECX,ECX
        PUSH RAX,RBX,RCX,RDX,RBP,RSI,RDI,R8
         MOV RBP,RSP
         XOR EAX,EAX
         MOV RDX,[RBP+10*8]    ; BufPtr.
         MOV RDI,[RSP+9*8]    ; EnvName$.
         MOV [RDX],AL         ; Prepare for the case when EnvName$ not found.
         NOT RCX
         MOV RSI,RDI
         REPNE SCASB
         NOT RCX
         MOV EDX,ECX          ; RDX=size of EnvName$ in bytes including the terminating NUL.
         LEA EDI,[2*RCX+7]
         AND EDI,-8           ; Round RDI up to QWORD.
         SUB RSP,RDI          ; Room for lowercase EnvName$.
         MOV RDI,RSP
.10:     LODSB
         CMP AL,'A'
         JB .20:
         CMP AL,'Z'
         JA .20:
         OR AL,'x'^'X'        ; Convert character to lowercase.
.20:     STOSB
         DEC ECX
         JNZ .10:
         WinABI GetEnvironmentStringsA,Fastmode=No
         MOV R8,RAX           ; Environment block.
         MOV RBX,RAX
.30:     MOV RDI,RBX
         XOR ECX,ECX
         XOR EAX,EAX
         NOT RCX
         MOV RSI,RDI
         CMP [RDI],AL         ; Test the end of environment block.
         JZ .90:              ; Return with RCX=0, CF=0, ZF=1.
         REPNE SCASB
         MOV RBX,RDI
         NOT RCX              ; RSI..RDI is ASCIIZ string EnvName=EnvVal, brutto size in bytes=RCX.
         MOV RDI,RSI
         MOV AL,'='
         REPNE SCASB
         JNE .30:
         SUB RDI,RSI
         CMP EDI,EDX
         JNE .30:
         LEA ECX,[EDI-1]      ; RCX is the size of netto string EnvName$.
         TESTB [RBP+12*8],1   ; PutEnvCase.
         JNZ .40:
         MOV RDI,[RBP+9*8]    ; EnvName$ - case sensitive search.
         REP CMPSB
         JNE .30:
         JMP .70:
.40:     MOV RDI,RSP          ; Case insensitive search.
.50:     LODSB
         CMP AL,'A'
         JB .60:
         CMP AL,'Z'
         JA .60:
         OR AL,'x'^'X'        ; Convert character to lowercase.
.60:     CMP AL,[RDI]
         JNE .30:
         INC RDI
         DEC ECX
         JNZ .50:
.70:     INC RSI              ; EnvName was found. RSI is now ASCIIZ EnvVal.
         MOV RDI,RSI
         XOR ECX,ECX
         XOR EAX,EAX
         NOT RCX
         REPNE SCASB
         SUB RDI,RSI          ; RDI= required-by-value brutto size of EnvVal in bytes.
         DEC RDI
         MOV [RBP+5*8],RDI    ; Return RCX=netto size of EnvVal in bytes.
         INC RDI
         MOV RCX,[RBP+11*8]   ; BufSize. EnvVal allocated-by-user brutto size in bytes.
         CMP ECX,EDI
         XCHG ECX,EDI
         JAE .80:
         XCHG EDI,ECX
.80:     MOV RDI,[RBP+10*8]   ; BufPtr.
          REP MOVSB
.90:      PUSHFQ
           WinABI FreeEnvironmentStringsA, R8, Fastmode=No
          POPFQ
          MOV RSP,RBP
         POP R8,RDI,RSI,RBP,RDX,RCX,RBX,RAX
         RET 4*8
        ENDP1 PutEnvWin64A@RT:
      %ENDIF ansi?
   %ENDMACRO PutEnv
</pre>


<dl id="StdOutput"><dt><a href="#top">&uarr; StdOutput String1, String2,,, Size=-1,
<!----> Handle=-11, Eol=No, Console=No, Unicode=%^UNICODE</a></dt>
<dd><p>Macro <dfn>StdOutput</dfn> writes one or more concatenated strings to the standard output
<!---->or to other equipment specified with the Handle identifier.</p>
<p>Strings are either zero-terminated, or the keyword Size= must specify its size in bytes.
<!---->The terminating NULL character is never written.</p>
<p>If keyword Eol=Yes, macro writes CR+LF after all strings.</p>
<blockquote>One of four possible runtime subprocedures is selected to emit,
<!---->depending on the chosen ANSI/WIDE and File/Console options.</blockquote>
</dd>
<dt>Input</dt><dd><b>String*</b> is pointer to ANSI or WIDE string.
<br/><b>Size=</b>-1  is the maximal possible string size in bytes. If its left to -1 (default),
<!---->the strings must be zero-terminated. This parameter applies to all ordinal operads.
<br/><b>Handle=</b>-11 is the Windows standard handle identifier.
<!---->Possible output values are defined in <a class="EXT" href="winscon.htm#Constants">winscon.htm</a>:<ul>
<li>STD_OUTPUT_HANDLE    = -11</li>
<li>STD_ERROR_HANDLE     = -12</li></ul>
<b>Eol=</b>No. If Yes, two additional characters CR and LF will be written on output
<!---->after all strings have been written.
<br/><b>Console=</b>No (or Yes) is boolean specification whether the macro should use
<!---->WinABI function WriteFile or WriteConsole.
<blockquote><p>Output of WriteFile (default) is redirectable, but it writes WIDE string as is;
<!---->in OEM console are the UTF-16 encoded characters displayed as interlaced.
<br/>Output produced by WriteConsole (when Console=Yes) cannot be redirected by command-line operator
<kbd>&gt;</kbd> but it accepts WIDE Unicode strings and displays the text in TrueType console properly,
<!---->including non-English characters.</p>
<p>When you want to use the Console (nondefault) mode in all StdOutput and StdInput invokations, you don't have to append
<code>,Console=Yes</code> to every invokation of <code>StdOutput</code> and <code>StdInput</code> if you set preprocessing %variable
<!---->in the beginning of your program: <code>%StdConsole %SETB Yes</code>.</blockquote><b>Unicode=</b> %^UNICODE is boolean specification whether the Strings are in WIDE (UTF-16) encoding.
 <!---->By default (if omitted) it copies the global option <code>EUROASM Unicode=</code>.</dd>
<dt>Output</dt><dd><b>CF=</b>0</dd>
<dt>Error</dt><dd><b>CF=</b>1 if not all characters were written or if Handle was invalid.</dd>
<dt>Depends on</dt><dd><a href="#WinABI">WinABI</a></dd>
<dt>Tested by</dt><dd><a href="../prowin64/twinabi.htm">twinabi.htm</a></dd>
<dt>Examples</dt><dd class="PRE"> StdOutput Message, Eol=Yes
<!----> StdOutput Eol=Yes ; Write new line (CR+LF) only.
<!----> StdOutput ="Error writing to file ",FileName, Handle=STD_ERROR_HANDLE
</dd></dl><pre>
StdOutput %MACRO  String1,String2,,,Size=-1, Handle=-11, Eol=No, Console=%StdConsole, Unicode=%^UNICODE
      IMPORT WriteFile,WriteConsoleA,WriteConsoleW
C     %IF %Console
U       %IF %Unicode
          %StdOutputFlags %SETA 2 + 1
        %ELSE U
          %StdOutputFlags %SETA 2 + 0
        %ENDIF U
      %ELSE C
W       %IF %Unicode
          %StdOutputFlags %SETA 0 + 1
        %ELSE W
          %StdOutputFlags %SETA 0 + 0
        %ENDIF W
      %ENDIF C
ArgNr %FOR 1..%#, STEP=1 ; Call the runtime for each String.
        PUSHQ %StdOutputFlags
S       %IF TYPE#(SEGMENT# %1) = 'N' ; String is specified as a scalar, e.g. RSI.
          PUSHQ %1
        %ELSE S          ; String is specified as a symbolic address, e.g. Msg or ="Msg".
          PUSH RAX
          LEA RAX,[%1]
          XCHG RAX,[RSP]
        %ENDIF S
        PUSHQ %Size, %Handle
        CALL StdOutputWin64@RT
        %SHIFT 1         ; The next string to output.
      %ENDFOR ArgNr
Eol   %IF %Eol
U       %IF %Unicode
          PUSHQ %StdOutputFlags + 4, 0, 4, %Handle
        %ELSE U
          PUSHQ %StdOutputFlags + 4, 0, 2, %Handle
        %ENDIF U
        CALL StdOutputWin64@RT
      %ENDIF Eol
StdOutputWin64@RT: PROC1 ; Invoked in stdcall convention with parameters Handle,Size,Addr,Flags.
        PUSHQ RAX,RCX,RDX,RDI,R8,R9,R10,R11,0,0
         %StdOutputWritten %SET RSP+0   ; QWORD memory for characters-written number.
         %StdOutputEol$    %SET RSP+8   ; Local string CR+LF.
         %StdOutputHandle  %SET RSP+88
         %StdOutputSize    %SET RSP+96
         %StdOutputString  %SET RSP+104
         %StdOutputFlags   %SET RSP+112
         MOV RCX,[%StdOutputHandle]
         WinABI GetStdHandle,RCX,Fastmode=Yes
         CMP RAX,-1
         STC
         JZ .90:  ; Abort with CF when INVALID_HANDLE_VALUE (-1).
         MOV R8,RAX        ; StdOutput handle.
         MOV RCX,[%StdOutputSize]
         MOV RDI,[%StdOutputString]
         MOV RDX,[%StdOutputFlags] ; Bits 0=Unicode, 1=Console, 2=Eol.
         MOV R11,WriteFile:
         TEST DL,2         ; Select File or Console mode.
         JZ .10:
         MOV R11,WriteConsoleA:
         TEST DL,1         ; Select ANSI or WIDE variant.
         JZ .10:
         MOV R11,WriteConsoleW:
     .10:TEST DL,4         ; Test if the string should be Eol.
         JZ .20:
         LEA RDI,[%StdOutputEol$] ; EOL is requested instead of string.
         MOVD [RDI],0x000A_000D ; WIDE EOL.
         TEST DL,1
         JNZ .20:
         MOVW [RDI],0x0A0D ; ANSI EOL.
     .20:XOR EAX,EAX       ; RDI,RCX is ASCIIZ string.
         MOV R10,RDI
         TEST DL,1         ; ASCII | WIDE.
         JZ .40:
         SHR ECX,1         ; Convert size to length in characters.
         REPNE SCASW       ; Find the WIDE zero terminator.
         JNE .50:
         SUB RDI,2         ; Omit the zero terminator.
         JMP .50:
     .40:REPNE SCASB       ; Find the ANSI zero terminator.
         JNE .50:
         DEC RDI
     .50:SUB RDI,R10       ; RDI is now the string size in bytes.
         AND DL,3
         XOR DL,3
         JNZ .60:
         SHR EDI,1         ; RDI is now string size in WIDE characters for Console.
         MOV RDX,RSP
     .60:MOV RCX,R8        ; File/Console handle.
         MOV R9,RSP        ; Characters-written variable.
         MOV R8,RDI        ; String length in characters.
         MOV RDX,R10       ; Pointer to string.
         WinABI R11,RCX,RDX,R8,R9,RAX,Fastmode=Yes
         CMP [%StdOutputWritten],RDI ; Set CF if not all characters were written.
    .90:POP RAX,RAX,R11,R10,R9,R8,RDI,RDX,RCX,RAX
        RET 4*8
      ENDP1 StdOutputWin64@RT:
 %ENDMACRO StdOutput
</pre>

<dl id="StdInput"><dt><a href="#top">&uarr; StdInput </a> Buffer, Size=, Handle=-10, Console=No, Unicode=%^UNICODE</dt>
<dd><p>Macro <dfn>StdInput</dfn> reads a line of text terminated with CR from
<!---->standard input device (usually the keyboard) specified by the Handle identifier.</p></dd>
<dt>Input</dt><dd><b>Buffer</b> is offset of memory where the input string will be stored. It can be a GPR, too.
<br/><b>Size=</b> is the Buffer size in bytes.  If omitted (default), macro will use SIZE# attribute of the Buffer.
<br/><b>Handle=</b>-10 is the Windows standard input handle identifier.
<!---->Possible input values are defined in <a class="EXT" href="winscon.htm#Constants">winscon.htm</a>:<ul>
<li>STD_INPUT_HANDLE    = -10</li></ul>
<b>Console=</b>No (or Yes) is boolean specification whether the macro should use
<!---->WinABI function ReadFile or ReadConsole.
<br/><b>Unicode=</b>%^UNICODE is boolean specification whether the characters read from console
<!---->should be in WIDE (UTF-16) encoding. It is ignored when Console=No.
<blockquote>Input of ReadFile (default) is redirectable, but it does not distinguish
<!---->WIDE or ANSI characters. ReadConsole mode can only be used with a console input
<!---->buffer handle (no redirection by command-line operators <kbd>&lt;</kbd> or
<kbd>|</kbd> is working) but it interprets WIDE characters properly.
</blockquote></dd>
<dt>Output</dt><dd><b>CF=</b>0, RCX=number of bytes read.</dd>
<dt>Error</dt><dd><b>CF=</b>1, RCX=0.</dd>
<dt>Tested by</dt><dd><a href="../prowin64/twinabi.htm">twinabi.htm</a></dd>
</dl><pre>
StdInput %MACRO Buffer, Size=, Handle=-10, Console=No, Unicode=%^UNICODE
    IMPORT ReadFile,ReadConsoleW,ReadConsoleA
C   %IF %Console
U     %IF %Unicode
        %StdInputFlags %SETA 2 + 1
      %ELSE U
        %StdInputFlags %SETA 2 + 0
      %ENDIF
    %ELSE C        ; ReadFile variant. Ignores Unicode.
W     %IF %Unicode
        %StdInputFlags %SETA 0 + 1
      %ELSE W
        %StdInputFlags %SETA 0 + 0
      %ENDIF W
    %ENDIF C
    PUSHQ %StdInputFlags
B   %IF TYPE#(SEGMENT# %Buffer) = 'N' ; Buffer is specified as a scalar, e.g. RSI.
       PUSHQ %Buffer
    %ELSE B          ; Buffer is specified as a symbolic address, e.g. Answer or [Answer+RDI].
M     %IF '%Buffer[1]' === '['
        PUSH RAX
        LEA RAX,%Buffer
        MOV RAX,[RAX]
        XCHG RAX,[RSP]
      %ELSE M
        PUSH RAX
        LEA RAX,[%Buffer]
        XCHG RAX,[RSP]
      %ENDIF M
    %ENDIF B
S   %IF '%Size' === ''
      PUSHQ SIZE# %Buffer
    %ELSE S
      PUSHQ %Size
    %ENDIF S
    PUSHQ %Handle
    CALL StdInputWin64@RT
StdInputWin64@RT: PROC1
    PUSHQ RAX,RDX,R8,R9,R10,R11,0
     %ReturnedRCX    %SET RSP+0
     %StdInputHandle %SET RSP+64
     %StdInputSize   %SET RSP+72
     %StdInputBuffer %SET RSP+80
     %StdInputFlags  %SET RSP+88
     MOV RCX,[%StdInputHandle]
     WinABI GetStdHandle,RCX,Fastmode=Yes
     CMP RAX,-1
     STC
     JZ .90: ; Abort with CF when INVALID_HANDLE_VALUE (-1).
     MOV RCX,RAX
     MOV RDX,[%StdInputFlags] ; Bits 0=Unicode, 1=Console.
     MOV R8,[%StdInputSize]
     MOV R11,ReadFile
     TEST DL,2
     JZ .20:
 .10:MOV R11,ReadConsoleA
     TEST DL,1
     JZ .20:
     MOV R11,ReadConsoleW
     SHR R8,1
 .20:CMP DL,3
     MOV RDX,[%StdInputBuffer]
     MOV R9,RSP    ; %ReturnedECX.
     PUSHFQ        ; Remember in ZF if Unicode&&Console.
      WinABI R11,RCX,RDX,R8,R9,0,Fastmode=Yes
     POPFQ
     CLC
     JNE .90:
     SALQ [RSP],1  ; Convert read character to bytes when Unicode&&Console.
.90:POPQ RCX,R11,R10,R9,R8,RDX,RAX
    RET 4*8
   ENDP1 StdInputWin64@RT:
 %ENDMACRO StdInput
</pre>

<dl id="TerminateProgram"><dt><a href="#top">&uarr; TerminateProgram  Errorlevel=0</a></dt>
<dd>This macro provides exit from the running process and the return to the operating system.
<br/>It also specifies the Errorlevel (plain number) which can be used to inform
<!---->the batch script which launched the program whether the program terminated normally
<!---->or due to some error condition.</dd>
<dt>Input</dt><dd><b>Errorlevel=</b> is the return code of the terminating program.
<br/>Beside the keyword <code>Errorlevel=</code>, this value may also be specified as an ordinal operand.
<br/>When this argument is omitted, it defaults to 0.</dd>
<dt>Output</dt><dd> is not applicable. </dd>
<dt>Example</dt><dd class="PRE"> TerminateProgram Errorlevel=[WorstErrLevel] ; Keyword value (from memory).
<!----> TerminateProgram 8  ; Ordinal value.</dd></dl><pre>
TerminateProgram %MACRO Errorlevel=0
     %IF %#=1 ; If ordinal provided.
       MOV RCX,%1
     %ELSE    ; If keyword provided.
       MOV RCX,%Errorlevel
     %ENDIF
     SUB RSP,4*8
     IMPORT ExitProcess, Lib="kernel32.dll"
     JMP ExitProcess
   %ENDMACRO TerminateProgram
</pre>
<pre>
   ENDHEAD winabi
</pre>
<!--TAILMENU-->
<!--Contents below the marker {!==TAILMENU==} was generated by "generate.php".-->
<br class='CLEAR'/><a id='bottom' href='#top'>&#x25B2;Back to the top&#x25B2;</a>
</body></html>
