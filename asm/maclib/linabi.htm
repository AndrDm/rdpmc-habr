<!doctype html><html lang='en'><head>
<meta http-equiv='Content-Type' content='text/html; charset=utf-8'/>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=2.0, user-scalable=yes'>
<meta name='robots' content='ALL,FOLLOW'/>
<meta name='description' content='linabi.htm macro library'/>
<meta name='version' content='20250318'/>
<meta name='author' content='Pavel vitsoft Šrubař'/>
<link rel='stylesheet' href='../euroasm.css' type='text/css'/>
<link rel='shortcut icon' href='../favicon.ico'/>
<title>linabi.htm macro library</title>
</head>
<body class='MACLIB' id='top'><div class='HEADMENU'><table>
<tr><td rowspan='2' title='&euro;ASM - assembler and linker'><img src='../favicon.ico' alt='EuroAssembler' />
<td><a href='../index.htm' title='Alphabetical index of all &euro;ASM elements, directives and instructions'>Index</a></td>
<td><a href='../eadoc/' class='EADOC' title='Documentation of EuroAssembler'>Manual</a></td>
<td><a href='https://euroassembler.eu/download/' title='History &amp; download of the latest and previous versions'>Download</a></td>
<td><a href='../easource/' class='EASOURCE' title='Source files of EuroAssembler itself'>Source</a></td>
<td><a href='../maclib/' class='MACLIB' title='Macro libraries shipped with &euro;ASM'>Macros</a></td>
<td rowspan='2' title='Find the searched token in any text file on this site'>
<form method='post' action='../search.php' enctype='multipart/form-data' accept-charset='utf-8'>
<input type='text' id='q' placeholder='Searched word(s)' name='q' value=''/>
<br/><label title='Check the box to find the expression even if it is surrounded by other letters | digits.'>
<input type='checkbox' name='EW'/><small>Embedded word</small></label>
<br/><label title='Check the box for case-insensitive search.'>
<input type='checkbox' name='CI'/><small>Case ins.</small></label>
<input type='submit' title='Search for the specified word|expression in all site files.' name='find' value='Search'/>
</form></td></tr><tr>
<td><a href='../sitemap.htm' title='List of directories and files on this site'>Sitemap</a></td>
<td><a href='../eadoc/links.htm' class='EADOC' title='References and external links to resources used in EuroAssembler developement'>Links</a></td>
<td><a href='https://euroassembler.eu/forum/' title='Discussion forum concerning EuroAssembler'>Forum</a></td>
<td><a href='../eatests/' class='EATESTS' title='Program snippets for testing the function of &euro;ASM'>Tests</a></td>
<td><a href='../objlib/' class='OBJLIB' title='Skeletons and sample objects and projects shipped with &euro;ASM'>Projects</a></td>
</tr></table></div>
<!--Contents above the marker {!==/HEADMENU==} was generated by "generate.php".-->
<!--/HEADMENU-->
<h1>linabi.htm
<br/><i>Enumerations</i>
<br/><a href="#pcLinSyscall64List">%LinSyscall64List</a>
<br/><i>Macros</i>
<br/><a href="#GetArg">GetArg</a>
<br/><a href="#GetArgCount">GetArgCount</a>
<br/><a href="#LinABI">LinABI</a>
<br/><a href="#MemAlloc">MemAlloc</a>
<br/><a href="#MemFree">MemFree</a>
<br/><a href="#PutArg">PutArg</a>
<br/><a href="#PutEnv">PutEnv</a>
<br/><a href="#StdInput">StdInput</a>
<br/><a href="#StdOutput">StdOutput</a>
<br/><a href="#TerminateProgram">TerminateProgram</a>
</h1>
<p>This file can be included to <strong>64bit</strong> programs written in Euro Assembler.
<br/>It contains macros for some basic <strong>Linux | Unix</strong> interactions:
<!---->retrieving of environment and command-line arguments, standard I/O, program termination,
<!---->and for access to <strong>Linux kernel 64bit ABI
</strong> (Application Binary Interface) using <code>SYSCALL</code>, as described in
<a class="EXTL" href="../eadoc/links.htm#SystemV">[SystemV]</a>.</p>
<br clear="all"><pre>
 linabi HEAD
</pre>
<dl id="pcLinSyscall64List"><dt><a href="#top">&uarr; %LinSyscall64List</a></dt>
<dd>Assembly-time array <dfn>%LinSyscall64List</dfn> declares mnemonic names assigned
<!---->to Linux kernel 64bit functions, and also the required number of their arguments,
<!---->as defined in documentation.
<br/>Constant prefix <code>sys_</code> was removed from function names.
<br/>Functions declared with unspecified number of arguments
<kbd>(?)</kbd> were removed or not implemented in the kernel.</dd>
<dt>Documentation</dt><dd><a class="EXTL" href="../eadoc/links.htm#LinSyscall64">[LinSyscall64]</a>
<a class="EXTL" href="../eadoc/links.htm#LinSyscall64S">[LinSyscall64S]</a>
<a class="EXTL" href="../eadoc/links.htm#LinManSyscall">[LinManSyscall]</a>
</dd></dl><pre>
%LinSyscall64List %SET \ Declare 64bit <b>syscall_name(number_of_parameters)    \ numeric_id</b>
 read(3),write(3),open(3),close(1),stat(2),fstat(2),lstat(2),poll(3),        \ 000..007
 lseek(3),mmap(6),mprotect(4),munmap(2),brk(1),rt_sigaction(4),              \ 008..013
 rt_sigprocmask(4),rt_sigreturn(1),ioctl(3),pread64(4),pwrite64(4),readv(3), \ 014..019
 writev(3),access(2),pipe(1),select(5),sched_yield(0),mremap(5),msync(3),    \ 020..026
 mincore(3),madvise(3),shmget(3),shmat(3),shmctl(3),dup(1),dup2(2),pause(0), \ 027..034
 nanosleep(2),getitimer(2),alarm(1),setitimer(3),getpid(0),sendfile(4),      \ 035..040
 socket(3),connect(3),accept(3),sendto(6),recvfrom(6),sendmsg(3),recvmsg(3), \ 041..047
 shutdown(2),bind(3),listen(2),getsockname(3),getpeername(3),socketpair(4),  \ 048..053
 setsockopt(5),getsockopt(5),clone(4),fork(0),vfork(0),execve(3),exit(1),    \ 054..060
 wait4(4),kill(2),uname(1),semget(3),semop(3),semctl(4),shmdt(1),msgget(2),  \ 061..068
 msgsnd(4),msgrcv(5),msgctl(3),fcntl(3),flock(2),fsync(1),fdatasync(1),      \ 069..075
 truncate(2),ftruncate(2),getdents(3),getcwd(2),chdir(1),fchdir(1),rename(2),\ 076..082
 mkdir(2),rmdir(1),creat(2),link(2),unlink(1),symlink(2),readlink(3),        \ 083..089
 chmod(2),fchmod(2),chown(3),fchown(3),lchown(3),umask(1),gettimeofday(2),   \ 090..096
 getrlimit(2),getrusage(2),sysinfo(1),times(1),ptrace(4),getuid(0),syslog(3),\ 097..103
 getgid(0),setuid(1),setgid(1),geteuid(0),getegid(0),setpgid(2),getppid(0),  \ 104..110
 getpgrp(0),setsid(0),setreuid(2),setregid(2),getgroups(2),setgroups(2),     \ 111..116
 setresuid(3),getresuid(3),setresgid(3),getresgid(3),getpgid(1),setfsuid(1), \ 117..122
 setfsgid(1),getsid(1),capget(2),capset(2),rt_sigpending(2),                 \ 123..127
 rt_sigtimedwait(4),rt_sigqueueinfo(3),rt_sigsuspend(2),sigaltstack(2),      \ 128..131
 utime(2),mknod(3),uselib(1),personality(1),ustat(2),statfs(2),fstatfs(2),   \ 132..138
 sysfs(3),getpriority(2),setpriority(3),sched_setparam(2),sched_getparam(2), \ 139..143
 sched_setscheduler(3),sched_getscheduler(1),sched_get_priority_max(1),      \ 144..146
 sched_get_priority_min(1),sched_rr_get_interval(2),mlock(2),munlock(2),     \ 147..150
 mlockall(1),munlockall(0),vhangup(0),modify_ldt(3),pivot_root(2),_sysctl(1),\ 151..156
 prctl(5),arch_prctl(3),adjtimex(1),setrlimit(2),chroot(1),sync(0),acct(1),  \ 157..163
 settimeofday(2),mount(5),umount2(2),swapon(2),swapoff(1),reboot(4),         \ 164..169
 sethostname(2),setdomainname(2),iopl(2),ioperm(3),create_module(?),         \ 170..174
 init_module(3),delete_module(2),get_kernel_syms(?),query_module(?),         \ 175..178
 quotactl(4),nfsservctl(?),getpmsg(?),putpmsg(?),afs_syscall(?),tuxcall(?),  \ 179..184
 security(?),gettid(0),readahead(3),setxattr(5),lsetxattr(5),fsetxattr(5),   \ 185..190
 getxattr(4),lgetxattr(4),fgetxattr(4),listxattr(3),llistxattr(3),           \ 191..195
 flistxattr(3),removexattr(2),lremovexattr(2),fremovexattr(2),tkill(2),      \ 196..200
 time(1),futex(6),sched_setaffinity(3),sched_getaffinity(3),                 \ 201..204
 set_thread_area(?),io_setup(2),io_destroy(1),io_getevents(4),io_submit(3),  \ 205..209
 io_cancel(3),get_thread_area(?),lookup_dcookie(3),epoll_create(1),          \ 210..213
 epoll_ctl_old(?),epoll_wait_old(?),remap_file_pages(5),getdents64(3),       \ 214..217
 set_tid_address(1),restart_syscall(0),semtimedop(4),fadvise64(4),           \ 218..221
 timer_create(3),timer_settime(4),timer_gettime(2),timer_getoverrun(1),      \ 222..225
 timer_delete(1),clock_settime(2),clock_gettime(2),clock_getres(2),          \ 226..229
 clock_nanosleep(4),exit_group(1),epoll_wait(4),epoll_ctl(4),tgkill(3),      \ 230..234
 utimes(2),vserver(?),mbind(6),set_mempolicy(3),get_mempolicy(5),mq_open(4), \ 235..240
 mq_unlink(1),mq_timedsend(5),mq_timedreceive(5),mq_notify(2),               \ 241..244
 mq_getsetattr(3),kexec_load(4),waitid(5),add_key(4),request_key(4),         \ 245..249
 keyctl(5),ioprio_set(3),ioprio_get(2),inotify_init(0),inotify_add_watch(3), \ 250..254
 inotify_rm_watch(2),migrate_pages(4),openat(4),mkdirat(3),mknodat(4),       \ 255..259
 fchownat(5),futimesat(3),newfstatat(4),unlinkat(3),renameat(4),linkat(5),   \ 260..265
 symlinkat(3),readlinkat(4),fchmodat(3),faccessat(3),pselect6(6),ppoll(5),   \ 266..271
 unshare(1),set_robust_list(2),get_robust_list(3),splice(6),tee(4),          \ 272..276
 sync_file_range(4),vmsplice(4),move_pages(6),utimensat(4),epoll_pwait(6),   \ 277..281
 signalfd(3),timerfd_create(2),eventfd(1),fallocate(4),timerfd_settime(4),   \ 282..286
 timerfd_gettime(2),accept4(4),signalfd4(4),eventfd2(2),epoll_create1(1),    \ 287..291
 dup3(3),pipe2(2),inotify_init1(1),preadv(5),pwritev(5),rt_tgsigqueueinfo(4),\ 292..297
 perf_event_open(5),recvmmsg(5),fanotify_init(2),fanotify_mark(5),           \ 298..301
 prlimit64(4),name_to_handle_at(5),open_by_handle_at(5),clock_adjtime(2),    \ 302..305
 syncfs(1),sendmmsg(4),setns(2),getcpu(3),process_vm_readv(6),               \ 306..310
 process_vm_writev(6),kcmp(5),finit_module(3),sched_setattr(3),              \ 311..314
 sched_getattr(4),renameat2(5),seccomp(3),getrandom(3),memfd_create(2),      \ 315..319
 kexec_file_load(5),bpf(3),stub_execveat(5),userfaultfd(1),membarrier(2),    \ 320..324
 mlock2(3),copy_file_range(6),preadv2(6),pwritev2(6),pkey_mprotext(4),       \ 325..329
 pkey_alloc(2),pkey_free(1),statx(5),io_pgetevents_time64(6),rseq(4),        \ 330..334
 ;
</pre>

<dl id="LinABI"><dt><a href="#top">&uarr; LinABI</a> &nbsp; Sys_call, Arg1,Arg2,Arg3,Arg4,Arg5,Arg6, Fastmode=No</dt>
<dd><p>This macroinstruction encapsulates invokation of <strong>Linux 64bit kernel functions</strong>
<!---->using machine instruction <code>SYSCALL</code>.</p>
<p>Function arguments %Arg1..%Arg6 are transferred in registers <code>RDI,RSI,RDX,R10,R8,R9</code>, respectively.
<br/><code>RAX</code> contains the function's ordinal number 0..334 from the list
<a href="#pcLinSyscall64List">%LinSyscall64List</a>.</p>
<dt>Input</dt><dd><b>Sys_call</b> is the name of invoked kernel function as specified in
<a href="#pcLinSyscall64List">%LinSyscall64List</a> enumeration, for instance
<code>read</code>, <code>write</code>, <code>open</code> etc (case insensitive).
<!---->Its ordinal number will be provided in register RAX.
<br/><b>Argr*</b> are zero to six parameters (function arguments).
<!---->They will be copied to registers RDI, RSI, RDX, R10, R8, R9, respectively,
<!---->before SYSCALL invokation. Do not use RAX in robust (not Fastmode) when other lower parameters are pointers.
<br/><b>Fastmode=No</b> is Boolean argument. When it's <em>false</em> or omitted (default),
<!---->the LinABI macro preserves all registers except for RAX which returns the result of Function.
<!---->Arguments in this <strong>robust mode</strong> may be provided to this macro in any GPR (except for RAX),
<!---->regardless of the order required by the kernel function specification.
<br/><b>Fastmode=Yes</b> is faster but it destroys registers RCX and R11 clobbered by kernel,
<!---->and attention must be paid to the order of parameter passing.
<br/>Arguments in <strong>fast mode</strong> are loaded directly to registers, starting with the last,
<!---->and they may overwrite the previous contents of R9, R8, R10, RDX, RSI, RDI.
<!---->Programmer should avoid using those registers for parameter passing in fast mode.
<blockquote>When you want to use the fast (nondefault) mode in all LinABI invokations, you don't have to append <code>,Fastmode=Yes
</code> to every invokation of <code>LinABI</code> if you set preprocessing %variable
<!---->in the beginning of your program: <code>%Fastmode %SETB Yes</code>.
</blockquote></dd>
<dt>Output if Fastmode=No</dt><dd><b>RAX, RFlags</b> as returned from kernel function, i.e. the function result, or error code when it's negative.
<br/>All other registers are preserved.</dd>
<dt>Output if Fastmode=Yes</dt><dd><b>RAX, RFlags</b> as returned from kernel function, i.e. the function result, or error code when it's negative.
<br/><b>RCX,R11</b> are undefined.
<br/><b>RDI</b> is Par1 or unchanged.
<br/><b>RSI</b> is Par2 or unchanged.
<br/><b>RDX</b> is Par3 or unchanged.
<br/><b>R10</b> is Par4 or unchanged.
<br/><b>R8</b>  is Par5 or unchanged.
<br/><b>R9</b>  is Par6 or unchanged.</dd>
<dt>Example</dt><dd class="PRE"> LinABI write, 1, =B"Hello, world!", 13
<!----> LinABI exit, 0</dd>
<dt>Documented</dt><dd><a class="EXTL" href="../eadoc/links.htm#LinManSyscall">[LinManSyscall]</a></dd>
<dt>Remark</dt><dd>
<p>User of <strong>robust</strong> mode does not have to keep on mind that function's parameter will be loaded
<!---->to registers RSI,RDI etc, overwriting their previous contents.
<!---->Arguments of macro <code>LinABI Fastmode=off</code> may be provided in any 64bit GPR, e.g.
<code>LinABI write, stdout, RSI, RCX</code>.
<br/>When arguments are small integers, the robust variant is sometimes shorter, because it loads registers with
<code>PUSH param + POP reg</code> (2+1&nbsp;bytes) instead of <code>MOV reg,param</code> (5&nbsp;bytes).
<p>The following example demonstrates both modes of LinABI on the function
<code>sys_write</code> with three arguments:
<code> LinABI write, STDOUT_FILENO, Message, SIZE# Message</code>
 <samp>|00000000:               | ; <b>Fast version</b>.
<!---->|00000000:               | LinABI write, STDOUT_FILENO, Message, SIZE# Message, Fastmode=Yes
<!---->|00000000:BA0E000000     + MOV RDX,14            ; Arg3 SIZE# Message.
<!---->|00000005:488D350C000000 + LEA RSI,[Message]     ; Arg2 OFFSET# Message, use relative addressing frame.
<!---->|0000000C:BF01000000     + MOV RDI,STDOUT_FILENO ; Arg1 StdOutput handle = 1.
<!---->|00000011:B801000000     + MOV RAX,1             ; Syscall write = 1.
<!---->|00000016:0F05           + SYSCALL               ; Perform the kernell call.
<!---->|00000018:               | ; LinABI in fast mode occupies 24 bytes.
</samp>
 <samp>|00000000:               | ; <b>Robust version</b>.
<!---->|00000000:               | LinABI write, STDOUT_FILENO, Message, SIZE# Message, Fastmode=No
<!---->|00000000:6A0E           + PUSHQ 14              ; Arg3 SIZE# Message.
<!---->|00000002:488D050F000000 + LEA RAX,[Message]     ; Arg2 OFFSET# Message, use relative addressing frame.
<!---->|00000009:50             + PUSH RAX              ; Temporary use RAX for transfer.
<!---->|0000000A:6A01           + PUSH STDOUT_FILENO    ; Arg1 StdOutput handle = 1.
<!---->|0000000C:6A01           + PUSH 1                ; Syscall write = 1.
<!---->|0000000E:6A03           + PUSH 3                ; Number of Syscall arguments = 3.
<!---->|00000010:E814000000     + CALL LinABI@RT        ; Invoke the system function, discard the last two pushed parameters.
<!---->|00000015:5F5E5A         + POP RDI,RSI,RDX       ; Epilogue: restore original value of transfer registers.
<!---->|00000018:               | ; LinABI in robust mode occupies 24 bytes (plus 75 bytes of runtime code, once per program).
</samp><h6>Fast mode is optimised for performance, robust mode is optimised for programmer's convenience.</h6>
</dd></dl>
<pre>
LinABI %MACRO Sys_call, Arg1,Arg2,Arg3,Arg4,Arg5,Arg6, Fastmode=%Fastmode
%GPR  %SET RDI,RSI,RDX,R10,R8,R9               ; Enumerate registers for transfer of arguments.
%FnNr %SETA 0                                  ; Function identification 0..328, transferred in RAX.
%IF "%Sys_call"===""
   %ERROR ID=5813,%0 function was not specified.
%ENDIF
FnRef %FOR %LinSyscall64List                   ; Walk through <a href="#pcLinSyscall64List">kernel function reference</a>.
found  %IF "%Sys_call" == "%FnRef[1..%&-3]"    ; Omit the last three characters from function reference and compare.
%ArgC    %SET %FnRef[%&-1]                     ; Sys_call name was found. Pick up the digit from parenthesis ('0'..'6' or '?').
checkDef %IF "%ArgC" === "?"
           %ERROR ID=5813,%0 %Sys_call (RAX=%FnNr) is not implemented in the kernel.
           %EXITMACRO LinABI
         %ENDIF checkDef
checkArg %IF %ArgC <> %# - 1
           %ERROR ID=5811,Macro "%0 %Sys_call" requires %ArgC arguments.
           %EXITMACRO LinABI
         %ENDIF checkArg
mode     %IF %Fastmode                         ; <b>Fast mode</b>.
args       %WHILE %ArgC >= 1                   ; Argument passing. Start with the last one.
%Arg         %SET %*{%ArgC+1}
rel          %IF TYPE#(SEGMENT#(%Arg)) = 'A'   ; %Arg requires relocation (it's defined in a segment).
ref            %IF '%Arg[1]' === '['           ; Argument is a relocatable memory variable, e.g. [Symbol+RSI].
                 LEA %GPR{%ArgC},%Arg          ; Use relative addressing frame for relocatable %Arg.
                 MOV %GPR{%ArgC},[%GPR{%ArgC}] ; Dereference the argument value.
               %ELSE ref                       ; Argument is a relocatable immediate (pointer), e.g. Symbol.
                 LEA %GPR{%ArgC},[%Arg]        ; Use relative addressing frame for relocatable %Arg.
               %ENDIF ref
             %ELSE rel                         ; Arg is scalar, e.g. 1234, RSI, [RBP+40].
               %IF '%GPR{%ArgC}' !== '%Arg'    ; Skip if the argument already is in transfer register.
                 MOVQ %GPR{%ArgC},%Arg         ;  otherwise copy the argument to GPR.
               %ENDIF
             %ENDIF rel
%ArgC        %SETA %ArgC-1                     ; Arguments are loaded in reversed order.
           %ENDWHILE args
           MOV RAX,%FnNr                       ; Load syscall identification number %FnNr to RAX.
           SYSCALL                             ; Perform the <b>kernell call</b>.
           %EXITMACRO LinABI                   ; Expansion of macro is completed.
         %ELSE mode                            ; <b>Robust mode</b>.
ArgNr      %FOR %ArgC..1, STEP= -1             ; Push arguments, start with the last one.
%Arg         %SET %*{%ArgNr+1}
rel          %IF TYPE#(SEGMENT#(%Arg)) = 'A'   ; Argument is relocatable.
ref            %IF '%Arg[1]' === '['           ; Argument is a relocatable memory variable, e.g. [Symbol+RSI].
                 LEA RAX,%Arg                  ; Use relative addressing frame for relocatable %Arg.
                 PUSHQ [RAX]                   ; Dereference and push the argument value.
               %ELSE ref                       ; Argument is a relocatable immediate (pointer), e.g. Symbol.
                 LEA RAX,[%Arg]                ; Use relative addressing frame for relocatable %Arg.
                 PUSH RAX                      ; Push the pointer.
               %ENDIF ref
             %ELSE rel                         ; Arg is scalar, e.g. 1234, RSI, [RBP+40].
               PUSHQ %Arg
             %ENDIF rel
           %ENDFOR ArgNr
             PUSHQ %FnNr                       ; Sys_call identification.
             PUSHQ %ArgC                       ; Number of Sys_call arguments (0..6).
           CALL LinABI@RT                      ; Runtime performs the SYSCALL and discards the last two pushed parameters.
LinABI@RT:: PROC1                              ; <b>Robust LinABI runtime</b> with variable number of pushed arguments.
             PUSH RCX,R11                      ; Save registers clobbered by SYSCALL.
              MOV RCX,[RSP+24]                 ; %ArgC - number of arguments on stack (0..6).
              MOV RAX,[RSP+32]                 ; %FnNr - SYSCALL function identificator.
              JRCXZ .Syscall:
              DEC CL
              XCHG RDI,[RSP+40]                ; %Arg1.
              JRCXZ .Syscall:
              DEC CL
              XCHG RSI,[RSP+48]                ; %Arg2.
              JRCXZ .Syscall:
              DEC CL
              XCHG RDX,[RSP+56]                ; %Arg3.
              JRCXZ .Syscall:
              DEC CL
              XCHG R10,[RSP+64]                ; %Arg4.
              JRCXZ .Syscall:
              DEC CL
              XCHG R8,[RSP+72]                 ; %Arg5.
              JRCXZ .Syscall:
              DEC CL
              XCHG R9,[RSP+80]                 ; %Arg6.
.Syscall:     SYSCALL
             POP R11,RCX                       ; Restore registers clobbered by SYSCALL.
             RET 2*8                           ; Discard %ArgC and %FnNr.
            ENDP1 LinABI@RT::                  ; Pushed arguments will be discarded by LinABI's epilogue.
           POP %GPR{1..%ArgC}                  ; Epilogue: restore original value of transfer registers.
           %EXITMACRO LinABI                   ; Expansion of macro is completed.
         %ENDIF mode
       %ENDIF found
       %FnNr %SETA %FnNr+1                     ; Try the next function reference in %LinSyscall64List.
      %ENDFOR FnRef
      %ERROR ID=5812,Unrecognized function name "%Sys_call". See %%LinSyscall64List in "linabi.htm".
    %ENDMACRO LinABI
</pre>

<dl id="MemAlloc"><dt><a href="#top">&uarr; MemAlloc &nbsp;</a> Size</dt>
<dd>Macro <dfn>MemAlloc</dfn> allocates memory from Linux.</dd>
<dt>Input</dt><dd><b>Size</b> is the number of bytes allocated memory.
<!--->It will be rounded up to the multiply of pagesize (4&nbsp;KiB).</dd>
<dt>Output</dt><dd><b>CF</b>=0,
<br><b>RAX</b> is pointer to the first byte of the allocated memory.</dd>
<dt>Error</dt><dd><b>CF</b>=1
<br/><b>RAX=</b><a class="EXT" href="../maclib/lins.htm#Constants">Error number</a></dd>
<dt>Depends on</dt><dd><a href="#LinABI">LinABI</a></dd>
<dt>See also</dt><dd><a href="#MemFree">MemFree</a></dd><pre>
MemAlloc %MACRO Size
     LinABI mmap, 0, %Size, PROT_EXEC|PROT_READ|PROT_WRITE, \
            MAP_PRIVATE|MAP_32BITS|MAP_ANONYMOUS, -1, 0, Fastmode=no
     CMP RAX,-ERR_MAX
     CMC
    %ENDMACRO MemAlloc
</pre>

<dl id="MemFree"><dt><a href="#top">&uarr; MemFree &nbsp;</a> Address, Size</dt>
<dd>Macro <dfn>MemFree</dfn> unallocates memory from Linux.</dd>
<dt>Input</dt><dd><b>Address</b> as returned from <a href="#MemAlloc">MemAlloc</a> which allocated it.
<br><b>Size</b> is the size in bytes of the unallocated memory.</dd>
<dt>Output</dt><dd><b>CF</b>=0,
<br><b>RAX</b>=0</dd>
<dt>Error</dt><dd><b>CF</b>=1
<br/><b>RAX=</b><a class="EXT" href="../maclib/lins.htm#Constants">Error number</a></dd>
<dt>Depends on</dt><dd><a href="#LinABI">LinABI</a></dd>
<dt>See also</dt><dd><a href="#MemAlloc">MemAlloc</a></dd><pre>
MemFree %MACRO Address, Size=0
     LinABI munmap, %Address, %Size, Fastmode=no
     CMP RAX,-ERR_MAX
     CMC
    %ENDMACRO MemFree
</pre>

<dl id="GetArg"><dt><a href="#top">&uarr; GetArg &nbsp;</a> ArgNumber, Frame=RSP</dt>
<dd>Macro <dfn>GetArg</dfn> retrieves ArgNumber-th parameter provided on command line.
<br/>Parameters on the command line are separated with unquoted white space(s).
<br/>Single or double quotes are not returned.</dd>
<dt>Input</dt><dd><b>ArgNumber</b> is ordinal number of the required
<!---->parameter (0..127). The 0-th parameter specifies the executable file itself.
<!---->ArgNr can be an immediate number, 64bit GPR or memory variable.
<br/><b>Frame=</b>RSP specifies the pointer to process stack, i.e. to the QWORD
<!---->with process' <code>argc</code> value. It can be GPR or [QWORD_memory_variable].
<br/>The default <code>Frame=RSP</code> is valid only if nothing has been pushed yet
<!---->since the program started. Otherwise use something like
<code>LEA RCX,[RSP+4]</code> or <code>LEA RCX,[RBP+8]</code> and then <code>Frame=RCX</code>.</dd>
<dt>Output</dt><dd><b>CF</b>=0,
<br><b>RSI</b> is pointer to the first byte of the requested argument,
<br><b>RCX</b> is argument size in bytes.</dd>
<dt>Error</dt><dd><b>CF</b>=1 Frame is wrong or the requested argument was not provided.
<br/><b>RCX=</b>0
<br/><b>RSI=</b>undefined.</dd>
<dt>See also</dt><dd><a href="#GetArgCount">GetArgCount</a></dd>
<dt>Process' stack layout</dt><dd class="PRE">of a program launched as <code>./executable --option argumentA argumentB</code>
<!---->        &#x250C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2510;
<!---->        &#x2502;     0  &#x2502; NULL QWORD which terminates array of pointers to env strings.
<!---->        &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;
<!---->        &#x2502;  env2  &#x2502; Pointer to 2nd ASCIIZ environment string.
<!---->        &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;
<!---->        &#x2502;  env1  &#x2502; Pointer to 1st ASCIIZ environment string.
<!---->        &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;
<!---->        &#x2502;     0  &#x2502; NULL QWORD which terminates array of pointers to arg strings.
<!---->        &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;
<!---->        &#x2502; argv3  &#x2502; Pointer to ASCIIZ string <code>argumentB</code>.
<!---->        &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;
<!---->        &#x2502; argv2  &#x2502; Pointer to ASCIIZ string <code>argumentA</code>.
<!---->        &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;
<!---->        &#x2502; argv1  &#x2502; Pointer to ASCIIZ string <code>--option</code>.
<!---->        &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;
<!---->        &#x2502; execut &#x2502; Pointer to this executable file name <code>./executable</code>.
<!---->        &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;
<!---->        &#x2502;  argc  &#x2502; Number of arguments including the executable itself <code>4</code>.
<!---->Frame-&gt; &#x2514;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2518;
</dd></dl><pre>
GetArg %MACRO ArgNumber, Frame=RSP
     PUSHQ %Frame, %ArgNumber
     CALL GetArgLin64@RT
GetArgLin64@RT:: PROC1 ; Stdcalled with Param1=ArgNumber, Param2=%Frame.
    PUSH RAX,RBX,RDX,RDI
     MOV RSI,[RSP+6*8] ; Frame.
     MOV RBX,[RSP+5*8] ; Requested ArgNumber (0..126) or -1.
     SUB EDX,EDX
     MOV RCX,[RSI]     ; argc (expected 1..128).
     DEC RCX           ; Do not count the executable itself.
     CMP RBX,-1        ; Test if GetArg was invoked from GetArgCount.
     JE .90:
     CMP ECX,EBX
     JC  .80:          ; This many arguments are not available.
     MOV RDI,[RSI+8*RBX+8]
     TEST RDI
     STC
     JZ  .80:          ; Invalid %Frame.
     MOV RSI,RDI
     XOR ECX,ECX
     XOR EAX,EAX
     NOT RCX
     REPNE SCASB       ; Find the zero terminator, set CF=0.
     NOT RCX
     LEA EDX,[ECX-1]
.80: MOV ECX,EDX
.90:POP RDI,RDX,RBX,RAX
    RET 2*8
  ENDP1 GetArgLin64@RT::
 %ENDMACRO GetArg
</pre>

<dl id="GetArgCount"><dt><a href="#top">&uarr; GetArgCount Frame=RSP</a></dt>
<dd>returns number of arguments provided on the command line of the executed program.
<!---->Arguments are separated with unquoted space(s).</dd>
<dt>Input</dt><dd> is taken from the command line which launched the program.
<br/><b>Frame=</b>RSP specifies the pointer to process stack, i.e. to the QWORD
<!---->with process' <code>argc</code> value. It can be GPR or [DWORD_memory_variable].
<br/>The default <code>Frame=RSP</code> is valid only if nothing has been pushed yet
<!---->since the program started. Otherwise use something like
<code>LEA RCX,[RSP+4]</code> or <code>LEA RCX,[RBP+8]</code> and then <code>Frame=RCX</code>.</dd>
<dt>Output</dt><dd><b>CF=</b>0
<br/><b>RCX</b>=number of arguments on the command line which launched the program (0..127).
<dt>Error</dt><dd><b>CF</b>=1 if the Frame= was invalid. RCX is undefined.</dd>
<dt>Depends on</dt><dd><a href="#GetArg">GetArg</a></dd>
</dl> <pre>
GetArgCount %MACRO Frame=RSP
     GetArg -1, Frame=%Frame
   %ENDMACRO GetArgCount
</pre>

<dl id="PutArg"><dt><a href="#top">&uarr; PutArg</a> &nbsp; ArgNumber, BufPtr, BufSize, Frame=RSP</dt>
<dd><p>Macro <dfn>PutArg</dfn> retrieves ArgNumber-th argument from command-line,
<!---->copies its content to the memory specified by BufPtr, BufSize
<!---->and appends one NUL character at its end.</p></dd>
<dt>Input</dt><dd><b>ArgNumber</b> is ordinal number of the required parameter.
<!---->The 0-th parameter specifies the executable file itself.
<!---->ArgNumber can be an immediate number below 128, 64bit GPR or memory variable.
<br/><b>BufPtr</b> is pointer to the Buffer, i.e. to caller-reserved memory for the argument value.
<br/><b>BufSize</b> is size of the reserved memory in bytes. This 3rd parameter may be omitted,
<code>SIZE# %BufPtr</code> will be used instead.
<br/><b>Frame=</b>RSP specifies the pointer to process stack, i.e. to the QWORD
<!---->with process' <code>argc</code> value. It can be GPR or [QWORD_memory_variable].
<br/>The default <code>Frame=RSP</code> is valid only if nothing has been pushed yet
<!---->since the program started. Otherwise use something like
<code>LEA RCX,[RSP+4]</code> or <code>LEA RCX,[RBP+8]</code> and then <code>Frame=RCX</code>.</dd>
<dt>Output</dt><dd><b>CF=0</b> if the requested value was successfully copied to Buffer
<!---->and zero-terminated.
<br/><b>RCX=</b>number of bytes written to Buffer, without the terminating NUL character.
<br/>RCX=0 when the ArgNumber-th argument does not exist and only NUL was written to Buffer.
</dd>
<dt>Error</dt><dd><b>CF=1</b> bad Frame or the argument size overflowed BufSize
<!---->and is therefore incomplete and not zero-terminated.
<br/><b>RCX=</b>number of bytes written to the Buffer (never exceeds BufSize).</dd>
<dt>Tested by</dt><dd><a href="../prolin64/tlinabi.htm">tlinabi.htm</a></dd>
<dt>Depends on</dt><dd><a href="#GetArg">GetArg</a></dd>
</dl><pre>
PutArg %MACRO ArgNumber, BufPtr, BufSize, Frame=RSP
sized?  %IF %# = 2
mem?      %IF %^PASS > 1 && TYPE#(SEGMENT# %BufPtr) != 'A'
            %ERROR ID=5814, 'Please specify the size of output buffer.'
            %EXITMACRO PutArg
          %ELSE mem?  ; BufPtr is specified as a memory variable with size.
            %PutArgSize %SETA SIZE# %BufPtr
          %ENDIF mem?
        %ELSE sized?  ; BufSize is explicitly specified.
          %PutArgSize %SET %BufSize
        %ENDIF sized?
        PUSHQ %Frame, %PutArgSize, %BufPtr, %ArgNumber
        CALL PutArgLin64@RT::
PutArgLin64@RT::PROC1
        PUSH RCX,RSI,RDI
         MOV RCX,[RSP+7*8]          ; Frame.
         MOV RDI,[RSP+5*8]          ; BufPtr.
         MOV RSI,[RSP+4*8]          ; ArgNumber.
         GetArg RSI,Frame=RCX       ; Returns argument in RSI,RCX.
         JC .50:
         INC ECX
         CMP [RSP+6*8],ECX          ; BufSize.
         DEC ECX
         JNC .50:
         MOV ECX,[RSP+6*8]          ; BufSize.
.50:     MOV [RSP+2*8],RCX          ; Returned RCX.
         REP MOVSB
         JC .90:
         MOV [RDI],CL
.90:    POP RDI,RSI,RCX
        RET 4*8
       ENDP1 PutArgLin64@RT::
     %ENDMACRO PutArg
</pre>


<dl id="PutEnv"><dt><a href="#top">&uarr; PutEnv &nbsp;</a> EnvName$, BufPtr, BufSize, IgnoreCase=Yes, Frame=RSP</dt>
<dd>Macro <dfn>PutEnv</dfn> retrieves environment-variable with zero-terminated name
<em>EnvName$</em> at run-time, and copies its content to the memory specified by
<em>BufPtr, BufSize</em>, including the NUL character at its end.
</dd>
<dt>Input</dt><dd><b>EnvName$</b> is pointer to zero-terminated string with environment-variable name.
<br/><b>BufPtr</b> is pointer to the caller-reserved memory for the variable value.
<br/><b>BufSize</b> is size of the reserved memory in bytes. This 3rd parameter may be omitted,
<code>SIZE# %BufPtr</code> will be used instead.
<br/><b>IgnoreCase=</b>Yes is <a class="EXT" href="../eadoc/index.htm#BooleansExt">extended Boolean
</a> value specifying if PutEnv should search for EnvName$ case-insensitively.
<br/><b>Frame=</b>RSP specifies the pointer to process stack, i.e. to the QWORD
<!---->with process' <code>argc</code> value. It can be GPR or [QWORD_memory_variable].
<br/>The default <code>Frame=RSP</code> is valid only if nothing has been pushed yet
<!---->since the program started. Otherwise use something like
<code>LEA RCX,[RSP+4]</code> or <code>LEA RCX,[RBP+8]</code> and then <code>Frame=RCX</code>.</dd>
<dt>Output</dt><dd><b>CF</b>=0 if the requested ASCIIZ value was successfully copied to Buffer.
<br><b>RCX</b>= number of bytes written to BufPtr, without the terminating NUL character.
<br/>RCX=0 when the environment variable is empty or does not exist.</dd>
<dt>Error</dt><dd><b>CF=1</b> bad Frame or the value size overflowed BufSize and is therefore incomplete.
<br/><b>RCX=</b> number of bytes written to BufPtr (never above BufSize).</dd>
<dt>Tested by</dt><dd><a href="../prolin64/tlinabi.htm">tlinabi.htm</a></dd>
<dt>Example</dt><dd class="PRE">  PutEnv =B"HOSTNAME", HostName
<!---->  JC .HostNameTooLong:
<!---->  JRCXZ .HostNameNotSet:
<!---->[.bss]
<!---->HostName DB 64*BYTE</dd>
<dd>Process' stack layout of a program <code>executable
</code> with environment strings <code>TEMP=/tmp</code> and <code>PATH=/bin:/usr/bin
</code> launched from console as
<code>./executable --option argumentA argumentB</code></dd>
<dd class="PRE">
<!---->        &#x250C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2510;
<!---->        &#x2502;     0  &#x2502; NULL QWORD which terminates array of pointers to env strings.
<!---->        &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;
<!---->        &#x2502;  env2  &#x2502; Pointer to 2nd ASCIIZ environment string <code>PATH=/bin:/usr/bin</code>.
<!---->        &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;
<!---->        &#x2502;  env1  &#x2502; Pointer to 1st ASCIIZ environment string <code>TEMP=/tmp</code>.
<!---->        &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;
<!---->        &#x2502;     0  &#x2502; NULL QWORD which terminates array of pointers to arg strings.
<!---->        &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;
<!---->        &#x2502; argv3  &#x2502; Pointer to ASCIIZ string <code>argumentB</code>.
<!---->        &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;
<!---->        &#x2502; argv2  &#x2502; Pointer to ASCIIZ string <code>argumentA</code>.
<!---->        &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;
<!---->        &#x2502; argv1  &#x2502; Pointer to ASCIIZ string <code>--option</code>.
<!---->        &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;
<!---->        &#x2502; execut &#x2502; Pointer to this executable file ASCIIZ name <code>./executable</code>.
<!---->        &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;
<!---->        &#x2502;  argc  &#x2502; Number of arguments including the executable itself <code>4</code>.
<!---->Frame-&gt; &#x2514;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2518;
</dd></dl><pre>
PutEnv %MACRO EnvName$, BufPtr, BufSize, IgnoreCase=Yes, Frame=RSP
sized?  %IF %# = 2
mem?      %IF %^PASS > 1 && TYPE#(SEGMENT# %BufPtr) != 'A'
            %ERROR ID=5814, 'Please specify the size of output buffer.'
            %EXITMACRO PutEnv
          %ELSE mem?  ; BufPtr is specified as a memory variable with size.
%PutEnvSize %SETA SIZE# %BufPtr
           %ENDIF mem?
        %ELSE sized?  ; BufSize is explicitly specified.
%PutEnvSize %SET %BufSize
        %ENDIF sized?
%PutEnvCase %SETB %IgnoreCase
        PUSHQ %Frame, %PutEnvCase, %PutEnvSize, %BufPtr, %EnvName$
        CALL PutEnvLin64@RT::
PutEnvLin64@RT:: PROC1
        PUSH RAX,RBX,RCX,RDX,RBP,RSI,RDI
         MOV RBP,RSP
         XOR ECX,ECX
         MOV RSI,[RBP+12*8]     ; Frame.
         MOV [RBP+4*8],RCX      ; Initialize returned RCX with 0.
         MOV RDI,[RBP+9*8]      ; BufPtr.
         MOV [RDI],CL           ; Initialize empty Buffer.
         LODSQ                  ; RAX=argc (1..127).
         CMP RAX,127
         CMC
         JC .90:                ; Abort with CF due to bad Frame.
         TEST EAX
         STC
         JZ .90:                ; Abort with CF due to bad Frame.
         LEA RSI,[RSI+8*RAX]    ; Pointers to argv* strings should be followed with NULL pointer.
         LODSQ
         TEST RAX               ; NUL pointer which terminates argv strings.
         STC
         JNZ .90:               ; Abort with CF due to bad Frame.
         MOV RBX,RSI            ; RBX points to array of pointers to ASCIIZ environment strings <code>NAME=value</code>.
         MOV RDI,[RBP+8*8]      ; EnvName$.
         MOV RSI,RDI
         NOT ECX
         REPNE SCASB
         NOT RCX
         MOV EDX,ECX            ; RCX=RDX is now the size of EnvName$ string in bytes, including NUL.
         LEA EDI,[RCX+7]
         AND EDI,-8             ; Round RDI up to QWORD.
         SUB RSP,RDI            ; Make room for lowercase EnvName$.
         MOV RDI,RSP
.20:     LODSB
         CMP AL,'A'
         JB .30:
         CMP AL,'Z'
         JA .30:
         OR AL,'x'^'X'           ; Convert ASCII character to lowercase.
.30:     STOSB
         DEC ECX
         JNZ .20:
.40:     MOV RSI,RBX
         LODSQ                   ; Pointer to env string <code>Name=Value</code>.
         MOV RBX,RSI
         TEST RAX                ; NUL pointer terminates env strings.
         JZ .90:                 ; Abort with CF=0, EnvName$ not found.
         MOV RSI,RAX
         XOR ECX,ECX
         MOV AL,'='
         NOT RCX
         MOV RDI,RSI
         REPNE SCASB
         JNE .40:
         NOT RCX
         CMP ECX,EDX
         JNE .40:
         DEC ECX                ; Netto size of EnvName$.
         TESTB [RBP+11*8],1     ; IgnoreCase?
         JNZ .50:
         MOV RDI,[RBP+8*8]      ; EnvName$ - case sensitive search.
         REP CMPSB
         JNE .40:
         JMP .70:
.50:     MOV RDI,RSP            ; Case insensitive search.
.55:     LODSB
         CMP AL,'A'
         JB .60:
         CMP AL,'Z'
         JA .60:
         OR AL,'x'^'X'          ; Convert character to lowercase.
.60:     CMP AL,[RDI]
         JNE .40:
         INC RDI
         DEC ECX
         JNZ .55:
.70:     INC RSI                ; Skip '=', point to EnvVal.
         MOV RDI,RSI
         XOR EAX,EAX
         NOT RCX
         REPNE SCASB
         SUB RDI,RSI            ; RDI= required-by-value brutto size of EnvVal in bytes.
         MOV RCX,[RBP+10*8]     ; BufSize.  EnvVal allocated-by-user brutto size in bytes.
         STC
         JRCXZ .90:
         CMP ECX,EDI            ; CF=overflow of EnvVal.
         XCHG ECX,EDI
         JAE .80:
         XCHG EDI,ECX
.80:     LEA EDX,[ECX-1]
         MOV RDI,[RBP+9*8]      ; BufPtr.
         MOV [RBP+4*8],RDX      ; Returned RCX.
         REP MOVSB
.90:     MOV RSP,RBP
        POP RDI,RSI,RBP,RDX,RCX,RBX,RAX
        RET 5*8
  ENDP1 PutEnvLin64@RT::
 %ENDMACRO PutEnv
</pre>


<dl id="StdOutput"><dt><a href="#top">&uarr; StdOutput </a> String1, String2,,, Size=-1,
<!----> Handle=1, Eol=No</dt>
<dd><p>Macro <dfn>StdOutput</dfn> writes one or more concatenated strings to the standard output
<!---->or to other device or file specified with the Handle identifier.</p>
<p>Strings are either zero-terminated, or the keyword Size= must specify their size in bytes.
<!---->The terminating NUL character is never written.</p>
<p>If keyword Eol=Yes, macro writes LF after all strings.</p>
</dd>
<dt>Input</dt><dd><b>StringX</b> is pointer to the buffer with characters-to-be-written.
<br/><b>Size=</b>-1  is the maximal possible string size in bytes. If it is left to -1 (default),
<!---->strings must be zero-terminated. This parameter applies to all ordinal operands.
<br/><b>Handle=</b>1 is the Linux file descriptor.
<!---->Possible values are defined in <a class="EXT" href="linsfile.htm#Constants">linsfile.htm</a>:<ul>
<li>STDOUT_FILENO = 1</li>
<li>STDERR_FILENO = 2</li></ul>
<br><b>Eol=</b>No. When this Boolean keyword is switched on, an additional character
<code>LF</code> (0x10) will be written on output after all strings have been written.
<br><b>Unicode=disabled</b>, <b>Console=disabled</b> are ignored, they provide compatibility with Windows version.
</dd>
<dt>Output</dt><dd><b>CF=</b>0. All registers are preserved.</dd>
<dt>Error</dt><dd><b>CF=</b>1 when SYSCALL returned an error.</dd>
<dt>Depends on</dt><dd><a href="#LinABI">LinABI</a></dd>
<dt>Examples</dt><dd class="PRE"> StdOutput TextPart1,TextPart2,TextPart3
<!----> StdOutput Eol=Yes ; Write new line (LF) only.
<!----> StdOutput ="Error writing to file ",FileName, Handle=STDERR_FILENO
</dd></dl><pre>
StdOutput %MACRO  String1,String2,,,Size=-1, Handle=1, Eol=No, Console=disabled, Unicode=disabled
    %IF %Unicode
      %ERROR ID=5946, 'Macroinstructions for Linux expect Unicode=off.'
    %ENDIF
opN %FOR 1..%#, STEP=1                ; Walk through all ordinal operands.
      PUSHQ %Handle, %Size
rel   %IF TYPE#(SEGMENT#(%1)) = 'A'   ; String is relocatable.
ref     %IF '%1[1]' === '['           ; Pointer reference, e.g. [ArrayOfPointersToMsgs+RSI].
          PUSH RAX
          LEA RAX,%1
          MOV RAX,[RAX]               ; Dereference the pointer.
          XCHG RAX,[RSP]
        %ELSE ref                     ; Absolute reference, e.g. Message.
          PUSH RAX
          LEA RAX,[%1]
          XCHG RAX,[RSP]
        %ENDIF ref
      %ELSE rel                       ; String is not relocatable, e.g. RSI or [RBP+16].
        PUSHQ %1
      %ENDIF rel
      CALL StdOutputLin64@RT
      %SHIFT 1                        ; The next string to write.
    %ENDFOR opN
eol %IF %Eol
       PUSHQ %Handle, 1, 0            ; NUL string pointer represents the request for LF.
       CALL StdOutputLin64@RT
     %ENDIF eol
StdOutputLin64@RT:: PROC1             ; StdCalled runtime with params String, Size, Handle.
     PUSH RAX,RBX,RCX,RSI,RDI,R11
     PUSHQ 0x0A                       ; Prepare Eol character on stack.
       MOV RBX,[RSP+80]               ; File descriptor %Handle.
       MOV RCX,[RSP+72]               ; String maximal %Size.
       MOV RDI,[RSP+64]               ; String pointer or 0 for Eol.
       XOR EAX,EAX
       CMP RDI,RAX                    ; NULL pointer in RDI signalizes Eol request.
       JNE .10:
       INC RDI                        ; Size of Eol=1.
       MOV RSI,RSP                    ; Pointer to Eol (0x0A).
       JMP .50:
.10:   MOV RSI,RDI                    ; Remember the start of string in RSI.
       REPNE SCASB                    ; Find the end of string.
       JNE .30:
       DEC RDI                        ; Omit the NUL terminator.
.30:   SUB RDI,RSI                    ; Netto string is now ESI,EDI
.50:   LinABI write,RBX,RSI,RDI, Fastmode=No
       SAL RAX                        ; Copy SF to CF (this signalizes an error).
.90: POP RAX,R11,RDI,RSI,RCX,RBX,RAX
     RET 3*8
  ENDP1 StdOutputLin64@RT::
 %ENDMACRO StdOutput
</pre>

<dl id="StdInput"><dt><a href="#top">&uarr; StdInput </a> Buffer, Size=, Handle=0</dt>
<dd><p>Macro <dfn>StdInput</dfn> reads from standard input specified by the Handle.</p></dd>
<dt>Input</dt><dd><b>Buffer</b> is offset of memory where the input line will be stored.
<br/><b>Size=</b> is the Buffer size.  If omitted (default), macro will use SIZE# attribute of the Buffer.
<br/><b>Handle=</b>0 is the Linux file descriptor.
<!---->Possible values are defined in <a class="EXT" href="linsfile.htm#Constants">linsfile.htm</a>:
<ul><li>STDIN_FILENO = 0</li></ul>
</dd>
<dt>Output</dt><dd><b>CF=</b>0, RCX=number of bytes read.</dd>
<dt>Error</dt><dd><b>CF=</b>1, RCX=error code.</dd>
<dt>Example</dt><dd class="PRE"> StdInput RSI, Size=80</dd>
</dl><pre>
StdInput %MACRO Buffer, Size=, Handle=0
    PUSHQ %Handle
bs  %IF "%Size" === ""
      PUSHQ SIZE# %Buffer
    %ELSE bs
      PUSHQ %Size
    %ENDIF bs
rel %IF TYPE#(SEGMENT#(%Buffer)) = 'A' ; Buffer is relocatable.
ref   %IF "%Buffer[1]" === "["   ; Pointer reference, e.g. [ArrayOfPointersToBuffers+RSI].
        LEA RCX,%Buffer
        MOV RCX,[RCX]            ; Dereference the pointer.
        PUSH RCX
      %ELSE ref                  ; Absolute reference, e.g. InputLine.
        LEA RCX,[%Buffer]
        PUSH RCX
      %ENDIF ref
    %ELSE rel                    ; Buffer is not relocatable, e.g. RBX or [RBP+16].
      PUSHQ %Buffer
    %ENDIF
    CALL StdInputLin64@RT
StdInputLin64@RT::PROC1          ; StdCalled with params Handle, BufferSize, BufferPtr.
    PUSH RAX,RDX,RSI,RDI,R8,R9,R10,R11
      MOV RSI,[RSP+72]           ; %Buffer.
      MOV RDX,[RSP+80]           ; %Size.
      MOV RDI,[RSP+88]           ; %Handle.
      LinABI read,RDI,RSI,RDX, Fastmode=Yes
      MOV RCX,RAX
      SAL RAX                    ; Copy SF to CF (this signalizes an error).
    POP R11,R10,R9,R8,RDI,RSI,RDX,RAX
    RET 3*8
   ENDP1 StdInputLin64@RT::
 %ENDMACRO StdInput
</pre>


<dl id="TerminateProgram"><dt><a href="#top">&uarr; TerminateProgram </a> Errorlevel=0</dt>
<dd>This macro provides exit from the running process and return to the operating system.
<br/>It also specifies the Errorlevel (plain number) which can be used to inform
<!---->the batch script which launched the program whether the program terminated normally
<!---->or due to some error condition.</dd>
<dt>Input</dt><dd><b>Errorlevel=</b> is the return code of the terminating program.
<br/>Beside the keyword <code>Errorlevel=</code>, this value may also be specified as an ordinal operand.
<br/>When this argument is omitted, it defaults to 0.</dd>
<dt>Output</dt><dd> is not applicable. </dd>
<dt>Examples</dt><dd class="PRE"> TerminateProgram 8                          ; Ordinal value of errorlevel.
<!----> TerminateProgram Errorlevel=[WorstErrLevel] ; Keyword value (from memory).</dd></dl><pre>
TerminateProgram %MACRO Errorlevel=0
     PUSHQ 60            ; Function sys_exit identification.
     %IF %# = 1          ; If %Errorlevel is provided as ordinal value.
       PUSHQ %1
     %ELSE               ; %Errorlevel is provided as keyword.
       PUSHQ %Errorlevel
     %ENDIF
     POP RDI
     POP RAX
     SYSCALL
   %ENDMACRO TerminateProgram
</pre>

<pre>
  ENDHEAD linabi
</pre>
<!--TAILMENU-->
<!--Contents below the marker {!==TAILMENU==} was generated by "generate.php".-->
<br class='CLEAR'/><a id='bottom' href='#top'>&#x25B2;Back to the top&#x25B2;</a>
</body></html>
