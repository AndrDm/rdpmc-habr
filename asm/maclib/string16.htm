<!doctype html><html lang='en'><head>
<meta http-equiv='Content-Type' content='text/html; charset=utf-8'/>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=2.0, user-scalable=yes'>
<meta name='robots' content='ALL,FOLLOW'/>
<meta name='description' content='string16.htm macro library'/>
<meta name='version' content='20250318'/>
<meta name='author' content='Pavel vitsoft Šrubař'/>
<link rel='stylesheet' href='../euroasm.css' type='text/css'/>
<link rel='shortcut icon' href='../favicon.ico'/>
<title>string16.htm macro library</title>
</head>
<body class='MACLIB' id='top'><div class='HEADMENU'><table>
<tr><td rowspan='2' title='&euro;ASM - assembler and linker'><img src='../favicon.ico' alt='EuroAssembler' />
<td><a href='../index.htm' title='Alphabetical index of all &euro;ASM elements, directives and instructions'>Index</a></td>
<td><a href='../eadoc/' class='EADOC' title='Documentation of EuroAssembler'>Manual</a></td>
<td><a href='https://euroassembler.eu/download/' title='History &amp; download of the latest and previous versions'>Download</a></td>
<td><a href='../easource/' class='EASOURCE' title='Source files of EuroAssembler itself'>Source</a></td>
<td><a href='../maclib/' class='MACLIB' title='Macro libraries shipped with &euro;ASM'>Macros</a></td>
<td rowspan='2' title='Find the searched token in any text file on this site'>
<form method='post' action='../search.php' enctype='multipart/form-data' accept-charset='utf-8'>
<input type='text' id='q' placeholder='Searched word(s)' name='q' value=''/>
<br/><label title='Check the box to find the expression even if it is surrounded by other letters | digits.'>
<input type='checkbox' name='EW'/><small>Embedded word</small></label>
<br/><label title='Check the box for case-insensitive search.'>
<input type='checkbox' name='CI'/><small>Case ins.</small></label>
<input type='submit' title='Search for the specified word|expression in all site files.' name='find' value='Search'/>
</form></td></tr><tr>
<td><a href='../sitemap.htm' title='List of directories and files on this site'>Sitemap</a></td>
<td><a href='../eadoc/links.htm' class='EADOC' title='References and external links to resources used in EuroAssembler developement'>Links</a></td>
<td><a href='https://euroassembler.eu/forum/' title='Discussion forum concerning EuroAssembler'>Forum</a></td>
<td><a href='../eatests/' class='EATESTS' title='Program snippets for testing the function of &euro;ASM'>Tests</a></td>
<td><a href='../objlib/' class='OBJLIB' title='Skeletons and sample objects and projects shipped with &euro;ASM'>Projects</a></td>
</tr></table></div>
<!--Contents above the marker {!==/HEADMENU==} was generated by "generate.php".-->
<!--/HEADMENU-->
<h1>string16.htm
<br/><i>Macros</i>
<br/><a href="#Concatdo">Concat$</a>
<br/><a href="#Comparedo">Compare$</a>
<br/><a href="#DecodeUTF8">DecodeUTF8</a>
<br/><a href="#GetLengthdo">GetLength$</a>
</h1>
<p>This file can be included to <b>16bit</b> programs written in Euro Assembler.
<br/>It contains <b>OS-independent</b> macros for zero-terminated (ASCIIZ) string operations.</p>
<p>All functions expect direction flag on input be zero and they do not change it.</p>
<p>Similar macros with identical names for different program width are defined in
<a href="string32.htm">string32.htm</a> and
<a href="string64.htm">string64.htm</a>.</p>
<br class="CLEAR"/>
<pre>
 string16 HEAD
</pre>  

<dl id="GetLengthdo"><dt><a href="#top">&uarr; GetLength$</a> String</dt>
<dd>This macro returns the size of ASCIIZ string in bytes. The terminating NUL character is not counted.</dd>
<dt>Input</dt>
<dd><b>String</b> is pointer to a zero terminated string of ANSI
<!---->characters. It may also be a literal string.
<br/><b>ES=</b> segment of the String.</dd>
<dt>Output</dt><dd><b>CX</b>= size of the string in bytes without the terminating NUL.</dd>
</dl><pre>
GetLength$ %MACRO String
     %IF "%String" !== "CX"
       MOV CX,%String
     %ENDIF
     CALL GetLength$@RT::
       GetLength$@RT:: PROC1
          PUSH AX,DI
            MOV DI,CX
            XOR AX,AX
            XOR CX,CX
            CLD
            DEC CX
            REPNE SCASB
            NOT CX
            DEC CX
         POP DI,AX
         RET
       ENDPROC1 GetLength$@RT::
   %ENDMACRO GetLength$
</pre>

<dl id="Concatdo"><dt><a href="#top">&uarr; Concat$</a> Destination, Size=, Source1, Source2,,,</dt>
<dd>Macro will concatenate one or more zero-terminated source strings to a destination string.
<br/>All source strings must be addressable with DS. Destination must be addressable with ES.</dd>
<dt>Input</dt>
<dd><b>Destination</b> is a pointer to an output buffer where the result
<!---->of concatenation will be stored as zero-terminated byte string.
<br/><b>ES=</b> is segment of Destination string.
<br/><b>Size=</b> is the size allocated for the output destination buffer
<!---->including the zero terminator. By default it is set to <code>SIZE# %Destination</code>.
<br/><b>Source*</b> operands are pointers to the ASCIIZ strings which are being
<!---->concatenated. The first one (Source1) may be identical
<!---->with the destination, when we need to append something
<!---->to an existing string.
<br/><b>DS=</b> is segment of all Source strings.
</dd>
 <dt>Output</dt><dd><b>CF</b>=0, Destination string is filled with concatenation
<!---->of all Source strings. Registers are preserved.
<br/><b>CF</b>=1 when the allocated Size= is not long enough. The output buffer Size
<!---->is never exceeded.</dd>
<dt>Example</dt><dd class="PRE">Concat$ FullName$,Path$,FileName$,=B".htm"</dd>
</dl><pre>
Concat$ %MACRO Destination, Source,,, Size=
   %IF %# < 2                                                                      ; >
     %ERROR ID=5930, 'Missing operand of macro "Concat$".'
     %EXITMACRO Concat$
   %ENDIF
   PUSH BP
     MOV BP,SP ; Store stack pointer.
     ArgNr %FOR %#..2, STEP= -1
       PUSHW %*{%ArgNr} ; All Source pointers, starting with the last.
     %ENDFOR ArgNr
     PUSHW %# - 1  ; Number of Source strings to concatenate.
     %IF "%Size" === ""
       PUSHW SIZE# %Destination
     %ELSE
        PUSHW %Size
     %ENDIF
     PUSHW %Destination
     CALL Concat$@RT::
     MOV SP,BP ; Restore stack.
   POP BP
Concat$@RT:: PROC1
     PUSHAW
       MOV BP,SP
       MOV DI,[BP+18] ; %Destination.
       MOV DX,[BP+20] ; %Size.
       MOV CX,[BP+22] ; Number of source strings.
       ADD DX,DI
       CLD
       DEC DX ; End of allocated Destination.
 .20:  MOV SI,[BP+24] ; Source pointer.
 .30:  LODSB
       CMP AL,0
       JE .40:
       CMP DI,DX
       CMC
       JC .80: ; If destination size overflowed.
       STOSB
       JMP .30:
 .40:  INC BP,BP ; The next Source pointer.
       LOOP .20:
 .80:  MOV AL,0
       STOSB
     POPAW
     RET
   ENDP1 Concat$@RT::
 %ENDMACRO Concat$
</pre>

<dl id="Comparedo"><dt><a href="#top">&uarr; Compare$</a> String1, String2</dt>
<dd>Compare two zero-terminated strings.</dd>
<dt>Input</dt>
<dd><b>String1</b> is pointer to the first zero-terminated string. SI is assumed when the 1st operand is empty.
<br/><b>DS=</b> is segment of the first string.
<br/><b>String2</b> is pointer to the second zero-terminated string. DI is assumed when the 2nd operand is empty.
<br/><b>ES=</b> is segment of the second string.</dd>
<dt>Output</dt><dd><b>ZF</b>=1 if both string are identical,
<br><b>ZF</b>=0 otherwise.</dd></dl><pre>
Compare$ %MACRO String1, String2
   %IF "%String2" === ""
     PUSHW DI
   %ELSE
     PUSHW %String2
   %ENDIF
   %IF "%String1" === ""
     PUSHW SI
   %ELSE
     PUSHW %String1
   %ENDIF
   CALL Compare$@RT::
Compare$@RT:: PROC1
       PUSHAW
         MOV BP,SP
         SUB AX,AX
         MOV DI,[BP+20] ; %String2.
         MOV CX,-1
         MOV BX,DI
         CLD
         REPNE:SCASB    ; Search for the terminator of string ES:DI.
         SUB DI,BX      ; Size of String2 including the NUL.
         MOV DX,DI
         MOV DI,[BP+18] ; %String1$.
         MOV CX,-1
         MOV SI,DI
         PUSH ES,DS
          POP ES        ; Temporarily load ES from DS.
          REPNE:SCASB   ; Search for the terminator of string DS:SI.
         POP ES
         MOV CX,DI
         SUB CX,SI      ; Size of %String1 including the NUL.
         CMP CX,DX      ; Compare string sizes.
         JNE .90        ; If sizes do not match.
         MOV DI,BX      ; String1$.
         REPE CMPSB
   .90:POPAW
       RET 2*2
      ENDPROC1 Compare$@RT::
  %ENDMACRO Compare$
</pre>

<dl id="DecodeUTF8"><dt><a href="#top">DecodeUTF8</a> Source, CallbackProc, Size=-1, Width=16</dt>
<dd><p>Macro <dfn>DecodeUTF8</dfn> converts Source UTF-8 string to UTF-16 or UTF-32 string
<!---->in 16bit CPU mode. It requires CPU 386 or higher.
<br/>Source string is either zero-terminated, or its Size= must be specified.
<!---->Conversion stops at NUL byte, which is not converted to output.
<!---->Input never reads beyond Source+Size.</p>
<p>If <em>Byte Order Mark</em> (BOM, <code>0xEF,0xBB,0xBF
</code>) is detected at the beginning of the Source string, it is ignored.</p>
<p>Invalid UTF-8 sequence will send a <em>replacement character</em> <code>0xFFFD</code>
<kbd>&#xfffd;</kbd> to the output.</p>
<p>Byte order in output encoding is always LittleEndian, the same which is used in MS Windows WIDE functions.</p>
<blockquote>If you want to produce UTF-16BE, perform <code>XCHG AL,AH</code> in CallbackProc.
<br/>If you want to produce UTF-32BE, perform <code>BSWAP EAX</code> in CallbackProc.
<br/>If you want to prefix the output string with BOM, store it to destination buffer
<!---->before invoking DecodeUTF8.
<br/>If you don't like replacement characters (usually displayed as little squares
<kbd>&#xfffd;</kbd>), filter them out in CallbackProc.</blockquote></dd>
<dt>Documented</dt><dd> <a class="EXTL" href="../eadoc/links.htm#UTF8">[UTF8]</a>,
<a class="EXTL" href="../eadoc/links.htm#UTF16">[UTF16]</a>,
<a class="EXTL" href="../eadoc/links.htm#UTF32">[UTF32]</a></dd>
<dt>Input</dt><dd><b>ES=</b> is segment of UTF8-encoded string.
<br/><b>Source</b> is offset of the first byte of UTF8-encoded string.
<br/><b>Size=</b> -1 is the maximal possible size of source string in bytes.
<!---->It may be left on default when the Source string is terminated with NUL byte
<!---->(this NUL is not written to output).
<br/>If Size is not -1, exactly that many input bytes are decoded, including NUL bytes.
<br/><b>Width=</b>16 or 32 specifies the output encoding UTF-16 or UTF-32, respectively.
<br/><b>CallbackProc</b> is offset in CS segment of the procedure which stores one converted character.
<dl><dt>CallbackProc</dt><dd>is called with <em>register calling convention</em>.
<br/>It is expected to store the UTF-16 or UTF-32 character obtained in EAX and return with CF=0.</dd>
<dt>Input</dt><dd><b>CF=DF=0</b>
<br/><b>EAX=</b> contains one converted character encoded in UTF-16 or UTF-32, which should be stored.
<br/>EAX may contain surrogate code <code>0x0000_D800..0x0000_DFFF</code> when the input UTF-8 character
<!---->belongs to Unicode supplementary planes (Emoji, Asian characters etc).
<br/>EAX may also contain the replacement <code>0x0000_FFFD</code> when the input UTF-8 string is malformed.
<br/><b>BP=</b> original value of BP on input to the macro.
<!---->Usually it is the frame pointer of the function which expanded DecodeUTF8,
<!---->thus arguments and local variables of the function can be used in CallbackProc.
<br/><b>DI=</b> original value of DI on input to the macro. It may be used in STOS,
<!---->incremented value of DI will be supplied on the next invocation of CallbackProc.
<br/><b>BX,CX,DX,SI</b> should be considered undefined.</dd>
<dt>Output</dt><dd><b>CF=</b>0 when a character from EAX was successfully stored to the destination
<!---->buffer by CallbackProc and macro should continue with parsing the next UTF-8 characters.
<br/><b>CF=</b>1 signalizes that the macro should cancel further conversion. CF propagates to the output of DecodeUTF8.
<br/>AX,BX,CX,DX,BP,SI,DI,ES may be changed in Callback procedure. The value of
<br/><b>DI</b> will be saved and provided in the next call of CallbackProc,
<!---->thus DI can be used in CallbackProc as an output pointer for decoded data.</dd>
</dl></dd>
<dt>Output</dt><dd><b>CF=0</b>, <b>CX=</b> number of unprocessed bytes at the end of text (0..3)
<!---->due to incompleteness of the last UTF-8 character in input text block.
<!---->The caller of DecodeUTF8 should LSEEK the input file by CX bytes back
<!---->before reading the next block of text.
<br/><b>DI=</b> as returned from CallbackProc.
<br/>All other registers are preserved.
<dt>Error</dt><dd><b>CF=1</b> when CallbackProc returned CF to the macro.
<br/><b>CX=</b>0, other registers are preserved.</dd>
<dt>Example</dt><dd class="PRE">       MOV DI,DestString ; It should be long enough for the decoded string.
<!---->       MOV AX,PARA# SourceString
<!---->       MOV ES,AX
<!---->       DecodeUTF8 SourceString, Store:
<!----> Store:PROC1  ; Thanks to using PROC1 instead of PROC it doesn't need bypass by JMP.
<!---->        STOSW ; Store UTF-16 character from AX and advance DI to the next free room.
<!---->        RET   ; Return to DecodeUTF-8 macro with CF=0.
<!---->       ENDPROC1 Store:
<!---->       SUB AX,AX
<!---->       STOSW ; Zero-terminate DestString.
</dd></dl>
<pre>
DecodeUTF8 %MACRO Source, CallbackProc, Size=-1, Width=16
    %IF %Width != 16 && %Width != 32
      %ERROR ID=5932,'Macro "DecodeUTF8" requires Width=16 or Width=32.'
      %EXITMACRO DecodeUTF8
    %ENDIF
    PUSHW %Width, %Size, %CallbackProc, %Source
    CALL DecodeUTF8@RT::
DecodeUTF8@RT:: PROC1
    PUSHAW
    MOV BP,SP
    PUSH ES
      SUB CX,CX
      MOV [BP+12],CX  ; Initialize %ReturnCX to 0.
      MOV DI,[BP+18]  ; %Source.
      MOV CX,[BP+22]  ; %Size.
      MOV SI,DI
      MOV AX,CX
      INC AX
      JZ .Scan:       ; If Size=-1, AX=0 and the Source size will be scanned.
      ADD DI,CX       ; Otherwise use the explicit %Size.
      JNC .No0:
      MOV DI,-1
      JMP .No0:
.Scan:REPNE:SCASB
      JNE .No0:
      DEC DI            ; Omit the terminator from conversion.
.No0: ; Source string without NUL is now at ES:SI..ES:DI.
 BOM  %FOR 0xEF,0xBB,0xBF ; Little-Endian BOM (<code>0xFEFF</code>) encoded in UTF-8.
        CMP SI,DI
        JNB .NoBOM:
        LODSB [ES:SI]
        CMP AL,%BOM
        JNE .NoBOM:
      %ENDFOR BOM
      JMP .Start:     ; BOM was detected, SI is advanced just behind it.
.NoBOM:MOV SI,[BP+18] ; No BOM detected, restore SI to the start of Source again.
.Start:CMP SI,DI      ; Decode one UTF8 character from the string ES:SI..ES:DI.
      JNB .End:
      XOR EBX,EBX
      LODSB [ES:SI]
      MOV BL,AL
      NOT BL
      BSR CX,BX   ; Scan bits 7..0 of inverted first byte of 1,2,3,4 bytes long UTF-8 character.
      MOV BL,AL   ; First byte of 1,2,3,4 bytes long UTF-8 character (not inverted).
      MOV DL,0x7F ; Prepare mask for payload bits in the 1st UTF-8 byte.
      SUB CX,7    ; CX=7,5,4,3 change to CX=0,-2,-3,-4.
      JZ .Out:    ; Done when BX is codepoint 0..0x7F (7bit ASCII character).
      NEG CX      ; ECX=2,3,4 (number of bytes in UTF-8 character).
      SHR DL,CL   ; DL=0x1F,0x0F,0x07 is the payload mask of the first UTF-8 byte.
      AND BL,DL   ; EBX will accumulate payload bits of codepoint.
      CMP CL,2
      JB .Invalid:
      CMP CL,4
      JBE .Good:
.Invalid:
      MOV EAX,0xFFFD ; Invalid UTF-8 detected, output the replacement instead.
      JMP .NoSg:
.Good:DEC CX         ; CX=1, 2 or 3 continuation bytes 10xxxxxxb expected.
      MOV AX,SI      ; Check if there's that many input bytes left.
      ADD AX,CX
      CMP AX,DI
      JBE .Cont:
      DEC SI         ; Rollback, the last UTF-8 character is incomplete.
      SUB DI,SI      ; DI characters (1..3) were not decoded.
      MOV [BP+12],DI ; %ReturnCX.
      JMP .End:      ; CF=0.
.Cont:LODSB [ES:SI]  ; Continuation byte AL=10xxxxxxb expected.
      BTR AX,7       ; Reset the marker bit 7.
      JNC .Invalid:
      BTR AX,6
      JC .Invalid:
      SHL EBX,6      ; Make room in EBX for the next 6 bits.
      OR  BL,AL      ; Accumulate them.
      DEC CX
      JNZ .Cont:
.Out: MOV EAX,EBX ; EAX=EBX is now the decoded codepoint 0..0x10_FFFF.
      ; Check for overlong encodings. DL=0x7F,0x1F,0x0F,0x07 for 1,2,3,4 bytes in UTF-8 character.
      CMP EBX,0x01_0000   ; Codepoint 0x01_0000..0x10_FFFF should be encoded in 4 bytes.
      JAE .NoOverlong:
      CMP BX,0x00_0800    ; Codepoint 0x00_0800..0x00_FFFF should be encoded in 3 bytes.
      JB .2Bts:
      CMP DL,0x0F
      JE  .NoOverlong:
      JMP .Invalid:
.2Bts:CMP BX,0x00_0080    ; Codepoint 0x00_0080..0x00_07FF should be encoded in 2 bytes.
      JB .1Bts:
      CMP DL,0x1F
      JE .NoOverlong:
      JMP .Invalid:
.1Bts:CMP DL,0x7F         ; Codepoint 0x00_0000..0x00_007F should be encoded in 1 byte.
      JE .NoOverlong:
      TEST BX
      JNZ .Invalid:
      CMP DL,0x1F         ; Exception: codepoint 0 may be encoded in 1 or 2 bytes.
      JNE .Invalid:
.NoOverlong:
      SHR EBX,11          ; Check for surrogate codepoints.
      CMP BL,0x1B
      JE .Invalid:            ; Do not accept surrogates 0xD800..0xDFFF from input.
      TEST BX,0x3E0
      JZ .NoSg:           ; If codepoint EAX is below 0x0001_0000, surrogates do not apply.
      CMPW [BP+24],16     ; Output UTF %Width (16 or 32).
      JNE .NoSg:          ; UTF-32 does not need surrogates.
      SUB EAX,0x0001_0000 ; Codepoint EAX was not encodable in one UTF-16 character.
      MOV EBX,0x0000_03FF ; Use two surrogate Unichars.
      AND EBX,EAX
      SHR EAX,10
      ADD EBX,0x0000_DC00 ; EBX is now low surrogate.
      ADD EAX,0x0000_D800 ; EAX is now high surrogate.
      CALL .OutEAX:       ; High surrogate first.
      MOV EAX,EBX         ; Low surrogate.
      JC .End:            ; If aborted by CallbackProc.
.NoSg:CALL .OutEAX:       ; Low surrogate or BMP codepoint or UTF-32.
      JNC .Start:         ; Parse the next UTF-8 character from string ES:SI..ES:DI.
.End:POP ES
     POPAW
     RET 2*4
.OutEAX:PROC              ; Send EAX to callback. Preserves EBX,ES,SI,DI, updates %ReturnDI.
        PUSH EBX,ES,SI,DI
          MOV DI,[BP+0]   ; Restore %ReturnDI from DecodeUTF8@RT frame.
          PUSH BP
            CALL [BP+20]  ; %CallbackProc.
          POP BP
          MOV [BP+0],DI   ; Update %ReturnDI from DecodeUTF8@RT frame.
        POP DI,SI,ES,EBX
        RET
      ENDPROC .OutEAX:
   ENDP1 DecodeUTF8@RT::
 %ENDMACRO DecodeUTF8
</pre><pre>
  ENDHEAD string16
</pre>
<!--TAILMENU-->
<!--Contents below the marker {!==TAILMENU==} was generated by "generate.php".-->
<br class='CLEAR'/><a id='bottom' href='#top'>&#x25B2;Back to the top&#x25B2;</a>
</body></html>
