<!doctype html><html lang='en'><head>
<meta http-equiv='Content-Type' content='text/html; charset=utf-8'/>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=2.0, user-scalable=yes'>
<meta name='robots' content='ALL,FOLLOW'/>
<meta name='description' content='winf64.htm macro library'/>
<meta name='version' content='20250318'/>
<meta name='author' content='Pavel vitsoft Šrubař'/>
<link rel='stylesheet' href='../euroasm.css' type='text/css'/>
<link rel='shortcut icon' href='../favicon.ico'/>
<title>winf64.htm macro library</title>
</head>
<body class='MACLIB' id='top'><div class='HEADMENU'><table>
<tr><td rowspan='2' title='&euro;ASM - assembler and linker'><img src='../favicon.ico' alt='EuroAssembler' />
<td><a href='../index.htm' title='Alphabetical index of all &euro;ASM elements, directives and instructions'>Index</a></td>
<td><a href='../eadoc/' class='EADOC' title='Documentation of EuroAssembler'>Manual</a></td>
<td><a href='https://euroassembler.eu/download/' title='History &amp; download of the latest and previous versions'>Download</a></td>
<td><a href='../easource/' class='EASOURCE' title='Source files of EuroAssembler itself'>Source</a></td>
<td><a href='../maclib/' class='MACLIB' title='Macro libraries shipped with &euro;ASM'>Macros</a></td>
<td rowspan='2' title='Find the searched token in any text file on this site'>
<form method='post' action='../search.php' enctype='multipart/form-data' accept-charset='utf-8'>
<input type='text' id='q' placeholder='Searched word(s)' name='q' value=''/>
<br/><label title='Check the box to find the expression even if it is surrounded by other letters | digits.'>
<input type='checkbox' name='EW'/><small>Embedded word</small></label>
<br/><label title='Check the box for case-insensitive search.'>
<input type='checkbox' name='CI'/><small>Case ins.</small></label>
<input type='submit' title='Search for the specified word|expression in all site files.' name='find' value='Search'/>
</form></td></tr><tr>
<td><a href='../sitemap.htm' title='List of directories and files on this site'>Sitemap</a></td>
<td><a href='../eadoc/links.htm' class='EADOC' title='References and external links to resources used in EuroAssembler developement'>Links</a></td>
<td><a href='https://euroassembler.eu/forum/' title='Discussion forum concerning EuroAssembler'>Forum</a></td>
<td><a href='../eatests/' class='EATESTS' title='Program snippets for testing the function of &euro;ASM'>Tests</a></td>
<td><a href='../objlib/' class='OBJLIB' title='Skeletons and sample objects and projects shipped with &euro;ASM'>Projects</a></td>
</tr></table></div>
<!--Contents above the marker {!==/HEADMENU==} was generated by "generate.php".-->
<!--/HEADMENU-->
<h1>winf64.htm
<br/><i>Class</i>
<br/><a href="#FILE64">FILE64</a>
<br/><i>Encoding</i>
<br/><a href="#FileStatusEnc">FileStatusEnc</a>
<br/><i>Macros</i>
<br/><a href="#FileAppend">FileAppend</a>
<br/><a href="#FileAssign">FileAssign</a>
<br/><a href="#FileClose">FileClose</a>
<br/><a href="#FileCreate">FileCreate</a>
<br/><a href="#FileDelete">FileDelete</a>
<br/><a href="#FileEach">FileEach</a>
<br/><a href="#FileEnclose">FileEnclose</a>
<br/><a href="#FileEnclosedo">FileEnclose$</a>
<br/><a href="#FileEncloseLn">FileEncloseLn</a>
<br/><a href="#FileExistsqm">FileExists?</a>
<br/><a href="#FileLoad">FileLoad</a>
<br/><a href="#FileMapCreate">FileMapCreate</a>
<br/><a href="#FileMapOpen">FileMapOpen</a>
<br/><a href="#FileMkDir">FileMkDir</a>
<br/><a href="#FileMove">FileMove</a>
<br/><a href="#FileNameParse">FileNameParse</a>
<br/><a href="#FileOpen">FileOpen</a>
<br/><a href="#FileRead">FileRead</a>
<br/><a href="#FileReset">FileReset</a>
<br/><a href="#FileStore">FileStore</a>
<br/><a href="#FileStreamAppend">FileStreamAppend</a>
<br/><a href="#FileStreamCreate">FileStreamCreate</a>
<br/><a href="#FileStreamOpen">FileStreamOpen</a>
<br/><a href="#FileStreamRead">FileStreamRead</a>
<br/><a href="#FileStreamReadByte">FileStreamReadByte</a>
<br/><a href="#FileStreamReadLn">FileStreamReadLn</a>
<br/><a href="#FileStreamWrite">FileStreamWrite</a>
<br/><a href="#FileStreamWriteByte">FileStreamWriteByte</a>
<br/><a href="#FileStreamWriteWord">FileStreamWriteWord</a>
<br/><a href="#FileStreamWriteDword">FileStreamWriteDword</a>
<br/><a href="#FileStreamWritedo">FileStreamWrite$</a>
<br/><a href="#FileStreamWriteLn">FileStreamWriteLn</a>
<br/><a href="#FileWrite">FileWrite</a>
<br/><a href="#FileWritedo">FileWrite$</a>
<br/><a href="#FileWriteLn">FileWriteLn</a>
</h1>
<p>This library contains wrapper macros which encapsulate WinAPI calls
<!---->for most typical file operations in <strong>64bit Windows
</strong>. See also equivalent homonymous macroinstructions in
<a class="EXT" href="winf32.htm">winf32.htm</a>,
<a class="EXT" href="linf32.htm">linf32.htm</a>,
<a class="EXT" href="linf64.htm">linf64.htm</a>.
</p>
<table><tr><th>File Access method</th><th>Open</th><th>Data transfer</th><th>Close</th></tr>
<tr><td>read file at once</td><td> - </td><td><a href="#FileLoad">FileLoad</a></td>
<td><a href="#FileClose">FileClose</a></td></tr>
<tr><td>write file at once</td><td> - </td><td><a href="#FileStore">FileStore</a></td><td>-</td></tr>
<tr><td>standard read</td><td><a href="#FileOpen">FileOpen</a></td>
<td><a href="#FileRead">FileRead</a></td><td><a href="#FileClose">FileClose</a></td></tr>
<tr><td>standard write</td><td><a href="#FileCreate">FileCreate</a></td>
<td><a href="#FileWrite">FileWrite</a>, <a href="#FileWriteLn">FileWriteLn</a>,
<a href="#FileWritedo">FileWrite$</a></td><td><a href="#FileClose">FileClose</a></td></tr>
<tr><td>standard write at the end of file</td><td><a href="#FileAppend">FileAppend</a></td>
<td><a href="#FileWrite">FileWrite</a>, <a href="#FileWriteLn">FileWriteLn</a>,
<a href="#FileWritedo">FileWrite$</a></td><td><a href="#FileClose">FileClose</a></td></tr>
<tr><td>memory mapped read</td><td><a href="#FileMapOpen">FileMapOpen</a></td><td>-</td>
<td><a href="#FileClose">FileClose</a></td></tr>
<tr><td>memory mapped write</td><td><a href="#FileMapCreate">FileMapCreate</a></td>
<td>-</td><td><a href="#FileClose">FileClose</a></td></tr>
<tr><td>buffered read</td><td><a href="#FileStreamOpen">FileStreamOpen</a></td>
<td><a href="#FileStreamReadByte">FileStreamReadByte</a>,
<a href="#FileStreamRead">FileStreamRead</a>, <a href="#FileStreamReadLn">FileStreamReadLn</a></td>
<td><a href="#FileClose">FileClose</a></td></tr>
<tr><td>buffered write</td><td><a href="#FileStreamCreate">FileStreamCreate</a></td>
<td><a href="#FileStreamWriteByte">FileStreamWriteByte</a>, <a href="#FileStreamWriteWord">FileStreamWriteWord</a>,
<a href="#FileStreamWriteDword">FileStreamWriteDword</a>,
<a href="#FileStreamWrite">FileStreamWrite</a>, <a href="#FileStreamWriteLn">FileStreamWriteLn</a>,
<a href="#FileStreamWritedo">FileStreamWrite$</a></td><td><a href="#FileClose">FileClose</a></td></tr>
<tr><td>buffered write at end of file</td><td><a href="#FileStreamAppend">FileStreamAppend</a></td>
<td><a href="#FileStreamWriteByte">FileStreamWriteByte</a>,
<a href="#FileStreamWriteWord">FileStreamWriteWord</a>, <a href="#FileStreamWriteDword">FileStreamWriteDword</a>,
<a href="#FileStreamWrite">FileStreamWrite</a>, <a href="#FileStreamWriteLn">FileStreamWriteLn</a>,
<a href="#FileStreamWritedo">FileStreamWrite$</a></td><td><a href="#FileClose">FileClose</a></td></tr>
<tr><td>append to file</td><td> - </td><td><a href="#FileEnclose">FileEnclose</a>,
<a href="#FileEncloseLn">FileEncloseLn</a>, <a href="#FileEnclosedo">FileEnclose$</a></td><td>-</td></tr>
<tr><td>special functions</td><td><a href="#FileReset">FileReset</a></td>
<td><a href="#FileAssign">FileAssign</a>, <a href="#FileExistsqm">FileExists?</a>,
<a href="#FileNameParse">FileNameParse</a>,
<a href="#FileMove">FileMove</a>,
<a href="#FileMkDir">FileMkDir</a>, <a href="#FileEach">FileEach</a></td>
<td><a href="#FileDelete">FileDelete</a></td></tr>
</table>
<p>Macros return the results in registers, usually RAX. Other registers
<!---->do not change. CF is set when error occurs, ZF is set at the end
<!---->of file, DF must be always reset. Other flags are undefined.</p>
<p>Association of the FILE64 object with the name of file is provided separately, using the macro
<a href="#FileAssign">FileAssign</a>. File must be assigned before opening.</p>
<p>Macro names suffixed with <em>~Ln</em> write CR+LF characters after the data.
<!---->Macro names suffixed with <em>~$</em> expect NULL-terminated input data.</p>
<p>Acces methods <em>at once, stream, memory-map</em> allocate dynamic virtual memory. It will be freed in
<a href="#FileClose">FileClose</a>.</p>

<table><tr><th rowspan="2">Access method</th><th colspan="2">Virtual memory</th></tr>
<tr><th>reserved</th><th>comitted</th></tr>
<tr><th>At once load</th><td>filesize</td><td>filesize</td></tr>
<tr><th>At once store</th><td>none</td><td>none</td></tr>
<tr><th>Standard</th><td>none</td><td>none</td></tr>
<tr><th>MemoryMapped</th><td>filesize</td><td>pagesize</td></tr>
<tr><th>Streamed</th><td>buffersize</td><td>buffersize</td></tr>
</table>

<p>File access method <strong>at once</strong> loads entire file content
<!---->into comitted memory, so it is suitable for small files only.
<!---->The loaded/stored file doesn't need explicit opening nor closing.</p>
<blockquote>This access method is equivalent to PHP functions
<a class="EXTW" href="https://www.php.net/manual/en/function.file-get-contents.php">file_get_contents</a>,
<a class="EXTW" href="https://www.php.net/manual/en/function.file-put-contents.php">file_put_contents</a>.
</blockquote>
<p>Access method <strong>enclose</strong> opens the file at its end
<!---->for writing, appends the data and closes file in one operation.</p>
<p><strong>Standard</strong> read/write methods only encapsulate API functions
<em>read/write</em> and they can process files of any size. Example:</p><br class="CLEAR"/>
<div class="PRE">[.bss]
<!---->InpFile  DS FILE64
<!---->OutFile  DS FILE64
<!---->Record:  DB 512 * BYTE
<!---->[.text]
<!---->         FileAssign InpFile, ="Input.dat"
<!---->         FileAssign OutFile, ="Output.dat"
<!---->         FileOpen   InpFile
<!---->         JC .InpErr:
<!---->         FileCreate OutFile
<!---->         JC .OutErr:
<!---->.Next:   FileRead   InpFile, Record, SIZE# Record
<!---->         JC .InpErr:
<!---->         JZ .EOF:
<!---->         CALL ModifyRecord
<!---->         FileWrite  OutFile, Record, SIZE# Record
<!---->         JC .OutErr:
<!---->         JMP .Next:
<!---->.InpErr: StdOutput ="Error reading ",InpFile.Name
<!---->         JMP .EOF:
<!---->.OutErr: StdOutput ="Error writing ",OutFile.Name
<!---->.EOF:    FileClose OutFile, InpFile
<!---->         TerminateProgram
</div>
<p><strong>Memory mapped</strong> file access reserves memory for the entire file contents
<!---->virtually loaded to memory.</p>
<p><strong>Streamed</strong> (buffered) file access method allocates its own memory buffer
<!---->to accelerate reading/writing of small pieces of data.
<!---->This method is also suitable for processing text files line by line.
<!---->Example:</p>
<div class="PRE">  FileAssign InpFile, ="Input.txt"
<!---->  FileAssign OutFile, ="Output.txt"
<!---->  FileStreamOpen   InpFile
<!---->  JC .Error:
<!---->  FileStreamCreate OutFile
<!---->  JC .Error:
<!---->.Next:
<!---->  FileStreamReadLn  InpFile
<!---->  JC .Error:
<!---->  JZ .EOF:
<!---->  MOV RCX,RAX ; line size
<!---->  MOV RDI,aLine
<!---->  REP MOVSB
<!---->  CALL ModifyLine
<!---->  FileStreamWrite  OutFile, aLine, RAX
<!---->  JC .Error:
<!---->  JMP .Next:
<!---->.EOF: FileClose OutFile, InpFile
</div>
<p>Common limitations: This library cannot be used if special requirements are required,
<!---->such as overlapped file access, other than normal file attributes,
<!---->nonstandard share disposition, files bigger than 2 GB,
<!---->filename longer than 260 characters.</p>
<p>Runtime procedures defined in this library use macros
<a class="EXT" href="winabi.htm#WinABI">WinABI</a>,
<a class="EXT" href="cpuext.htm#Dispatch">Dispatch</a>,
<a class="EXT" href="status32.htm">status32.htm</a>.</p>  s
<br clear="all"><pre>
winf64 HEAD
 INCLUDEHEAD1 winsfile.htm, wins.htm, winabi.htm, winscon.htm, status32.htm, cpuext.htm
</pre>

<dl id="FILE64"><dt><a href="#top">FILE64</a></dt><dd> structure keeps information about the file status.
<!---->Variable with FILE64 structure should be defined for each file used in program,
<!---->either statically (in .data segment) or cleared when defined on stack or .bss.
<!---->Pointer to a FILE64 structured variable
<!---->is passed as the first parameter to all macros in this library.</dd></dl><pre>
FILE64      STRUC
 .Ptr       DQ  Q ; Pointer to the file content in memory-mapped|buffered data.
 .Top       DQ  Q ; Pointer to the end of the memory-mapped|buffered data.
 .BufPtr    DQ  Q ; Pointer to the memory-map|allocated buffer.
 .BufSize   DQ  Q ; Size of memory map|buffer.
 .Pos       DQ  Q ; Zero based offset of the file position.
 .Size      DQ  Q ; File size in bytes.
 .Handle    DQ  Q ; Handle to the opened file.
 .MapHandle DQ  Q ; Handle to the file mapping.
 .Status    DD  D ; File status flags, see <a href="#FileStatusEnc">FileStatusEnc</a>.
 .NameOffs  DD  D ; Offset of the filename without path inside the .Name. Zero if no path in .Name.
 .ExtOffs   DD  D ; Offset of the file extension inside the .Name.
 .Name      D MAX_PATH_SIZE * U ; Zero terminated WIDE|ANSI file name.
 ENDSTRUC FILE64
</pre>

<dl id="FileStatusEnc"><dt><a href="#top">FileStatusEnc</a></dt><dd>Definition of flags which describe
<code>FILE64.Status</code>.</dd></dl><pre>
fi64StFound      EQU 0x00000010 ; File was once succesfully opened.
fi64StAppend     EQU 0x00100000 ; Created file should move its pointer to the end.
fi64StStdIO      EQU 0x00200000 ; FILE64.Handle is standard input|output.
fi64StAllocated  EQU 0x00400000 ; FILE64.BufPtr is pointer to the allocated memory.
fi64StUnicode    EQU 0x00800000 ; FILE64.Name is in WIDE characters.
fi64StMapCreated EQU 0x01000000 ; FILE64.MapHandle is valid for writing.
fi64StMapOpened  EQU 0x02000000 ; FILE64.MapHandle is valid for reading.
fi64StMapped     EQU 0x04000000 ; FILE64.Ptr is pointer to the mapped memory.
fi64StCreated    EQU 0x10000000 ; FILE64.Handle is valid for writing.
fi64StOpened     EQU 0x20000000 ; FILE64.Handle is valid for reading.
</pre>

<dl id="FileNameParse"><dt><a href="#top"> FileNameParse</a> FileNamePtr, Size= -1, Unicode=%^UNICODE</dt>
<dd><dfn>FileNameParse</dfn> will analyze string with complete FileName, which may contain path, name, extension,
<!---->and return pointers to the name without path and to the file extension.
<br/>Name starts behind the last slash <kbd>/</kbd>, backslash <kbd>\</kbd> or colon<kbd>:</kbd>.
<!---->If no such characters exists, the whole input string is name.
<br/>File extension starts at the last point <kbd>.</kbd> in the name.
<!---->If there is no point in name, extension is empty.</dd>
<dt>Input</dt><dd><b>FileNamePtr</b> is pointer to a string of ANSII or WIDE characters.
<br><b>Size</b>=-1 is the size of input string in bytes. By default it is unlimited and the
<!---->string must be zero terminated in this case.
<br/><b>Unicode</b>=%^UNICODE specifies whether the FileNamePtr string is ANSI or WIDE.
<!---->By default it copies the value of system variable
<code>%^UNICODE</code> at macro invocation
<!---->but you may want to set this parameter to 0 even if %UNICODE is enabled and vice versa.</dd>
<dt>Output</dt><dd><b>RAX</b> is pointer to the start of name without path.
<br><b>RCX</b> is pointer to the start of extension.
<br><b>RDX</b> points behind the last FileName character.
<br>Path starts at %FileNamePtr, size=RAX - OFFSET#FileNamePtr
<br>Name starts at RAX, size=RCX - RAX
<br>Extension starts at RCX, size=RDX - RCX</dd>
<dt>Error</dt><dd>-</dd>
<dt>Examples</dt><dd class="PRE"><abbr>%FileNamePtr &#x2502;                             &#x2502;           &#x2502;               &#x2502;</abbr>
<!----><b>            "D:\path.ext\nam.part1.txt"   "\plain"    "./.profile"    "name"</b>
<abbr>                         &#x2502;        &#x2502;   &#x2502;     &#x2502;    &#x2502;       &#x2502;       &#x2502;     &#x2502;   &#x2502;</abbr>
<abbr>                        RAX       &#x2502;   &#x2502;    RAX   &#x2502;      RAX      &#x2502;    RAX  &#x2502;</abbr>
<abbr>                                 RCX  &#x2502;         RCX     RCX      &#x2502;        RCX</abbr>
<abbr>                                     RDX        RDX             RDX       RDX</abbr>
</dd></dl><pre>
FileNameParse %MACRO FileNamePtr,Size=-1, Unicode=%^UNICODE
    PUSHQ %Size,%FileNamePtr
    %IF %Unicode
       CALL FileNameParseW64@RT::
FileNameParseW64@RT:: PROC1
    PUSH RAX,RCX,RDX,RSI
     MOV RSI,[RSP+40] ; %FileNamePtr.
     MOV RDX,[RSP+48] ; %Size.
     SUB RCX,RCX
     TEST RDX
     JS .UnlimitedSize:
     ADD RDX,RSI ; End of input string.
.UnlimitedSize:
     MOV [RSP+24],RCX ; Returned RAX.
     MOV [RSP+16],RCX ; Returned RCX.
     MOV [RSP+08],RCX ; Returned RDX.
.NextChar:
     CMP RSI,RDX
     JNB .E0:
     LODSW
     Dispatch AX,58,92,47,46,0 ; colon, backslash, slash, dot, NULL
     ; Ordinary character.
     LEA RAX,[RSI-2]
     CMP [RSP+24],RCX          ; ReturnedRAX.
     JNZ .NextChar:
     MOV [RSP+24],RAX          ; ReturnedRAX.
     JMP .NextChar:
.46: ; dot .
     LEA RAX,[RSI-2]
     MOV [RSP+16],RAX          ; ReturnedRCX.
     CMP [RSP+24],RCX          ; ReturnedRAX.
     JNE .NextChar:
     MOV [RSP+24],RAX          ; ReturnedRAX.
     JMP .NextChar:
.47: ; Colon, slash, backslash.
.58:
.92: MOV [RSP+24],RSI          ; ReturnedRAX.
     MOV [RSP+16],RCX          ; ReturnedRCX.
     JMP .NextChar:
 .0: DEC RSI,RSI ; Unichar NULL.
 .E0:MOV [RSP+08],RSI          ; ReturnedRDX.
     CMP [RSP+16],RCX          ; ReturnedRCX.
     JNE .E1:
     MOV [RSP+16],RSI          ; ReturnedRCX.
 .E1:CMP [RSP+24],RCX          ; ReturnedRAX.
     JNE .E2:
     MOV RAX,[RSP+16]          ; ReturnedRCX.
     MOV [RSP+24],RAX          ; ReturnedRAX.
 .E2:POP RSI,RDX,RCX,RAX
    RET 2*8
   ENDPROC1 FileNameParseW64@RT::
    %ELSE ; <b>ANSI variant</b>.
     CALL FileNameParseA64@RT::
FileNameParseA64@RT:: PROC1
    PUSH RAX,RCX,RDX,RSI
     MOV RSI,[RSP+40] ; %FileNamePtr.
     MOV RDX,[RSP+48] ; %Size.
     SUB RCX,RCX
     TEST RDX
     JS .UnlimitedSize:
     ADD RDX,RSI ; End of input string.
 .UnlimitedSize:
     MOV [RSP+24],RCX
     MOV [RSP+16],RCX
     MOV [RSP+08],RCX
 .NextChar:
     CMP RSI,RDX
     JNB .E0:
     LODSB
     Dispatch AL,58,92,47,46,0 ; colon, backslash, slash, dot, NULL.
     ; Ordinary character.
     LEA RAX,[RSI-1]
     CMP [RSP+24],RCX
     JNZ .NextChar:
     MOV [RSP+24],RAX
     JMP .NextChar:
.46: ; dot .
     LEA RAX,[RSI-1]
     MOV [RSP+16],RAX
     CMP [RSP+24],RCX
     JNE .NextChar:
     MOV [RSP+24],RAX
     JMP .NextChar:
.47: ; colon, slash, backslash
.58:
.92: MOV [RSP+24],RSI
     MOV [RSP+16],RCX
     JMP .NextChar:
.0:  DEC RSI ; Byte NULL.
 .E0:MOV [RSP+08],RSI
     CMP [RSP+16],RCX
     JNE .E1:
     MOV [RSP+16],RSI
 .E1:CMP [RSP+24],RCX
     JNE .E2:
     MOV RAX,[RSP+16]
     MOV [RSP+24],RAX
 .E2:POP RSI,RDX,RCX,RAX
    RET 2*8
   ENDPROC1 FileNameParseA64@RT::
  %ENDIF ; %Unicode
 %ENDMACRO FileNameParse
</pre>

<dl id="FileAssign"><dt><a href="#top">FileAssign</a> theFile, Name$1, Name$2,,,Size=-1, Unicode=%^UNICODE</dt>
<dd>Macro <dfn>FileAssign</dfn> associates file name with the <a href="#FILE64">FILE64
</a> data object. Name of the file is copied to <code>theFile.Name</code> member.
<br/>The file must be assigned with file name before it is created or opened.
<!---->FileAssign can concatenate the filename from several input strings, e.g. path, name, extension.</dd>
<dt>Input</dt><dd><b>theFile</b> is pointer to a <a href="#FILE64">FILE64</a> structured memory variable.
<br><b>Name$*</b> is pointer to a zero terminated string with the file name or its part.
<!---->It needs not be zero terminated when Size= is expicitly specified.
<!---->Filename will be concatenated when more than one string is provided.
<br>Name$1 may also be 0 or pointer to an empty string. The file is then assigned
<!---->to standard input or output.
<br>Device name, such as COM1, LPT1, NULL, may be assigned instead of a disk file.
<br/><b>Size=</b> applies to all input strings. Size is unlimited
<!---->by default and the strings must be zero terminated in this case.
<br/><b>Unicode</b>=%^UNICODE specifies whether the Name$ strings are ANSI or WIDE.
<!---->By default it copies the current status of <code>EUROASM UNICODE=
</code> option at macro invocation,
<!---->but you may want to set this parameter to 0 even if UNICODE is globally enabled, and vice versa.</dd>
<dt>Output</dt><dd>Members of theFile <code>.Name, .NameOffs, .ExtOffs, .Status:fi64StUnicode</code> of <code>theFile</code> are set.</dd>
<dt>Error</dt><dd><b>CF</b>=1 if the concatenated name length exceeds
<code>SIZE# FILE64.Name</code>, i.e. MAX_PATH_SIZE=260 characters.</dd>
<dt>Depends on</dt><dd><a href="#FileNameParse">FileNameParse</a></dd>
<dt>Examples</dt><dd class="PRE">File1 DS FILE64
<!---->Path$ DB "C:\Text\",0
<!---->Name$ DB "Some",0
<!---->Ext$  DB ".txt",0
<!---->[.text]
<!---->      FileAssign File1,Path$,Name$,Ext$
<!---->      FileAssign File1,=U"\\Server\Share\File.txt",Unicode=1
<!---->      FileAssign File1,0  ; Standard output, by default redirected to console.
<!---->      FileAssign File1,="CON" ; Output to system console, not redirectable.
</dd></dl><pre>
FileAssign %MACRO theFile,Name$1,Name$2,,, Size=-1, Unicode=%^UNICODE
   %IF %#<2                                                                 ; >
     %ERROR ID=5941, 'File name missing in macro "FileAssign".'
     %EXITMACRO FileAssign
   %ENDIF
   PUSHQ 0 ; Mark the end of arguments.
   ArgNr %FOR %#..2,STEP=-1
     PUSHQ %*{%ArgNr}
   %ENDFOR ArgNr
   PUSHQ %Size, %theFile, RSP
   ADDQ [RSP],8*(%#+2)
   %IF %Unicode
     CALL FileAssignW64@RT::
FileAssignW64@RT:: PROC1 ; <b>Wide variant</b>.
   PUSH RAX,RCX,RDX,RBX,RBP,RSI,RDI
    MOV RBX,[RSP+72] ; %theFile
    LEA RBP,[RSP+88] ; %Name$1
    LEA RDI,[RBX+FILE64.Name]
    SetSt   [RBX+FILE64.Status],fi64StUnicode
    LEA RDX,[RDI+MAX_PATH_SIZE-2]
.10:XCHG RBP,RSI
    LODSQ            ; Offset of source string.
    MOV RBP,RAX
    XCHG RSI,RBP
    TEST RAX         ; No more macro arguments (zero marker)?
    JZ .50:
    MOV RCX,[RSP+80] ; %Size.
    SAR RCX,1 ; Size in unichars.
    JZ .10:
.20:LODSW
    CMP AX,0
    JE .10:
    CMP RDI,RDX
    JNB .40:
    STOSW
    LOOP .20:
    JMP .10:
.40:SUB EAX,EAX
    STC ; Overflow.
.50:MOV RCX,RDI
    STOSW
    LEA RDX,[RBX+FILE64.Name]
    PUSHFQ
     SUB RCX,RDX
     FileNameParse RDX,Size=RCX,Unicode=1
     LEA RDX,[RBX+FILE64.Name]
     SUB RAX,RDX
     SUB RCX,RDX
     MOV [RBX+FILE64.NameOffs],EAX
     MOV [RBX+FILE64.ExtOffs],ECX
    POPFQ
   POP RDI,RSI,RBP,RBX,RDX,RCX,RAX
   RET
ENDPROC1 FileAssignW64@RT::
   %ELSE ; ANSI.
     CALL FileAssignA64@RT::
FileAssignA64@RT:: PROC1 ; <b>ANSI variant</b>.
   PUSH RAX,RCX,RDX,RBX,RBP,RSI,RDI
    MOV RBX,[RSP+72] ; %theFile
    LEA RBP,[RSP+88] ; %Name$1
    LEA RDI,[RBX+FILE64.Name]
    RstSt   [RBX+FILE64.Status],fi64StUnicode
    LEA RDX,[RDI+MAX_PATH_SIZE]
.10:XCHG RBP,RSI
    LODSQ                 ; Offset of source string.
    MOV RBP,RAX
    XCHG RSI,RBP
    TEST RAX
    JZ .50:
    MOV RCX,[RSP+80]      ; %Size.
    JRCXZ .10:
.20:LODSB
    CMP AL,0
    JE .10:
    CMP RDI,RDX
    JNB .40:
    STOSB
    LOOP .20:
    JMP .10:
.40:SUB EAX,EAX
    STC ; Overflow.
.50:MOV RCX,RDI
    STOSB
    LEA RDX,[RBX+FILE64.Name]
    PUSHFQ
      SUB RCX,RDX
      FileNameParse RDX,Size=RCX,Unicode=0
      LEA RDX,[RBX+FILE64.Name]
      SUB RAX,RDX
      SUB RCX,RDX
      MOV [RBX+FILE64.NameOffs],EAX
      MOV [RBX+FILE64.ExtOffs],ECX
    POPFQ
   POP RDI,RSI,RBP,RBX,RDX,RCX,RAX
   RET
ENDPROC1 FileAssignA64@RT::
   %ENDIF
   POP RSP
%ENDMACRO FileAssign
</pre>

<dl id="FileExistsqm"><dt><a href="#top">FileExists?</a> theFile</dt><dd> will test if the given
<!---->file with assigned name exists on disk. File may be opened or closed. Wildcard characters
<code>* ?</code> are allowed in the file name.
<br/>This macro can test the presence of a directory, too.</dd>
<dt>Input</dt><dd><b>theFile</b> is pointer to <a href="#FILE64">FILE64</a> object with assigned name.</dd>
<dt>Output</dt><dd><b>CF</b>=1 if the file|directory does not exist.
<br><b>CF</b>=0  <b>ZF</b>=1 if the file exists
<br><b>CF</b>=0  <b>ZF</b>=0 if the directory exists</dd>
<dt>Example</dt><dd><div class="PRE">FileExists? =".\Config.ini"
<!---->JC ErrorIniNotFound
</div></dd></dl> <pre>
FileExists? %MACRO theFile
     PUSHQ %theFile
     CALL FileExists?64@RT::
FileExists?64@RT:: PROC1
    IMPORT FindFirstFileA,FindFirstFileW
    PUSH RAX,RBX,RSI,RDI
     MOV RBX,[RSP+40] ; theFile
     LEA RSI,[RBX+FILE64.Name]
     SUB RSP,SIZE# WIN32_FIND_DATAW
     MOV RDI,RSP
     LEA RAX,[FindFirstFileW::]      ; WinABI function thunk.
     JSt [RBX+FILE64.Status],fi64StUnicode,.20
     LEA RAX,[FindFirstFileA::]      ; WinABI function thunk.
 .20:WinABI RAX,RSI,RDI, Fastmode=No ; FindFirstFile.
 .30:CMP RAX,INVALID_HANDLE_VALUE
     STC
     JE .90
     WinABI FindClose,RAX,Fastmode=No
     TEST [RDI+WIN32_FIND_DATAW.FileAttributes],FILE_ATTRIBUTE_DIRECTORY
 .90:LEA RSP,[RSP+SIZE# WIN32_FIND_DATAW]
    POP RDI,RSI,RBX,RAX
    RET 1*8
  ENDPROC1 FileExists?64@RT::
 %ENDMACRO FileExists?
</pre>

<dl id="FileMkDir"><dt><a href="#top">FileMkDir</a> theFile</dt><dd> will parse the file name
<!---->and create all directories in its path if they didn't exist.
<br/>The last portion of assigned name is treated as directory only if
<!---->it is terminated with backslash.</dd>
<dt>Input</dt><dd><b>theFile</b> is pointer to <a href="#FILE64">FILE64</a> object with assigned name.</dd>
<dt>Output</dt><dd><b>CF</b>=0
<br/><b>RAX</b>=0 if the directory was created or if it existed before.</dd>
<dt>Error</dt><dd><b>CF</b>=1
<br/><b>RAX</b>=last error if CreateDirectory failed.</dd>
<dt>Example</dt><dd><div class="PRE">FileAssign SomeFile, ="C:\D1\D2\file.txt"
<!---->FileMkDir SomeFile ; will create folders C:\D1 and C:\D1\D2
<!---->FileAssign SomeFile, ="C:\D1\D2\file.txt\"
<!---->FileMkDir SomeFile ; will create folders C:\D1, C:\D1\D2 and C:\D1\D2\file.txt\
</div></dd></dl><pre>
FileMkDir %MACRO theFile
     PUSHQ %theFile
     CALL FileMkDir64@RT::
FileMkDir64@RT:: PROC1
   PUSH RCX,RDX,RBX,RBP,RSI,RDI
    MOV RBP,RSP
    MOV RBX,[RBP+56]        ; RBX=Pointer to %theFile structure FILE64.
    SUB RSP,SIZE#WIN32_FIND_DATAW
    MOV RDX,RSP             ; RDX=Local FindData structure.
    SUB RSP,2* MAX_PATH_SIZE
    MOV RDI,RSP             ; RSP=LocalVar for the copy of directory name.
    LEA RSI,[RBX+FILE64.Name]
    MOV CX,'\'
    MOVW [RSI+SIZE#FILE64.Name-2],0 ; Zero terminate MAX_PATH_SIZE for safety.
    JSt [RBX+FILE64.Status],fi64StUnicode,.50:
    ; <b>ANSI variant</b>.
    LODSB
    CMP AL,0
    JE .Done:
    CMP AL,CL
    JNE .30:
    CMP [RSI],CL            ; Test the case "\\server\share\dir\file".
    JNE .30:
    STOSB
    LODSB
.10:STOSB
    LODSB
    CMP AL,0
    JE .Done:
    CMP AL,CL
    JNE .10:
.20:STOSB
    LODSB
    CMP AL,0
    JE .Done:
    CMP AL,CL
    JNE .20:
.30:STOSB
    LODSB
    CMP AL,0
    JE .Done:
    CMP AL,CL
    JNE .30:
    CMPB [RDI-1],':'        ; Test the case "D:\dir\file".
    JE .30:
    SUB EAX,EAX
    STOSB                   ; Temporary terminate folder name.
    MOV RAX,RSP             ; Local copy of directory name.
    WinABI FindFirstFileA,RAX,RDX,Fastmode=No
    CMP RAX,INVALID_HANDLE_VALUE
    JE .35:
    WinABI FindClose,RAX,Fastmode=No
    JSt [RDX+WIN32_FIND_DATAA.FileAttributes],FILE_ATTRIBUTE_DIRECTORY,.40:
.35:MOV RAX,RSP             ; Local copy of directory name.
    WinABI CreateDirectoryA,RAX,0,Fastmode=No
    TEST RAX
    JZ .Error:
.40:DEC RDI                 ; Remove temporary zero-terminator.
    MOV EAX,ECX
    JMP .30:
.50: ; <b>WIDE variant</b>.
    LODSW
    CMP AX,0
    JE .Done:
    CMP AX,CX
    JNE .80:
    CMP [RSI],CX           ; Test the case "\\server\share\dir\file".
    JNE .80:
    STOSW
    LODSW
.60:STOSW
    LODSW
    CMP AX,0
    JE .Done:
    CMP AX,CX
    JNE .60:
.70:STOSW
    LODSW
    CMP AX,0
    JE .Done:
    CMP AX,CX
    JNE .70:
.80:STOSW
    LODSW
    CMP AX,0
    JE .Done:
    CMP AX,CX
    JNE .80:
    CMPW [EDI-2],':'        ; Test the case "D:\dir\file".
    JE .80:
    SUB EAX,EAX
    STOSW                   ; Temporary terminate folder name.
    MOV RAX,RSP             ; Local copy of directory name.
    WinABI FindFirstFileW,RAX,RDX,Fastmode=No
    CMP RAX,INVALID_HANDLE_VALUE
    JE .85:
    WinABI FindClose,RAX,Fastmode=No
    JSt [RDX+WIN32_FIND_DATAW.FileAttributes],FILE_ATTRIBUTE_DIRECTORY,.90:
.85:MOV RAX,RSP             ; Local copy of directory name.
    WinABI CreateDirectoryW,RAX,0,Fastmode=No
    TEST RAX
    JNZ .90:
.Error:WinABI GetLastError,Fastmode=No
    STC
    JMP .Ret:
.90:DEC RDI,RDI             ; Remove temporary zero-terminator.
    MOV EAX,ECX
    JMP .80:
.Done:SUB EAX,EAX
.Ret:MOV RSP,RBP
   POP RDI,RSI,RBP,RBX,RDX,RCX
   RET 1*8
 ENDPROC1 FileMkDir64@RT::
%ENDMACRO FileMkDir
</pre>

<dl id="FileFlush"><dt><a href="#top">FileFlush</a> theFile</dt>
<dd> is a service macro
<!---->used internally in FileClose, FileStreamWrite* to write the contents
<!---->of file buffer on disk. There is no reason to invoke this macro
<!---->explicitly by the programmer.</dd>
<dt>Output</dt><dd><b>CF=</b>0
<br/><b>EAX=</b>0.</dd>
<dt>Error</dt><dd><b>CF=</b>1
<br/><b>RAX=</b> errorCode as returned from GetLastError.</dd></dl><pre>
FileFlush %MACRO theFile
 ; OUT: CF=1 EAX=error     CF=0 EAX=unchanged
      PUSHQ %theFile
      CALL FileFlush64@RT::
FileFlush64@RT:: PROC1
   PUSH RCX,RDX,RBX,RSI,RDI
    MOV RBX,[RSP+48]       ; theFile.
    MOV RAX,0xE0070004     ; File is not opened.
    JNSt [RBX+FILE64.Status],fi64StAllocated,.ErrorRAX:
    JNSt [RBX+FILE64.Status],fi64StCreated,  .ErrorRAX:
    MOV RDI,[RBX+FILE64.Ptr]
    MOV RSI,[RBX+FILE64.BufPtr]
    MOV [RBX+FILE64.Ptr],RSI
    SUB RDI,RSI
    PUSH RDX
     MOV RDX,RSP
     WinABI WriteFile,[RBX+FILE64.Handle],RSI,RDI,RDX,0,Fastmode=No
    POP RDX                 ; Written size.
    TEST RAX
    JZ .EndWithLastError:
    XOR EAX,EAX
    CMP RDI,RDX
    JE .Ret:
.EndWithLastError:
     WinABI GetLastError,Fastmode=No
.ErrorRAX:
     STC
.Ret:POP RDI,RSI,RBX,RDX,RCX
     RET 1*8
 ENDPROC1 FileFlush64@RT::
%ENDMACRO FileFlush
</pre>

<dl id="FileClose"><dt><a href="#top">FileClose</a> theFile1, theFile2,,,</dt>
<dd> Macro <dfn>FileClose</dfn> will flush and deallocate
<!---->the buffer, close file mapping, close the file, clear pointers
<!---->in the FILE64 structure.
<br>FileClose does not clear the name assignment, so the closed file
<!---->may be reopen with the same name without invoking FileAssign again.</dd>
<dt>Input</dt><dd><b>theFile</b> is pointer to a <a href="#FILE64">FILE64</a> object.
<!---->More than one file may be specified simultaneously.</dd>
<dt>Output</dt><dd>-</dd>
<dt>Error</dt><dd>-</dd></dl><pre>
FileClose %MACRO theFile1
  ArgNr %FOR 1..%#
       PUSHQ %*{%ArgNr}
       CALL FileClose64@RT::
     %ENDFOR ArgNr
FileClose64@RT:: PROC1
     PUSH RBX,RSI,RDI
      MOV RBX,[ESP+32]      ; theFile
      SUB ESI,ESI
      MOV RDI,INVALID_HANDLE_VALUE
      JNSt [RBX+FILE64.Status],fi64StAllocated,.10:
      FileFlush RBX
      WinABI GlobalFree,[RBX+FILE64.BufPtr],Fastmode=No
      RstSt [RBX+FILE64.Status],fi64StAllocated
 .10: MOV [RBX+FILE64.BufPtr],RSI
      MOV [RBX+FILE64.BufSize],RSI
      JNSt [RBX+FILE64.Status],fi64StMapped,.20:
      WinABI UnmapViewOfFile,[RBX+FILE64.Ptr],Fastmode=No
      RstSt [RBX+FILE64.Status],fi64StMapped
 .20: MOV [RBX+FILE64.Ptr],RSI
      MOV [RBX+FILE64.Top],RSI
      JNSt [RBX+FILE64.Status],fi64StMapOpened|fi64StMapCreated,.30:
      WinABI CloseHandle,[RBX+FILE64.MapHandle],Fastmode=No
 .30: RstSt [RBX+FILE64.Status],fi64StMapOpened|fi64StMapCreated
      MOV [RBX+FILE64.MapHandle],RDI
      JNSt [RBX+FILE64.Status],fi64StOpened|fi64StCreated,.40:
      JSt  [RBX+FILE64.Status],fi64StStdIO,.40
      WinABI CloseHandle,[RBX+FILE64.Handle],Fastmode=No
 .40: RstSt [RBX+FILE64.Status],fi64StOpened|fi64StCreated|fi64StAppend
      MOV [RBX+FILE64.Handle],RDI
     POP RDI,RSI,RBX
     RET 1*8
   ENDPROC1 FileClose64@RT::
 %ENDMACRO FileClose
</pre>

<dl id="FileMove"><dt><a href="#top">FileMove</a> SourceFile, DestinationFile</dt>
<dd>FileMove renames directory on the same volume or moves the source file
<!---->to the destination. Files will be closed first, if necessarry.
<!---->The destination file will be erased if it existed before.
<br/>Directories in the destination file name will be maked, if necessarry.
<!---->Both files must have been assigned with either WIDE or ANSI name.</dd>
<dt>Input</dt><dd><b>SourceFile</b> and <b>DestinationFile</b> are pointers
<!---->to assigned <a href="#FILE64">FILE64</a> objects.</dd>
<dt>Output</dt><dd><b>CF</b>=0
<br/><b>RAX=</b>0</dd>
<dt>Error</dt><dd><b>CF=</b>1
<br/><b>RAX=</b> error as returned from GetLastError.</dd>
<dt>Depends on</dt><dd><a href="#FileMkDir">FileMkDir</a>
<a href="#FileClose">FileClose</a></dd>
</dl><pre>
FileMove %MACRO SourceFile, DestinationFile
       PUSHQ %DestinationFile, %SourceFile
       CALL FileMove64@RT::
FileMove64@RT:: PROC1
     IMPORT MoveFileExA,MoveFileExW
     PUSH RDX,RBX,RSI,RDI
      MOV RSI,[RSP+40]            ; SourceFile
      MOV RDI,[RSP+48]            ; DestinationFile
      MOV EAX,[RSI+FILE64.Status]
      MOV EDX,[RDI+FILE64.Status]
      MOV EBX,fi64StUnicode
      AND EAX,EBX
      AND EDX,EBX
      CMP EAX,EDX
      MOV RAX,0xC008007B ; Error 123: invalid filename.
      JNE .ErrorRAX:              ; Different width of strings.
      FileClose RSI,RDI
      FileMkDir RDI
      JC .ErrorRAX:
      LEA RSI,[RSI+FILE64.Name]
      LEA RDI,[RDI+FILE64.Name]
      LEA RAX,[MoveFileExW]
      JSt EDX,fi64StUnicode,.30:
      LEA RAX,[MoveFileExA]
 .30: WinABI RAX,RSI,RDI,MOVEFILE_REPLACE_EXISTING | MOVEFILE_COPY_ALLOWED,Fastmode=No
      TEST RAX
      MOV EAX,0
      JNZ .Ret:
      WinABI GetLastError,Fastmode=No
.ErrorRAX:
      STC
.Ret:POP RDI,RSI,RBX,RDX
     RET 2*8
   ENDPROC1 FileMove64@RT::
 %ENDMACRO FileMove
</pre>

<dl id="FileDelete"><dt><a href="#top">FileDelete</a> theFile1, theFile2,,,</dt><dd>
<!---->will close and erase the disk file(s).
<br>FileDelete does not clear the name assignment, so the deleted file
<!---->may be reopen with the same name without invoking FileAssign again.</dd>
<dt>Input</dt><dd><b>theFile</b> is pointer to a <a href="#FILE64">FILE64</a>object.
<!---->More than one file may be specified simultaneously.</dd>
<dt>Output</dt><dd><b>CF</b>=0,
<br/><b>RAX=</b>0 if the last file was succesfully deleted.</dd>
<dt>Error</dt><dd><b>CF=</b>1
<br/><b>RAX=</b> error as returned from GetLastError.</dd>
<dt>Depends on</dt><dd><a href="#FileClose">FileClose</a></dd>
</dl><pre>
FileDelete %MACRO theFile1
  ArgNr %FOR 1..%#
       PUSHQ %*{%ArgNr}
       CALL FileDelete64@RT::
     %ENDFOR ArgNr
FileDelete64@RT:: PROC1
     IMPORT DeleteFileA,DeleteFileW
     PUSH RBX,RSI
      MOV RBX,[RSP+24]     ; theFile.
      FileClose RBX
      LEA RSI,[RBX+FILE64.Name]
      LEA RAX,[DeleteFileW]
      JSt [RBX+FILE64.Status],fi64StUnicode,.30:
      LEA RAX,[DeleteFileA]
 .30: WinABI RAX,RSI,Fastmode=No
      TEST RAX
      JNZ .OK:
      WinABI GetLastError,Fastmode=No
      CMP EAX,2 ; ERROR_FILE_NOT_FOUND
      JE .OK:
      CMP EAX,3 ; ERROR_PATH_NOT_FOUND
      JE .OK:
      STC
      JMPS .90:
.OK:  XOR EAX,EAX
.90: POP RSI,RBX
     RET 1*8
   ENDPROC1 FileDelete64@RT::
 %ENDMACRO FileDelete
</pre>

<dl id="FileEach"><dt><a href="#top">FileEach</a> theFile, CallbackProc</dt>
<dd>Macro <dfn>FileEach</dfn> expects the file object assigned with file name
<!---->which can contain wildcard characters <kbd>*</kbd> and
<kbd>?</kbd>. FileEach will resolve the mask and performs callback procedure
<!---->with each such filename. If no file matches the mask, CallbackProc is never called.</dd>
<dt>Input</dt><dd><b>theFile</b> is a pointer to <a href="#FILE64">FILE64</a> object
<!---->which must have assigned the requested file path and file name mask.
<br><b>CallbackProc</b> is the address of callback procedure.</dd>
<dt>Output</dt><dd><b>RAX</b>=content of RAX at the last CallbackProc exit,
<!---->or 0 if the CallbackProc was never called.</dd>
<dt>CallbackProc</dt><dd> is called with register calling convention.
<!---->CallbackProc should return CF=0 to let FileEach continue with the next file
<!---->otherwise FileEach stops searching.
<dl>  <dt>CallbackProc input registers:</dt>
<dd><b>RBX</b>=pointer to %theFile where the mask in <code>FILE64.Name</code> is replaced
<!---->with the file found in directory. The file is not open.
<br><b>RDX</b>=Find handle, as returned from WinABI function FindFirstFile().
<br/>If CallbackProc aborts the program instead of returning to FileEach,
<!---->it should also close this FindHandle using
<code>WinABI FindClose,RDX</code> before terminating.
<br><b>RSI</b>=pointer to the file name without path inside RBX+FILE64.Name.
<!---->The string is zero-terminated ANSI or WIDE, depending on what mask was assigned to %theFile.
<br/><b>RDI</b>=pointer to <a class="EXT" href="winsfile.htm#WIN32_FIND_DATA">WIN32_FIND_DATA</a> structure
<!---->which contains attributes of the found file.
<br/><b>RBP</b>=RBP at FileEach macro entry. This allows to address local stack variables
<!---->of the procedure which invoked FileEach.
<br>Other registers are undefined at CallbackProc entry.</dd>
<dt>CallbackProc output registers:</dt><dd><b>RAX</b> is passed through. FileEach returns
<!---->RAX value from the last called CallbackProc, or 0 if it was never called.
<br><b>CF</b>=0 to continue with the next file
<br/><b>CF</b>=1 to break further searching. FileEach discards the WIN32_FIND_DATA
<!---->structure pointed to with EDI and exits but the actual file name without wildcards
<!---->assigned to %theFile remains intact.
<br>CallbackProc may destroy any GP register.</dd></dl></dd>
<dt>Depends on</dt><dd><a href="#FileNameParse">FileNameParse</a></dd>
<dt>Example</dt><dd class="PRE">
<!---->MyFile DS FILE64
<!---->   FileAssign MyFile,="D:\Dir\*.*
<!---->   FileEach MyFile, ListFile
<!---->   TerminateProgram
<!---->ListFile PROC
<!---->   StdOutput RSI, Eol=Yes
<!---->   CLC
<!---->   RET
<!----> ENDP ListFile
</dd></dl><pre>
FileEach %MACRO theFile, CallbackProc
     LEA RAX,[%CallbackProc]
     PUSH RAX
     LEA RAX,[%theFile]
     PUSH RAX
     CALL FileEach64@RT::
FileEach64@RT: PROC1
     IMPORT FindFirstFileA,FindFirstFileW,FindNextFileA,FindNextFileW
     PUSHQ 0,RCX,RDX,RBX,RSI,RDI
      MOV RBX,[RSP+56]               ; RBX=theFile.
      SUB RSP,SIZE# WIN32_FIND_DATAW
      MOV RDI,RSP                    ; RDI=Local WIN32_FIND_DATA structure.
      LEA RSI,[RBX+FILE64.Name]
      LEA RAX,[FindFirstFileW]
      JSt [RBX+FILE64.Status],fi64StUnicode, .10:
      LEA RAX,[FindFirstFileA]
.10:  WinABI RAX,RSI,RDI,Fastmode=No
      MOV RDX,RAX                    ; RDX=FindHandle.
      CMP RAX,INVALID_HANDLE_VALUE
      JE .90:
.20:  ; Copy resolved name to theFile.
      LEA RSI,[RDI+WIN32_FIND_DATAW.FileName] ; Identical for WIN32_FIND_DATAA.FileName.
      LEA RDI,[RBX+FILE64.Name]
      MOVZXD RAX,[RBX+FILE64.NameOffs]; Path size.
      ADD RDI,RAX                    ; RDI=^wildcarded mask without path.
      LEA RCX,[RBX+FILE64.Name + SIZE# FILE64.Name]
      SUB RCX,RDI
      REP MOVSB                      ; Copy resolved name to FILE64.
      ; Prepare GPRs for CallbackProc.
      LEA RSI,[RBX+FILE64.Name]
      ADD RSI,RAX                    ; RSI=^resolved name without path.
      MOV RDI,RSP                    ; RDI=Local WIN32_FIND_DATA structure.
      MOV RAX,[RSP+64+SIZE#WIN32_FIND_DATAW] ; RAX=^CallbackProc.
      PUSH RDX,RBX
       CALL RAX                      ; Perform the callback with resolved FILE64.
      POP RBX,RDX
      MOV [RSP+40+SIZE#WIN32_FIND_DATAW],RAX ; Value returned from CallbackProc.
      JC .90:                        ; Abort next files if CallbackProc returned CF.
      MOV RDI,RSP
      LEA RAX,[FindNextFileW]
      JSt [RBX+FILE64.Status],fi64StUnicode, .80:
      LEA RAX,[FindNextFileA]
.80:  WinABI RAX,RDX,RDI,Fastmode=No
      TEST RAX
      JNZ .20:                       ; The next file.
.90:  WinABI FindClose,RDX,Fastmode=No
      ADD RSP,SIZE# WIN32_FIND_DATAW
     POP RDI,RSI,RBX,RDX,RCX,RAX
     RET 2*8
 ENDPROC1 FileEach64@RT:
%ENDMACRO FileEach
</pre>

<dl id="FileLoad"><dt><a href="#top">FileLoad</a>  theFile</dt>
<dd>will allocate memory buffer on Windows heap,
<!---->open the file, read entire file content to memory and then close the file.
<br/>Although the file handle is closed immediately, you should always
<!---->use <a href="#FileClose">FileClose</a> to free allocated buffer
<!---->when the file contents is no longer needed.</dd>
<dt>Input</dt><dd><b>theFile</b> is pointer to <a href="#FILE64">FILE64</a> assigned with filename.</dd>
<dt>Output</dt><dd><b>CF=</b>0
<br/><b>RAX=</b> file size,
<br/><b>RSI=</b> pointer to the file contents in dynamically allocated memory.</dd>
<dt>Error</dt><dd><b>CF=</b>1
<br/><b>RAX=</b> errorCode as returned from GetLastError,
<br/><b>RSI=</b> is undefined.</dd></dl><pre>
FileLoad %MACRO theFile
    PUSHQ %theFile
    CALL FileLoad64@RT::
FileLoad64@RT:: PROC1
    IMPORT CreateFileA,CreateFileW
    PUSH RCX,RDX,RBX,RSI,RDI
     MOV RBX,[RSP+48]           ; %theFile.
     LEA RDX,[RBX+FILE64.Name]
     SUB ESI,ESI
     MOV RDI,INVALID_HANDLE_VALUE
     MOV [RBX+FILE64.Ptr],RSI
     MOV [RBX+FILE64.Top],RSI
     MOV [RBX+FILE64.BufPtr],RSI
     MOV [RBX+FILE64.BufSize],RSI
     MOV [RBX+FILE64.Pos],RSI
     MOV [RBX+FILE64.Size],RSI
     LEA RAX,[CreateFileW]
     JSt [RBX+FILE64.Status],fi64StUnicode,.10:
     LEA RAX,[CreateFileA]
 .10:WinABI RAX,RDX,GENERIC_READ,FILE_SHARE_READ,RSI, \
            OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,RSI,Fastmode=No
     MOV [RBX+FILE64.Handle],RAX
     CMP RAX,RDI
     JE .EndWithLastError:
     SetSt [RBX+FILE64.Status],fi64StOpened
     WinABI GetFileSize,RAX,RSI,Fastmode=No
     CMP RAX,RDI
     JE .EndWithLastError:
     MOV [RBX+FILE64.Size],RAX
     MOV [RBX+FILE64.Top],RAX
     MOV [RBX+FILE64.BufSize],RAX
     WinABI GlobalAlloc,GMEM_FIXED,RAX,Fastmode=No
     MOV [RBX+FILE64.Ptr],RAX
     ADD [RBX+FILE64.Top],RAX
     MOV [RBX+FILE64.BufPtr],RAX
     TEST RAX
     JZ .EndWithLastError:
     SetSt [RBX+FILE64.Status],fi64StAllocated
     MOV [RSP+8],RAX      ; ReturnRSI.
     PUSH RCX
      MOV RCX,RSP
      WinABI ReadFile,[RBX+FILE64.Handle],RAX,[RBX+FILE64.Size],RCX,0,Fastmode=No
     POP RCX
     ADD [RBX+FILE64.Pos],RCX
     TEST RAX
     JZ .EndWithLastError:
     MOV RAX,[RBX+FILE64.Size]
     CMP RAX,RCX
     JE .EndWithRAX
     MOV EAX,0xE0070026
     JMP .ErrorEAX
 .EndWithLastError:
     WinABI GetLastError,Fastmode=No
 .ErrorEAX: STC
 .EndWithRAX:
     PUSH RAX
      PUSHFD
       JNSt [RBX+FILE64.Status],fi64StOpened,.90:
       WinABI CloseHandle,[RBX+FILE64.Handle],Fastmode=No
 .90:  RstSt [RBX+FILE64.Status],fi64StOpened
       MOV [RBX+FILE64.Handle],RDI
      POPFD
     POP RAX
    POP RDI,RSI,RBX,RDX,RCX
    RET 1*8
  ENDPROC1 FileLoad64@RT::
 %ENDMACRO FileLoad
</pre>

<dl id="FileStore"><dt><a href="#top">FileStore</a>  theFile, DataPtr, DataSize</dt>
<dd>Macro <dfn>FileStore</dfn> will open the file, write data and close the file.</dd>
<dt>Input</dt><dd><b>theFile</b> is pointer to an assigned unopened <a href="#FILE64">FILE64</a> object,
<br><b>DataPtr</b> is pointer to the data to be written,
<br><b>DataSize</b> is size of the data in bytes, i.e. the future file size.</dd>
<dt>Output</dt><dd><b>CF=</b>0
<br/><b>RAX=</b> is the data size of written data.</dd>
<dt>Error</dt><dd><b>CF=</b>1
<br/><b>RAX=</b> is error code returned by GetLastError.</dd>
<dt>Example</dt><dd class="PRE"> FileAssign File1,="C:\Temp\MyFile1.txt"
<!----> FileStore File1, MyDataPtr, MyDataEnd-MyDataPtr
<!---->File1 DS FILE64</dd></dl><pre>
FileStore %MACRO theFile,DataPtr,DataSize
      PUSHQ %DataSize,%DataPtr,%theFile
      CALL FileStore64@RT::
FileStore64@RT:: PROC1
    IMPORT CreateFileA,CreateFileW
    PUSH RCX,RDX,RBX,RSI,RDI
     MOV RBX,[RSP+48]           ; theFile.
     MOV RAX,[RSP+56]           ; DataPtr.
     MOV RCX,[RSP+64]           ; DataSize.
     MOV [RBX+FILE64.Ptr],RAX
     MOV [RBX+FILE64.Top],RAX
     MOV [RBX+FILE64.Size],RCX
     ADD [RBX+FILE64.Top],RCX
     SUB ESI,ESI
     MOV RDI,INVALID_HANDLE_VALUE
     MOV [RBX+FILE64.Pos],RSI
     LEA RDX,[RBX+FILE64.Name]
     LEA RAX,[CreateFileW]
     JSt [RBX+FILE64.Status],fi64StUnicode,.10:
     LEA RAX,[CreateFileA]
 .10:WinABI RAX,RDX,GENERIC_WRITE,FILE_SHARE_READ,RSI, \
            CREATE_ALWAYS,FILE_ATTRIBUTE_NORMAL,RSI,Fastmode=No
     MOV [RBX+FILE64.Handle],RAX
     CMP RAX,RDI
     JE .EndWithLastError:
     SetSt [RBX+FILE64.Status],fi64StCreated
     PUSH RCX
      MOV RCX,RSP
      WinABI WriteFile,RAX,[RBX+FILE64.Ptr],[RBX+FILE64.Size],RCX,RSI,Fastmode=No
     POP RCX
     ADD [RBX+FILE64.Pos],RCX
     TEST RAX
     JZ .EndWithLastError:
     MOV RAX,[RBX+FILE64.Size]
     CMP RAX,RCX
     JE .EndWithRAX
     MOV EAX,0xE0070000 + 39 ; "The disk is full."
     JMP .ErrorEAX
 .EndWithLastError:
     WinABI GetLastError,Fastmode=No
 .ErrorEAX: STC
 .EndWithRAX:
     PUSHFD
      JNSt [RBX+FILE64.Status],fi64StCreated,.90:
      WinABI CloseHandle,[RBX+FILE64.Handle],Fastmode=No
 .90: RstSt [RBX+FILE64.Status],fi64StCreated
      MOV [RBX+FILE64.Handle],RDI
     POPFD
    POP RDI,RSI,RBX,RDX,RCX
    RET 3*8
  ENDPROC1 FileStore64@RT::
 %ENDMACRO FileStore
</pre>

<dl id="FileOpen"><dt><a href="#top">FileOpen</a> theFile</dt>
<dd> opens the assigned file for reading.</dd>
<dt>Input</dt><dd><b>theFile</b> is pointer to a <a href="#FILE64">FILE64</a> object.</dd>
<dt>Output</dt><dd><b>CF=</b>0
<br/><b>RAX=</b> file size.</dd>
<dt>Error</dt><dd><b>CF=</b>1
<br/><b>RAX=</b> errorCode as returned from GetLastError.</dd></dl><pre>
FileOpen %MACRO theFile
         PUSHQ %theFile
         CALL FileOpen64@RT::
FileOpen64@RT:: PROC1
    IMPORT CreateFileA,CreateFileW
    PUSHQ RCX,RDX,RBX,RSI,RDI
     MOV RBX,[RSP+48]           ; theFile.
     LEA RDX,[RBX+FILE64.Name]
     SUB ESI,ESI
     MOV RDI,INVALID_HANDLE_VALUE
     MOV [RBX+FILE64.Size],RSI
     MOV [RBX+FILE64.Pos],RSI
     MOV [RBX+FILE64.Ptr],RSI
     MOV [RBX+FILE64.Top],RSI
     RstSt [RBX+FILE64.Status],fi64StStdIO
     LEA RAX,[CreateFileW]
     JSt [RBX+FILE64.Status],fi64StUnicode,.30:
     LEA RAX,[CreateFileA]
     CMPB [RDX],0
     JNE .40:
 .20:SetSt [RBX+FILE64.Status],fi64StStdIO
     WinABI GetStdHandle,STD_INPUT_HANDLE,Fastmode=No
     JMP .50:
 .30:CMPW [RDX],0
     JE .20:
 .40:WinABI RAX,RDX,GENERIC_READ,FILE_SHARE_READ,RSI, \
            OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,RSI,Fastmode=No
 .50:MOV [RBX+FILE64.Handle],RAX
     CMP RAX,RDI
     JE .EndWithLastError:
     SetSt [RBX+FILE64.Status],fi64StOpened + fi64StFound
     MOV RCX,RAX
     SUB EAX,EAX
     JSt [RBX+FILE64.Status],fi64StStdIO,.EndWithRAX:
     WinABI GetFileSize,RCX,RSI,Fastmode=No
     CMP RAX,RDI
     JE .EndWithLastError:
     MOV [RBX+FILE64.Size],RAX
     CLC
     JMP .EndWithRAX
 .EndWithLastError:
     WinABI GetLastError,Fastmode=No
     STC
 .EndWithRAX:
    POP RDI,RSI,RBX,RDX,RCX
    RET 1*8
  ENDPROC1 FileOpen64@RT::
 %ENDMACRO FileOpen
</pre>

<dl id="FileReset"><dt><a href="#top">FileReset</a> theFile, Position </dt>
<dd>Macro <dfn>FileReset</dfn> will reset internal file pointers to a new Position in the file.</dd>
<dt>Input</dt><dd><b>theFile</b> is pointer to a <a href="#FILE64">FILE64</a> object,
<!---->which must have been opened with FileOpen, FileMapOpen or FileStreamOpen.
<br/><b>Position</b> specifies the number of bytes from the beginning of theFile. Zero is used if omitted.</dd>
<dt>Output</dt><dd><b>CF</b>=0
<br/><b>RAX</b>=Position</dd>
<dt>Error</dt><dd><b>CF</b>=1
<br/><b>RAX</b>= error code if SetFilePointer failed.</dd></dl> <pre>
FileReset %MACRO theFile, Position
     %IF "%Position" === ""
       PUSHQ 0
     %ELSE
       PUSHQ %Position
     %ENDIF
     PUSHQ %theFile
     CALL FileReset64@RT::
FileReset64@RT:: PROC1
     PUSH RDX,RBX
      MOV RBX,[RSP+24]       ; theFile.
      MOV RDI,[RSP+32]       ; Position.
      MOV RAX,0xE0070004     ; Error: File is not opened.
      JNSt [RBX+FILE64.Status],fi64StOpened, .ErrorRAX:
      WinABI SetFilePointer,[RBX+FILE64.Handle],RDI,0,FILE_BEGIN,Fastmode=No
      INC EAX
      JZ .EndWithLastError:
      MOV [RBX+FILE64.Pos],EDI
      MOV RAX,[RBX+FILE64.BufPtr]
      MOV [RBX+FILE64.Ptr],RAX
      JSt [RBX+FILE64.Status],fi64StMapOpened,.80:
      MOV [RBX+FILE64.Top],RAX
      JMPS .90:
 .EndWithLastError:
      WinABI GetLastError,Fastmode=No
 .ErrorRAX: STC
      JMPS .90:
 .80: ADD [RBX+FILE64.Ptr],RDI
 .90:POP RBX,RDI
     RET 2*8
    ENDPROC1 FileReset64@RT::
 %ENDMACRO FileReset
</pre>

<dl id="FileRead"><dt><a href="#top">FileRead</a> theFile, DataPtr, DataSize</dt>
<dd> reads from an opened file to the memory provided by caller.</dd>
<dt>Input</dt><dd><b>theFile</b> is pointer to a <a href="#FILE64">FILE64</a> object opened for reading.
<br><b>DataPtr</b> is pointer where the data will be read,
<br><b>DataSize</b> is requested number of bytes.</dd>
<dt>Output</dt><dd><b>CF=</b>0
<br/><b>ZF=</b>0
<br/><b>RAX=</b> the actually read size (may be less than DataSize if the file is not large enough).</dd>
<dt>End of file</dt><dd><b>CF=</b>0
<br/><b>ZF=</b>1
<br/><b>RAX=</b>0 if all data have been read from the file (EOF).</dd>
<dt>Error</dt><dd><b>CF=</b>1
<br/><b>RAX=</b> errorCode as returned from GetLastError.</dd>
<dt>Example</dt><dd class="PRE"> FileRead InpFile,aLine,80
<!----> JC .ErrorReadingFile
<!----> JZ .EOF</dd></dl><pre>
FileRead %MACRO theFile,DataPtr,DataSize
       PUSHQ %DataSize,%DataPtr,%theFile
       CALL FileRead64@RT::
FileRead64@RT:: PROC1
    PUSH RCX,RBX,RSI
     MOV RBX,[RSP+32]           ; theFile.
     MOV RSI,[RSP+40]           ; DataPtr.
     MOV RCX,[RSP+48]           ; DataSize.
     MOV RAX,0xE0070004         ; File is not open.
     JNSt [RBX+FILE64.Status],fi64StOpened, .ErrorRAX:
     PUSH RAX
       MOV RAX,RSP
       WinABI ReadFile,[RBX+FILE64.Handle],RSI,RCX,RAX,0,Fastmode=No
       TEST EAX
     POP RAX
     JZ .EndWithLastError:
     ADD [RBX+FILE64.Pos],RAX
     TEST RAX
     JMP .EndWithRAX
.EndWithLastError:
     WinABI GetLastError,Fastmode=No
.ErrorRAX:
     STC
.EndWithRAX:
    POP RSI,RBX,RCX
    RET 3*8
  ENDPROC1 FileRead64@RT::
 %ENDMACRO FileRead
</pre>

<dl id="FileCreate"><dt><a href="#top">FileCreate</a> theFile</dt>
<dd>creates a new file or rewrites an existing file for writing.</dd>
<dt>Input</dt><dd><b>theFile</b> is pointer to a <a href="#FILE64">FILE64</a> object.</dd>
<dt>Output</dt><dd><b>CF=</b>0
<br/><b>RAX=</b>0 (size of just rewritten file).</dd>
<dt>Error</dt><dd><b>CF=</b>1
<br/><b>EAX=</b>errorCode as returned from GetLastError.</dd></dl><pre>
FileCreate %MACRO theFile
         PUSHQ %theFile
         CALL FileCreate64@RT::
FileCreate64@RT:: PROC1
    IMPORT CreateFileA,CreateFileW
    PUSH RCX,RDX,RBX,RSI,RDI
     MOV RBX,[RSP+48]                ; theFile.
     LEA RDX,[RBX+FILE64.Name]
     SUB ESI,ESI
     MOV RDI,INVALID_HANDLE_VALUE
     MOV [RBX+FILE64.Size],RSI
     MOV [RBX+FILE64.Pos],RSI
     MOV [RBX+FILE64.Ptr],RSI
     MOV [RBX+FILE64.Top],RSI
     RstSt [RBX+FILE64.Status],fi64StStdIO
     LEA RAX,[CreateFileW]
     JSt [RBX+FILE64.Status],fi64StUnicode,.30:
     LEA RAX,[CreateFileA]          ; ANSI version.
     CMPB [RDX],0
     JNE .40:
 .20:SetSt [RBX+FILE64.Status],fi64StStdIO
     WinABI GetStdHandle,STD_OUTPUT_HANDLE,Fastmode=No
     JMP .60:
 .30:CMPW [RDX],0                   ; WIDE version.
     JE .20:
 .40:MOV RCX,OPEN_ALWAYS
     JSt [RBX+FILE64.Status],fi64StAppend,.50:
     MOV RCX,CREATE_ALWAYS
     MOV RSI,FILE_ATTRIBUTE_NORMAL
 .50:WinABI RAX,RDX,GENERIC_WRITE,FILE_SHARE_READ,0,RCX,RSI,0,Fastmode=No
 .60:MOV [RBX+FILE64.Handle],RAX
     CMP RAX,RDI
     JE .EndWithLastError:
     SetSt [RBX+FILE64.Status],fi64StCreated
     MOV RCX,RAX
     SUB EAX,EAX
     JSt [RBX+FILE64.Status],fi64StStdIO, .EndWithRAX:
     SUB ESI,ESI
     WinABI GetFileSize,RCX,RSI,Fastmode=No
     CMP RAX,RDI
     JE .EndWithLastError:
     MOV [RBX+FILE64.Size],RAX
     JNSt [RBX+FILE64.Status],fi64StAppend,.EndWithRAX:
     MOV [RBX+FILE64.Pos],RAX
     WinABI SetFilePointer,[RBX+FILE64.Handle],RSI,RSI,FILE_END,Fastmode=No
     CMP RDI,RAX
     JA .EndWithRAX:
.EndWithLastError:
     WinABI GetLastError,Fastmode=No
     STC
.EndWithRAX:
    POP RDI,RSI,RBX,RDX,RCX
    RET 1*8
   ENDPROC1 FileCreate64@RT::
 %ENDMACRO FileCreate
</pre>

<dl id="FileAppend"><dt><a href="#top">FileAppend</a> theFile</dt>
<dd>Macro <dfn>FileAppend</dfn> creates a new file
<!---->or opens an existing file for writing and sets file pointer to its end.</dd>
<dt>Input</dt><dd><b>theFile</b> is pointer to a <a href="#FILE64">FILE64</a> object.</dd>
<dt>Output</dt><dd><b>CF=</b>0
<br/><b>RAX=</b> file size.</dd>
<dt>Error</dt><dd><b>CF=</b>1
<br/><b>RAX=</b>errorCode as returned from GetLastError.</dd>
<dt>Depends on</dt><dd><a href="#FileCreate">FileCreate</a></dd>
</dl><pre>
FileAppend %MACRO theFile
       PUSHQ %theFile
       CALL FileAppend64@RT::
 FileAppend64@RT:: PROC1
     PUSH RBX
       MOV RBX,[RSP+16]            ; theFile.
       SetSt [RBX+FILE64.Status],fi64StAppend
       FileCreate RBX
     POP RBX
     RET 1*8
   ENDPROC1 FileAppend64@RT::
 %ENDMACRO FileAppend
</pre>

<dl><dt id="FileWriteRT"><a href="#top">FileWriteRT</a></dt>
<dd>is a runtime defining macro used internally by FileWrite, FileWriteLn, FileWrite$.
<br/>Returns RAX=total written size.</dd></dl><pre>
FileWriteRT %MACRO ; Common runtime procedure declaration for macros FileWrite*
FileWrite64@RT: PROC1
     PUSHQ 0,RCX,RDX,RBX,RSI
      MOV RBX,[RSP+56]                  ; theFile.
      LEA RSI,[RSP+64]                  ; Address of 1st string ptr.
      MOV RAX,0xE0070004                ; File is not opened.
      JNSt [RBX+FILE64.Status],fi64StCreated, .ErrorRAX:
.Next:LODSQ                             ; DataPtr.
      MOV RDX,RAX
      TEST RAX
      JZ .Ret:                          ; End of data. CF=0, ZF=1.
      LODSQ                             ; DataSize.
      MOV RCX,RAX
      PUSH RAX
        MOV RAX,RSP
        WinABI WriteFile,[RBX+FILE64.Handle],RDX,RCX,RAX,0,Fastmode=No
        TEST RAX
      POP RAX                          ; Written size.
      JZ .GetLastError:
      ADD [RSP+32],RAX                 ; %ReturnRAX.
      ADD [RBX+FILE64.Pos],RAX
      ADD [RBX+FILE64.Size],RAX
      JMP .Next:
.GetLastError:
      WinABI GetLastError,Fastmode=No
.ErrorRAX:
      STC
      MOV [RSP+32],RAX
.Ret:POP RSI,RBX,RDX,RCX,RAX
     RET
FileWrite$size64@RT:
     PUSH RCX,RDI
      SUB ECX,ECX
      SUB EAX,EAX
      DEC RCX
      MOV RDI,[RSP+24]                ; DataPtr
      REPNE SCASB
      SUB RAX,RCX
      SUB RAX,2
      MOV [RSP+32],RAX                ; DataSize
     POP RDI,RCX
     RET
  ENDPROC1 FileWrite64@RT:
%ENDMACRO FileWriteRT
</pre>

<dl id="FileWrite"><dt><a href="#top">FileWrite</a>  theFile, DataPtr1, DataSize1, DataPtr2, DataSize2,,,</dt>
<dd>This macro writes data to the file
<!---->previously opened for writing with <a href="#FileCreate">FileCreate</a> or
<a href="#FileAppend">FileAppend</a>.
<br>Multiple data may be written in one macro invocation.</dd>
<dt>Input</dt><dd><b>theFile</b> is pointer to an open <a href="#FILE64">FILE64</a> object,
<br><b>DataPtr*</b> points to the data to be written,
<br><b>DataSize*</b> is the size of data in bytes.</dd>
<dt>Output</dt><dd><b>CF=</b>0
<br/><b> RAX=</b>total written size in bytes.</dd>
<dt>Error</dt><dd><b>CF=</b>1
<br/><b> RAX=</b>errorCode as returned from GetLastError.</dd>
<dt>Depends on</dt><dd><a href="#FileWriteRT">FileWriteRT</a></dd></dl><pre>
FileWrite %MACRO theFile,DataPtr,DataSize,,,,
    %IF %# & 1 = 0
      %ERROR ID=5944, 'Macro "FileWrite" expects odd number of arguments.'
      %EXITMACRO FileWrite
    %ENDIF
    PUSHQ 0 ; Mark the end of arguments.
    ArgNr %FOR %#..2,STEP=-2
      PUSHQ %*{%ArgNr}, %*{%ArgNr-1}
    %ENDFOR ArgNr
    PUSHQ %theFile
    PUSH RSP
     ADDQ [RSP],(%#+1)*8
     CALL FileWrite64@RT
    POP RSP
    FileWriteRT                        ; Invoke the common runtime macro.
 %ENDMACRO FileWrite
</pre>

<dl id="FileWriteLn"><dt><a href="#top">FileWriteLn</a> theFile, DataPtr1, DataSize1, DataPtr2, DataSize2,,,</dt>
<dd>Macro <dfn>FileWriteLn</dfn> writes data to the file
<!---->previously opened for writing with <a href="#FileCreate">FileCreate</a> or
<a href="#FileAppend">FileAppend</a>.
<br>Multiple data may be written in one macro invocation.
<!---->End of line CR+LF characters are written in the end.</dd>
<dt>Input</dt><dd><b>theFile</b> is pointer to an open <a href="#FILE64">FILE64</a> object,
<br><b>DataPtr*</b> points to the data to be written,
<br><b>DataSize*</b> is size of data in bytes.</dd>
<dt>Output</dt><dd><b>CF=</b>0
<br/><b>RAX=</b> is the total written size including CR+LF.</dd>
<dt>Error</dt><dd><b>CF=</b>1
<br/><b>RAX=</b> errorCode as returned from GetLastError.</dd>
<dt>Depends on</dt><dd><a href="#FileWriteRT">FileWriteRT</a></dd></dl><pre>
FileWriteLn %MACRO theFile,DataPtr,DataSize,,,
    %IF %# & 1 = 0
      %ERROR ID=5945, 'Macro "FileWriteLn" expects odd number of arguments.'
      %EXITMACRO FileWriteLn
    %ENDIF
    PUSHQ 0x00000A0D                  ; CR+LF.
    PUSHQ 0                           ; Mark the end of arguments.
    PUSHQ 2                           ; Size of CR+LF.
    PUSH RSP
    ADDQ [RSP],2*8                    ; Pointer to CR+LF.
    ArgNr %FOR %#..2, STEP=-2
      PUSHQ %*{%ArgNr}, %*{%ArgNr-1}
    %ENDFOR ArgNr
    PUSHQ %theFile
    PUSH RSP
     ADDQ [RSP],(%#+4)*8
     CALL FileWrite64@RT
    POP RSP
    FileWriteRT                       ; Invoke the common runtime macro.
 %ENDMACRO FileWriteLn
</pre>

<dl id="FileWritedo"><dt><a href="#top">FileWrite$</a> theFile, DataPtr$1, DataPtr$2,,,
</dt><dd>This macro writes zero terminated ANSI string(s) to the file
<!---->previously opened for writing with <a href="#FileCreate">FileCreate</a> or
<a href="#FileAppend">FileAppend</a>.
<br>Multiple strings may be written in one macro invocation.
<!---->The terminating zeros are not written to the file.</dd>
<dt>Input</dt><dd><b>theFile</b> is pointer to an open <a href="#FILE64">FILE64</a> object,
<br><b>DataPtr$*</b> are pointers to zero terminated strings to be written.</dd>
<dt>Output</dt><dd><b>CF=</b>0
<br/><b>RAX=</b> total written size in bytes.</dd>
<dt>Error</dt><dd><b>CF=</b>1
<br/><b>RAX=</b> errorCode as returned from GetLastError.</dd>
<dt>Depends on</dt><dd><a href="#FileWriteRT">FileWriteRT</a></dd></dl><pre>
FileWrite$ %MACRO theFile,DataPtr1,DataPtr2,DataPtr3,,,
    PUSHQ 0 ; Mark the end of arguments
    ArgNr %FOR %#..2,STEP=-1
      PUSHQ RAX,%*{%ArgNr}
      CALL FileWrite$size64@RT
    %ENDFOR ArgNr
    PUSHQ %theFile
    PUSH RSP
     ADDQ [RSP],2 * %# * 8
     CALL FileWrite64@RT
    POP RSP
    FileWriteRT         ; Invoke the common runtime macro.
  %ENDMACRO FileWrite$
</pre>

<dl id="FileEncloseRT"><dt>FileEncloseRT</dt><dd>is a runtime defining macro
<!---->used internally by FileEnclose, FileEncloseLn, FileEnclose$.</dd>
<dt>Depends on</dt><dd><a href="#FileCreate">FileCreate</a>,
<a href="#FileClose">FileClose</a></dd>
</dl><pre>
FileEncloseRT %MACRO ; Common RT procedure declaration for macros FileEnclose*
FileEnclose64@RT:: PROC1
     PUSHQ 0,RCX,RDX,RBX,RSI,RDI
      MOV RBX,[RSP+64]         ; theFile.
      SetSt [RBX+FILE64.Status],fi64StAppend
      FileCreate RBX
      JC .ErrorRAX:
      LEA RSI,[RSP+72]         ; Pointer to the 1st string pointer.
 .10: LODSQ                    ; DataPtr.
      MOV RDX,RAX
      TEST RAX
      JZ .90:                  ; End of data.
      LODSQ                    ; DataSize.
      MOV RCX,RAX
      PUSH RDI                 ; Make room for written size.
        MOV RDI,RSP
        WinABI WriteFile,[RBX+FILE64.Handle],RDX,RCX,RDI,0,Fastmode=No
      POP RDI                  ; Written size.
      ADD [RSP+40],RDI         ; %ReturnEAX.
      ADD [RBX+FILE64.Pos],RDI
      ADD [RBX+FILE64.Size],RDI
      TEST RAX                 ; WriteFile result.
      JNZ .10:                 ; If OK, write the next Data.
      WinABI GetLastError,Fastmode=No
 .ErrorRAX:
      STC
      MOV [RSP+28],RAX         ; %ReturnEAX.
 .90: PUSHFQ
        FileClose RBX
      POPFQ
     POP RDI,RSI,RBX,RDX,RCX,RAX
     RET
 FileEnclose$size64@RT::       ; Subprocedure for zero-terminated strings.
     PUSH RAX,RCX,RDI
      SUB ECX,ECX
      SUB EAX,EAX
      DEC RCX
      MOV RDI,[RSP+32]         ; DataPtr.
      REPNE SCASB
      SUB RAX,RCX
      SUB RAX,2
      MOV [RSP+40],RAX         ; DataSize.
     POP RDI,RCX,RAX
     RET
  ENDPROC1 FileEnclose64@RT::
%ENDMACRO FileEncloseRT
</pre>

<dl id="FileEnclose"><dt><a href="#top">FileEnclose</a> theFile, DataPtr1, DataSize1, DataPtr2, DataSize2,,,
</dt><dd> This macro writes data at the end
<!---->of existing file or creates a new one and then closes the file.
<br>Multiple data can be appended with one invocation.
<br>The file should be assigned but not open.</dd>
<dt>Input</dt><dd><b>theFile</b> is pointer to <a href="#FILE64">FILE64</a> object with assigned name,
<br><b>DataPtr*</b> is pointer to the data to be written,
<br><b>DataSize*</b> is size of the data in bytes.</dd>
<dt>Output</dt><dd><b>CF=</b>0
<br/><b> RAX=</b> it total written size in bytes.</dd>
<dt>Error</dt><dd><b>CF=</b>1
<br/><b>RAX=</b> errorCode as returned from GetLastError.</dd>
<dt>Depends on</dt><dd><a href="#FileEncloseRT">FileEncloseRT</a></dd>
<dt>Example</dt><dd class="PRE">FileEnclose LogFile,Datum,SIZE#Datum</dd></dl><pre>
FileEnclose %MACRO theFile,DataPtr,DataSize,,,,
    %IF %# & 1 = 0
      %ERROR ID=5942, 'Macro "FileEnclose" expects odd number of arguments.'
      %EXITMACRO FileEnclose
    %ENDIF
    PUSHQ 0 ; Mark the end of arguments.
    ArgNr %FOR %#..2,STEP=-2
      PUSHQ %*{%ArgNr}, %*{%ArgNr-1}
    %ENDFOR ArgNr
    PUSHQ %theFile
    PUSH RSP
    ADDQ [RSP],(%#+1)*8
    CALL FileEnclose64@RT
    POP RSP
    FileEncloseRT              ; Invoke the common runtime macro.
 %ENDMACRO FileEnclose
</pre>

<dl id="FileEncloseLn"><dt><a href="#top">FileEncloseLn</a> theFile, DataPtr1, DataSize1, DataPtr2, DataSize2,,,
</dt><dd> This macro writes data at the end of existing file or creates a new one
<!---->and then closes the file.
<br>Multiple data can be appended with one invocation.
<br>When all data have been written, it appends end-of-line characters CR+LF to the file.
<br>The file should be assigned but not open.</dd>
<dt>Input</dt><dd><b>theFile</b> is pointer to <a href="#FILE64">FILE64</a> object with assigned name,
<br><b>DataPtr*</b> is pointer to the data to be written,
<br><b>DataSize*</b> is size of the data in bytes.</dd>
<dt>Output</dt><dd><b>CF=</b>0
<br/><b> RAX=</b> it total written size in bytes, including CR+LF.</dd>
<dt>Error</dt><dd><b>CF=</b>1
<br/><b>RAX=</b> errorCode as returned from GetLastError.</dd>
<dt>Depends on</dt><dd><a href="#FileEncloseRT">FileEncloseRT</a></dd></dl><pre>
FileEncloseLn %MACRO theFile,DataPtr,DataSize,DataPtr2,DataSize2,,,
    %IF %# & 1 = 0
      %ERROR ID=5943, 'Macro "FileEncloseLn" expects odd number of arguments.'
      %EXITMACRO FileEncloseLn
    %ENDIF
    PUSHQ 0x00000A0D        ; CR+LF
    PUSHQ 0                 ; Mark the end of arguments.
    PUSHQ 2                 ; Size of CR+LF.
    PUSH RSP
    ADDQ [RSP],2*8          ; Pointer to CR+LF.
    ArgNr %FOR %#..2,STEP=-2
      PUSHQ %*{%ArgNr}, %*{%ArgNr-1}
    %ENDFOR ArgNr
    PUSHQ %theFile
    PUSH RSP
     ADDQ [RSP],8*(%#+4)
     CALL FileEnclose64@RT
    POP RSP
    FileEncloseRT           ; Invoke the common runtime macro.
 %ENDMACRO FileEncloseLn
</pre>

<dl id="FileEnclosedo"><dt><a href="#top">FileEnclose$</a> theFile, DataPtr$1, DataPtr$2,,,
</dt><dd> This macro writes one or more zero-terminated data strings at the end of
<!---->existing file or it creates a new one, and then closes the file.
<br>The file should be assigned but not open.
<br>Multiple strings can be appended with one invocation. The terminating NULL is not written.
</dd>
<dt>Input</dt><dd><b>theFile</b> is pointer to <a href="#FILE64">FILE64</a> object with assigned name,
<br><b>DataPtr$*</b> are pointers to zero-terminated ANSI strings.
<!---->Terminating zeroes are not written to the file.</dd>
<dt>Output</dt><dd><b>CF=</b>0
<br/><b>RAX=</b> total written size.</dd>
<dt>Error</dt><dd><b>CF=</b>1
<br/><b>RAX=</b> is errorCode as returned by GetLastError.</dd>
<dt>Depends on</dt><dd><a href="#FileEncloseRT">FileEncloseRT</a></dd>
<dt>Example</dt><dd class="PRE"> FileEnclose$ LogFile, Time$, =B" Job started"
</dd></dl> <pre>
FileEnclose$ %MACRO theFile,DataPtr1,DataPtr2,DataPtr3,,,
    PUSHQ 0 ; Mark the end of arguments.
    ArgNr %FOR %#..2,STEP=-1
      PUSHQ RAX,%*{%ArgNr}
      CALL FileEnclose$size64@RT ; Get length of string and write it to the stack.
    %ENDFOR ArgNr
    PUSHQ %theFile
    PUSH RSP
     ADDQ [RSP],2 * %# * 8
     CALL FileEnclose64@RT
    POP RSP
    FileEncloseRT                ; Invoke the common runtime macro.
  %ENDMACRO FileEnclose$
</pre>

<dl id="FileMapOpen"><dt><a href="#top">FileMapOpen</a> theFile</dt>
<dd>opens an existing file for reading and creates file mapping to memory.
<br>Content of the file will be available for reading and pointed to with RSI.
<br>The file must not be assigned with device or empty name.</dd>
<dt>Input</dt><dd><b>theFile</b> is pointer to a <a href="#FILE64">FILE64</a> object.</dd>
<dt>Output</dt><dd><b>CF=</b>0
<br/><b>RAX=</b> file size,
<br/><b>RSI=</b> pointer to the memory mapped file contents.</dd>
<dt>Error</dt><dd><b>CF=</b>1
<br/><b>RSI=</b>0
<br/><b>RAX=</b> errorCode as returned from GetLastError.</dd></dl><pre>
FileMapOpen %MACRO theFile
       PUSHQ %theFile
       CALL FileMapOpen64@RT::
FileMapOpen64@RT:: PROC1
    IMPORT CreateFileA,CreateFileW,CreateFileMappingA,CreateFileMappingW
    PUSH RAX,RCX,RDX,RBX,RSI,RDI
     MOV RBX,[RSP+56]            ; theFile.
     LEA RDX,[RBX+FILE64.Name]
     SUB ESI,ESI
     MOV RDI,INVALID_HANDLE_VALUE
     MOV [RBX+FILE64.Ptr],RSI
     MOV [RBX+FILE64.Top],RSI
     MOV [RBX+FILE64.BufPtr],RSI
     MOV [RBX+FILE64.BufSize],RSI
     MOV [RBX+FILE64.Size],RSI
     MOV [RBX+FILE64.Pos],RSI
     MOV [RBX+FILE64.Handle],RDI
     MOV [RSP+08],RSI            ; ReturnRSI.
     LEA RAX,[CreateFileW]
     JSt [RBX+FILE64.Status],fi64StUnicode,.30:
     LEA RAX,[CreateFileA]       ; ANSI variant.
     CMPB [RDX],0
     JNE .40:
.20: MOV RAX,0xC0070000+123      ; "The file name is incorrect."
     JMP .ErrorRAX:
.30: CMPW [RDX],0                ; WIDE variant.
     JE .20:
.40: WinABI RAX,RDX,GENERIC_READ,FILE_SHARE_READ,RSI, \
           OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,RSI,Fastmode=No
     MOV [RBX+FILE64.Handle],RAX
     CMP RAX,RDI
     JE .EndWithLastError:
     SetSt [RBX+FILE64.Status],fi64StOpened + fi64StFound
     WinABI GetFileSize,RAX,RSI,Fastmode=No
     CMP RAX,RDI
     JE .EndWithLastError:
     MOV [RBX+FILE64.Size],RAX
     MOV [RBX+FILE64.BufSize],RAX
     MOV [RBX+FILE64.Top],RAX
     MOV [RSP+40],RAX             ; ReturnRAX.
     LEA RAX,[CreateFileMappingW]
     JSt [RBX+FILE64.Status],fi64StUnicode,.50:
     LEA RAX,[CreateFileMappingA]
.50: WinABI RAX,[RBX+FILE64.Handle],RSI,PAGE_READONLY,RSI,RSI,RSI,Fastmode=No
     MOV [RBX+FILE64.MapHandle],RAX
     TEST RAX
     JZ .EndWithLastError:
     SetSt [RBX+FILE64.Status],fi64StMapOpened
     WinABI MapViewOfFile,RAX,FILE_MAP_READ,RSI,RSI,RSI
     MOV [RBX+FILE64.Ptr],RAX
     MOV [RSP+08],RAX            ; ReturnRSI.
     ADD [RBX+FILE64.Top],RAX
     MOV [RBX+FILE64.BufPtr],RAX
     TEST RAX
     JZ .EndWithLastError:
     SetSt [RBX+FILE64.Status],fi64StMapped
     JMP .Ret:
.EndWithLastError:
     WinABI GetLastError,Fastmode=No
.ErrorRAX:
     STC
     MOV [RSP+40],EAX           ; ReturnRAX.
.Ret:POP RDI,RSI,RBX,RDX,RCX,RAX
    RET 1*8
  ENDPROC1 FileMapOpen64@RT::
%ENDMACRO FileMapOpen
</pre>

<dl id="FileMapCreate"><dt><a href="#top">FileMapCreate</a> theFile, FileSize</dt>
<dd>Macro <dfn>FileMapCreate</dfn> will create or rewrite an existing file for writing
<!---->and create file mapping. Size of the file being created must be
<!---->specified with FileSize.
<br>File content may be copied to the mapped memory returned in RDI
<!---->but not more than FileSize bytes.
<br>The file must not be assigned with device or empty name.</dd>
<dt>Input</dt><dd><b>theFile</b> is pointer to a <a href="#FILE64">FILE64</a> object.
<br><b>FileSize</b> is the size of memory mapped file. It may be omitted
<!---->when FileMapCreate opens an existing file.</dd>
<dt>Output</dt><dd><b>CF=</b>0
<br/><b>RAX=</b>FileSize
<br/><b>RDI=</b> is pointer to the memory mapped file content.</dd>
<dt>Error</dt><dd><b>CF=</b>1
<br/><b>RDI=</b>0
<br/><b>RAX=</b> errorCode as returned from GetLastError.</dd></dl><pre>
FileMapCreate %MACRO theFile,FileSize
       %IF %# > 1
         PUSHQ %FileSize
       %ELSE
         PUSHQ 0
       %ENDIF
       PUSHQ %theFile
       CALL FileMapCreate64@RT::
FileMapCreate64@RT:: PROC1
     IMPORT CreateFileA,CreateFileW,CreateFileMappingA,CreateFileMappingW
     PUSH RCX,RDX,RBX,RSI,0
      MOV RBX,[RSP+48]               ; theFile.
      LEA RDX,[RBX+FILE64.Name]
      SUB ESI,ESI
      MOV RDI,INVALID_HANDLE_VALUE
      RstSt [RBX+FILE64.Status],fi64StAppend
      MOV [RBX+FILE64.Ptr],RSI
      MOV [RBX+FILE64.Top],RSI
      MOV [RBX+FILE64.BufPtr],RSI
      MOV [RBX+FILE64.BufSize],RSI
      MOV [RBX+FILE64.Size],RSI
      MOV [RBX+FILE64.Pos],RSI
      MOV [RBX+FILE64.Handle],RDI
      LEA RAX,[CreateFileW]
      JSt [RBX+FILE64.Status],fi64StUnicode,.30:
      LEA RAX,[CreateFileA]
      CMPB [RDX],0
      JNE .40:
 .20: MOV RAX,0xC0070000+123 ; "Error: The file name is incorrect."
      JMP .ErrorRAX:
 .30: CMPW [RDX],0
      JE .20:
 .40: WinABI RAX,RDX,GENERIC_WRITE|GENERIC_READ,FILE_SHARE_READ|FILE_SHARE_WRITE, \
             RSI,OPEN_ALWAYS,FILE_ATTRIBUTE_NORMAL,RSI,Fastmode=No
      MOV [RBX+FILE64.Handle],RAX
      CMP RAX,RDI
      JE .EndWithLastError:
      SetSt [RBX+FILE64.Status],fi64StCreated
      MOV RCX,[RSP+56]        ; FileSize.
      TEST RCX
      JNZ .45:
      WinABI GetFileSize,[RBX+FILE64.Handle],RCX,Fastmode=No
      MOV RCX,RAX
      INC RAX
      JZ .EndWithLastError:
 .45: MOV [RBX+FILE64.Size],RCX
      MOV [RBX+FILE64.BufSize],RCX
      MOV [RBX+FILE64.Top],RCX
      LEA RAX,[CreateFileMappingW]
      JSt [RBX+FILE64.Status],fi64StUnicode,.50:
      LEA RAX,[CreateFileMappingA]
 .50: WinABI RAX,[RBX+FILE64.Handle],RSI,PAGE_READWRITE,RSI,RCX,RSI,Fastmode=No
      MOV [RBX+FILE64.MapHandle],RAX
      TEST RAX
      JZ .EndWithLastError:
      SetSt [RBX+FILE64.Status],fi64StMapCreated
      WinABI MapViewOfFile,RAX,FILE_MAP_WRITE,RSI,RSI,RSI,Fastmode=No
      MOV [RBX+FILE64.Ptr],RAX
      ADD [RBX+FILE64.Top],RAX
      MOV [RBX+FILE64.BufPtr],RAX
      MOV [RSP+00],RAX          ; ReturnRDI.
      TEST RAX
      JZ .EndWithLastError:
      SetSt [RBX+FILE64.Status],fi64StMapped
      MOV RAX,RCX
      JMP .Ret:
.EndWithLastError:
      WinABI GetLastError,Fastmode=No
.ErrorRAX:
      STC
.Ret:POP RDI,RSI,RBX,RDX,RCX
     RET 2*8
   ENDPROC1 FileMapCreate64@RT::
 %ENDMACRO FileMapCreate
</pre>

<dl id="FileStreamOpen"><dt><a href="#top">FileStreamOpen</a> theFile, BufSize=16K</dt>
<dd>This macro opens an existing file for reading and allocates
<!---->memory buffer from OS heap. Buffer will be read from file
<!---->on the FileStreamRead*  request.</dd>
<dt>Input</dt><dd><b>theFile</b> is pointer to a <a href="#FILE64">FILE64</a> object.
<br><b>BuffSize=</b> specifies the buffer size.</dd>
<dt>Output</dt><dd><b>CF=</b>0
<br/><b>RAX=</b> file size.</dd>
<dt>Error</dt><dd><b>CF=</b>1
<br/><b>RAX=</b> errorCode as returned from GetLastError.</dd>
<dt>Depends on</dt><dd><a href="#FileOpen">FileOpen</a></dd></dl><pre>
FileStreamOpen %MACRO theFile,BufSize=16K
       PUSH %BufSize,%theFile
       CALL FileStreamOpen64@RT::
FileStreamOpen64@RT:: PROC1
     PUSH RCX,RBX
      MOV RBX,[RSP+3*8]       ; theFile.
      MOV RCX,[RSP+4*8]       ; BufSize.
      MOV [RBX+FILE64.BufSize],RCX
      WinABI GlobalAlloc,GMEM_FIXED,RCX,Fastmode=No
      TEST RAX
      JZ .EndWithLastError:
      MOV [RBX+FILE64.BufPtr],RAX
      PUSH RDI
       MOV RDI,RAX
       SetSt [RBX+FILE64.Status],fi64StAllocated
       FileOpen RBX
       MOV [RBX+FILE64.Ptr],RDI
       MOV [RBX+FILE64.Top],RDI
      POP RDI
      JNC .EndWithRAX
.EndWithLastError:
      WinABI GetLastError,Fastmode=No
      STC
.EndWithRAX:
     POP RBX,RCX
     RET 2*8
  ENDPROC1 FileStreamOpen64@RT::
 %ENDMACRO FileStreamOpen
</pre>

<dl id="FileStreamRead"><dt><a href="#top">FileStreamRead</a>  theFile, DataPtr, DataSize</dt>
<dd>reads data from the file opened with
<a href="#FileStreamOpen">FileStreamOpen</a>.</dd>
<dt>Input</dt><dd><b>theFile</b> is pointer to a <a href="#FILE64">FILE64</a> object.
<br><b>DataPtr</b> points to a memory area allocated by the caller,
<br><b>DataSize</b> is amount of bytes to read.</dd>
<dt>Output</dt><dd><b>CF=</b>0
<br/><b>ZF=</b>0
<br/><b>RAX=</b> how many bytes was read (may be less the DataSize).</dd>
<dt>End of file</dt><dd><b>CF=</b>0
<br/><b>ZF=</b>1
<br><b>RAX=</b> 0  when there are no more bytes in the file (EOF).</dd>
<dt>error</dt><dd><b>CF=</b>1
<br/><b>RAX=</b> errorCode as returned from GetLastError.</dd></dl><pre>
FileStreamRead %MACRO theFile,DataPtr,DataSize
       PUSHQ %DataSize,%DataPtr,%theFile
       CALL FileStreamRead64@RT::
FileStreamRead64@RT:: PROC1
      PUSH RCX,RDX,RBX,RSI,RDI
        SUB EDX,EDX
        MOV RBX,[RSP+48]          ; theFile.
        MOV RDI,[RSP+56]          ; DataPtr.
 .10:   MOV RSI,[RBX+FILE64.Ptr]
 .20:   MOV RCX,[RBX+FILE64.Top]
        SUB RCX,RSI
        JNA .50:
        CMP RCX,[RSP+64]          ; DataSize.
        JA .30:
        SUB [RSP+64],RCX          ; DataSize.
        ADD RDX,RCX
        REP MOVSB
        MOV [RBX+FILE64.Ptr],RSI
        JMP .20:
 .30:   MOV RCX,[RSP+64]          ; DataSize.
        ADD RDX,RCX
        REP MOVSB
        MOV [RBX+FILE64.Ptr],RSI
        JMP .70:
 .50:   MOV RSI,[RBX+FILE64.BufPtr]
        MOV [RBX+FILE64.Ptr],RSI
        MOV [RBX+FILE64.Top],RSI
        PUSH RCX
          MOV RCX,RSP
          WinABI ReadFile,[RBX+FILE64.Handle],RSI,[RBX+FILE64.BufSize],RCX,0,Fastmode=No
        POP RCX
        TEST RAX
        JZ .EndWithLastError:
        JRCXZ .70:                ; EOF
        ADD [RBX+FILE64.Top],RCX
        JMP .20:
 .70:   MOV RAX,RDX
        ADD [RBX+FILE64.Pos],RDX
        TEST RAX
        JMP .EndWithRAX           ; ZF if RAX=0.
.EndWithLastError:
        WinABI GetLastError,Fastmode=No
.ErrorRAX:
        STC
.EndWithRAX:
.90: POP RDI,RSI,RBX,RDX,RCX
      RET 3*8
  ENDPROC1 FileStreamRead64@RT::
 %ENDMACRO FileStreamRead
</pre>

<dl id="FileStreamReadLn"><dt><a href="#top">FileStreamReadLn</a> theFile</dt>
<dd>reads one physical line from the file opened with
<a href="#FileStreamOpen">FileStreamOpen</a>.
<br>Line is always terminated with LF character (except for the last line in the file).
<br>Size of any line in file should not exceed the size of buffer allocated with
<a href="#FileStreamOpen">FileStreamOpen</a>. Longer lines will be
<!-->read <em>per partes</em>.</dd>
<dt>Input</dt><dd><b>theFile</b> is pointer to a <a href="#FILE64">FILE64</a> object.</dd>
<dt>Output</dt><dd><b>CF=</b>0
<br/><b>ZF</b>=0
<br/><b>RAX</b>= line size (never bigger than the FILE64.BufSize)
<br/><b>RSI</b>= pointer to the line in buffer.</dd>
<dt>End of file</dt><dd><b>CF</b>=0
<br/><b>ZF</b>=1
<br/><b>RAX</b>=0  when there are no more data in file (EOF).</dd>
<dt>error</dt><dd><b>CF</b>=1
<br/><b>RAX=</b> errorCode as returned from GetLastError.</dd></dl><pre>
FileStreamReadLn %MACRO theFile
      PUSHQ %theFile
      CALL FileStreamReadLn64@RT::
FileStreamReadLn64@RT:: PROC1
    PUSH 0,RCX,RDX,RBX,RSI,RDI
      MOV RBX,[RSP+56]          ; theFile.
      MOV RAX,0xE0070004        ; File is not open.
      JNSt [RBX+FILE64.Status],fi64StOpened,.ErrorRAX:
      JNSt [RBX+FILE64.Status],fi64StAllocated,.ErrorRAX:
      MOV RDI,[RBX+FILE64.Ptr]
      MOV RCX,[RBX+FILE64.Top]
.10:  MOV [RSP+08],RDI         ; ReturnRSI.
      MOV RDX,RDI
      SUB RCX,RDI
      JNA .30:
      MOV AL,10 ; LineFeed
      REPNE SCASB
      JE .50:
      CMP RDX,[RBX+FILE64.BufPtr]
      JE .50:
      ; When the end of line is out of buffer and start of line is not
      ; at buffer's beginning, the buffer will be reloaded with the current line.
      SUB RDX,RDI
      WinABI SetFilePointer,[RBX+FILE64.Handle],RDX,0,FILE_CURRENT,Fastmode=No
.30:  MOV RDI,[RBX+FILE64.BufPtr]
      MOV [RBX+FILE64.Ptr],RDI
      MOV [RBX+FILE64.Top],RDI
      PUSH RCX
       MOV RCX,RSP
       WinABI ReadFile,[RBX+FILE64.Handle],RDI,[RBX+FILE64.BufSize],RCX,0,Fastmode=No
      POP RCX
      TEST RAX
      JZ .EndWithLastError:
      JRCXZ .70:                  ; EOF
      ADD RCX,RDI
      MOV [RBX+FILE64.Top],RCX
      JMP .10:
.50:  MOV [RBX+FILE64.Ptr],RDI
      SUB RDI,RDX
      MOV [RSP+40],RDI            ; ReturnRAX.
      ADD [RBX+FILE64.Pos],RDI
      JMP .90:
.70:  SUB EAX,EAX
      JMP .EndWithRAX:
.EndWithLastError:
      WinABI GetLastError,Fastmode=No
.ErrorRAX:
      STC
.EndWithRAX:
      MOV [RSP+40],RAX            ; ReturnRAX.
.90:POP RDI,RSI,RBX,RDX,RCX,RAX
    RET 1*8
 ENDPROC1 FileStreamReadLn64@RT::
%ENDMACRO FileStreamReadLn
</pre>

<dl id="FileStreamReadByte"><dt><a href="#top">FileStreamReadByte</a> theFile</dt>
<dd>reads one byte from the file opened with
<a href="#FileStreamOpen">FileStreamOpen</a>.</dd>
<dt>Input</dt><dd><b>theFile</b> is pointer to a <a href="#FILE64">FILE64</a> object.</dd>
<dt>Output</dt><dd><b>CF=</b>0
<br/><b>ZF=</b>0
<br/><b>AL=</b> the byte read from file. Upper 7 bytes in RAX are preserved.</dd>
<dt>End of file</dt><dd><b>CF=</b>0
<br/><b>ZF=</b>1
<br/><b>AL=</b>0  when there are no more bytes in the file (EOF).</dd>
<dt>Error</dt><dd><b>CF=</b>1
<br/><b>RAX=</b> errorCode as returned from GetLastError.</dd>
</dl><pre>
FileStreamReadByte %MACRO theFile
     PUSHQ %theFile
     CALL FileStreamReadByte64@RT::
FileStreamReadByte64@RT:: PROC1
     PUSH RAX,RCX,RBX,RSI,RDI
      MOV RBX,[RSP+48]
 .10: MOV RSI,[RBX+FILE64.Ptr]
      CMP RSI,[RBX+FILE64.Top]
      JB .50:                      ; Buffer is not empty.
      MOV RAX,0xE0070004           ; File is not open.
      JNSt [RBX+FILE64.Status],fi64StOpened,.ErrorRAX:
      JNSt [RBX+FILE64.Status],fi64StAllocated,.ErrorRAX:
      MOV RDI,[RBX+FILE64.BufPtr]
      MOV [RBX+FILE64.Ptr],EDI
      MOV [RBX+FILE64.Top],EDI
      PUSH RCX
       MOV RCX,RSP
       WinABI ReadFile,[RBX+FILE64.Handle],RDI,[RBX+FILE64.BufSize],RCX,0,Fastmode=No
      POP RCX
      TEST RAX
      JZ .EndWithLastError:
      ADD [RBX+FILE64.Top],RCX
      TEST RCX
      JNZ .10
      MOV RAX,[RSP+32]      ; ReturnRAX.
      XOR AL,AL             ; Set ZF=1.
      JMP .EndWithRAX:
.EndWithLastError:
      WinABI GetLastError,Fastmode=No
.ErrorRAX:
      STC
      JMP .EndWithRAX:
 .50: MOV RAX,[RSP+32]      ; ReturnRAX.
      LODSB
      MOV [RBX+FILE64.Ptr],RSI
      INCQ [RBX+FILE64.Pos]
      CLC
.EndWithRAX:
      MOV [RSP+32],RAX
     POP RDI,RSI,RBX,RCX,RAX
     RET 1*8
  ENDPROC1 FileStreamReadByte64@RT::
 %ENDMACRO FileStreamReadByte
</pre>

<dl id="FileStreamCreate"><dt><a href="#top">FileStreamCreate</a>  theFile, BufSize=16K</dt>
<dd>This macro creates a new file or rewrites an existing file for writing
<!---->and allocates memory buffer from OS heap. The buffer will be automatically written to file
<!---->every time it is completely filled with FileStreamWrite*.</dd>
<dt>Input</dt><dd><b>theFile</b> is pointer to a <a href="#FILE64">FILE64</a> object,
<br><b>BuffSize=</b> specifies the buffer size.</dd>
<dt>Output</dt><dd><b>CF=</b>0
<br/><b>RAX=</b>0 (size of just rewritten file).</dd>
<dt>Error</dt><dd><b>CF=</b>1
<br/><b>RAX=</b> errorCode as returned from GetLastError.</dd>
<dt>Depends on</dt><dd><a href="#FileCreate">FileCreate</a></dd>
</dl><pre>
FileStreamCreate %MACRO theFile,BufSize=16K
       PUSHQ %BufSize,%theFile
       CALL FileStreamCreate64@RT::
FileStreamCreate64@RT:: PROC1
    PUSH RCX,RBX,RSI,RDI
     MOV RBX,[RSP+40]          ; theFile.
     MOV RCX,[RSP+48]          ; BufSize.
     MOV [RBX+FILE64.BufSize],RCX
     MOV RDI,RCX
     WinABI GlobalAlloc,GMEM_FIXED,RCX,Fastmode=No
     TEST RAX
     JZ .EndWithLastError:
     SetSt [RBX+FILE64.Status],fi64StAllocated
     MOV [RBX+FILE64.BufPtr],RAX
     ADD RDI,RAX
     MOV RSI,RAX
     FileCreate RBX
     MOV [RBX+FILE64.Ptr],RSI
     MOV [RBX+FILE64.Top],RDI
     JNC .EndWithRAX
.EndWithLastError:
     WinABI GetLastError,Fastmode=No
     STC
.EndWithRAX:
    POP RDI,RSI,RBX,RCX
    RET 2*8
  ENDPROC1 FileStreamCreate64@RT::
%ENDMACRO FileStreamCreate
</pre>

<dl id="FileStreamAppend"><dt><a href="#top">FileStreamAppend</a>  theFile, BufSize=16K</dt>
<dd>This macro creates a new file or rewrites an existing file for writing
<!---->at its end and allocates memory buffer from heap. Buffer will be written to file
<!---->every time it is completely filled with FileStreamWrite*.</dd>
<dt>Input</dt><dd><b>theFile</b> is pointer to a <a href="#FILE64">FILE64</a> object,
<br><b>BuffSize=</b> specifies the buffer size.</dd>
<dt>Output</dt><dd><b>CF=</b>0
<br/><b>RAX=</b> is the old file size.</dd>
<dt>Error</dt><dd><b>CF=</b>1
<br/><b>RAX=</b> errorCode as returned from GetLastError.</dd>
<dt>Depends on</dt><dd><a href="#FileStreamCreate">FileStreamCreate</a></dd>
</dl><pre>
FileStreamAppend %MACRO theFile,BufSize=16K
       PUSHQ %BufSize,%theFile
       CALL FileStreamAppend64@RT::
FileStreamAppend64@RT:: PROC1
     PUSH RBX,RCX
       MOV RBX,[RSP+24] ; theFile.
       MOV RCX,[RSP+32] ; BufSize.
       SetSt [RBX+FILE64.Status],fi64StAppend
       FileStreamCreate RBX,RCX
     POP RCX,RBX
     RET 2*8
   ENDPROC1 FileStreamAppend64@RT::
 %ENDMACRO FileStreamAppend
</pre>

<dl id="FileStreamWriteByte"><dt><a href="#top">FileStreamWriteByte</a> theFile</dt>
<dd>This macro writes one byte from AL to the file opened with
<a href="#FileStreamCreate">FileStreamCreate</a> or
<a href="#FileStreamAppend">FileStreamAppend</a>.</dd>
<dt>Input</dt><dd><b>theFile</b> is pointer to a <a href="#FILE64">FILE64</a> object,
<br><b>AL</b> contains the data byte to write.</dd>
<dt>Output</dt><dd><b>CF=</b>0, registers unchanged.</dd>
<dt>Error</dt><dd><b>CF=</b>1
<br/><b>EAX=</b> errorCode as returned from GetLastError.</dd>
<dt>Depends on</dt><dd><a href="#FileFlush">FileFlush</a></dd></dl><pre>
FileStreamWriteByte %MACRO theFile
      PUSHQ %theFile
      CALL FileStreamWriteByte64@RT::
FileStreamWriteByte64@RT:: PROC1
    PUSH RAX,RCX,RDX,RBX,RDI
     MOV RBX,[RSP+48]          ; theFile.
.10: MOV RDI,[RBX+FILE64.Ptr]
     CMP RDI,[RBX+FILE64.Top]
     JB .50:
     FileFlush RBX             ; If buffer is full.
     JNC .10:
     MOV [RSP+32],RAX          ; ReturnRAX.
     JMP .90:
.50: STOSB
     MOV RAX,[RBX+FILE64.Pos]
     MOV [RBX+FILE64.Ptr],RDI
     ADD RAX,1
     MOV [RBX+FILE64.Pos],RAX
     MOV [RBX+FILE64.Size],RAX
     CLC
.90:POP RDI,RBX,RDX,RCX,RAX
    RET 1*8
 ENDPROC1 FileStreamWriteByte64@RT::
%ENDMACRO FileStreamWriteByte
</pre>

<dl id="FileStreamWriteWord"><dt><a href="#top">FileStreamWriteWord</a> theFile</dt>
<dd>This macro writes one word from AX to the file opened with
<a href="#FileStreamCreate">FileStreamCreate</a> or
<a href="#FileStreamAppend">FileStreamAppend</a>.</dd>
<dt>Input</dt><dd><b>theFile</b> is pointer to a <a href="#FILE64">FILE64</a> object,
<br><b>AX</b> contains the data word to write.</dd>
<dt>Output</dt><dd><b>CF=</b>0, registers unchanged.</dd>
<dt>Error</dt><dd><b>CF=</b>1
<br/><b>RAX=</b> errorCode as returned from GetLastError.</dd>
<dt>Depends on</dt><dd><a href="#FileFlush">FileFlush</a></dd></dl><pre>
FileStreamWriteWord %MACRO theFile
      PUSHQ %theFile
      CALL FileStreamWriteWord64@RT::
FileStreamWriteWord64@RT:: PROC1
    PUSH RAX,RCX,RDX,RBX,RDI
     MOV RBX,[RSP+48]          ; theFile.
.10: MOV RDI,[RBX+FILE64.Ptr]
     LEA RDX,[RDI+1]
     CMP RDX,[RBX+FILE64.Top]
     JB .50
     FileFlush RBX             ; If buffer full.
     JNC .10:
     MOV [RSP+32],RAX          ; ReturnRAX.
     JMP .90:
.50: STOSW
     MOV RAX,[RBX+FILE64.Pos]
     MOV [RBX+FILE64.Ptr],RDI
     ADD RAX,2
     MOV [RBX+FILE64.Pos],RAX
     MOV [RBX+FILE64.Size],RAX
     CLC
.90:POP RDI,RBX,RDX,RCX,RAX
    RET 1*8
 ENDPROC1 FileStreamWriteWord64@RT::
%ENDMACRO FileStreamWriteWord
</pre>

<dl id="FileStreamWriteDword"><dt><a href="#top">FileStreamWriteDword</a> theFile</dt>
<dd>This macro writes one doubleword from EAX to the file opened with
<a href="#FileStreamCreate">FileStreamCreate</a> or
<a href="#FileStreamAppend">FileStreamAppend</a>.</dd>
<dt>Input</dt><dd><b>theFile</b> is pointer to a <a href="#FILE64">FILE64</a> object,
<br><b>EAX</b> contains the data word to write.</dd>
<dt>Output</dt><dd><b>CF=</b>0, registers unchanged.</dd>
<dt>Error</dt><dd><b>CF=</b>1
<br/><b>RAX=</b> errorCode as returned from GetLastError.</dd>
<dt>Depends on</dt><dd><a href="#FileFlush">FileFlush</a></dd></dl><pre>
FileStreamWriteDword %MACRO theFile
      PUSHQ %theFile
      CALL FileStreamWriteDword64@RT::
FileStreamWriteDword64@RT:: PROC1
    PUSH RAX,RCX,RDX,RBX,RDI
     MOV RBX,[RSP+48]           ; theFile.
.10: MOV RDI,[RBX+FILE64.Ptr]
     LEA RDX,[RDI+3]
     CMP RDX,[RBX+FILE64.Top]
     JB .50
     FileFlush RBX              ; If buffer full.
     JNC .10:
     MOV [RSP+32],RAX           ; ReturnRAX.
     JMP .90:
.50: STOSD
     MOV RAX,[RBX+FILE64.Pos]
     MOV [RBX+FILE64.Ptr],RDI
     ADD RAX,4
     MOV [RBX+FILE64.Pos],RAX
     MOV [RBX+FILE64.Size],RAX
     CLC
.90:POP RDI,RBX,RDX,RCX,RAX
    RET 1*8
 ENDPROC1 FileStreamWriteDword64@RT::
%ENDMACRO FileStreamWriteDword
</pre>

<dl id="FileStreamWriteRT"><dt><a href="#top">FileStreamWriteRT</a></dt>
<dd> is a runtime defining macro used internally by FileStreamWrite*.
<br/>Macro returns CF=0, RAX=total written size, or CF=error</dd>
<dt>Depends on</dt><dd><a href="#FileFlush">FileFlush</a></dd>
</dl><pre>
FileStreamWriteRT %MACRO ; Common runtime procedure for macros FileStreamWrite*
FileStreamWrite64@RT: PROC1
    PUSHQ 0,RCX,RDX,RBX,RBP,RSI,RDI
     MOV RBX,[RSP+72]             ; theFile.
     LEA RSI,[RSP+80]             ; Pointer to Data1Ptr.
     MOV RAX,0xE0070004           ; File was not opened.
     JNSt [RBX+FILE64.Status],fi64StCreated,.ErrorRAX:
     JNSt [RBX+FILE64.Status],fi64StAllocated,.ErrorRAX:
     SUB EAX,EAX
     MOV [RSP+48],EAX             ; ReturnRAX
.Next:LODSQ                        ; DataPtr.
     MOV RBP,RAX
     TEST RAX
     JZ .Ret:                     ; End of data.
     LODSQ                        ; DataSize.
     MOV RDX,RAX
     ADD [RSP+48],RAX             ; ReturnRAX
     CALL .FileStreamStoreData:
     JNC .Next:
.ErrorRAX:
     STC
     MOV [RSP+48],RAX             ; ReturnRAX
.Ret:POP RDI,RSI,RBP,RBX,RDX,RCX,RAX
    RET
.FileStreamStoreData: ; Copy data to FileStream buffer
; INP: RBX=^FILE64, RBP=DataPtr, RDX=DataSize.
; OUT: CF=error, RAX=error, EBX,ESI preserved, FILE64 updated.
    PUSH RSI
     MOV RSI,RBP
.S1: TEST RDX
     JZ .S9
.S2: MOV RCX,[RBX+FILE64.Top]
     MOV RDI,[RBX+FILE64.Ptr]
     SUB RCX,RDI
     JNZ .S3
     FileFlush RBX
     JNC .S2:
     JMP .S9:
.S3: CMP RCX,RDX
     JBE .S4:
     MOV RCX,RDX
.S4: SUB RDX,RCX
     ADD [RBX+FILE64.Ptr],RCX
     ADD [RBX+FILE64.Pos],RCX
     ADD [RBX+FILE64.Size],RCX
     REP MOVSB
     JMP .S1:
.S9:POP RSI
    RET
FileStreamWrite$size64@RT::
    PUSH RAX,RCX,RDI
     SUB ECX,ECX
     SUB EAX,EAX
     DEC RCX
     MOV RDI,[RSP+32] ; DataPtr
     REPNE SCASB
     SUB RAX,RCX
     SUB RAX,2
     MOV [RSP+40],RAX ; DataSize
    POP RDI,RCX,RAX
    RET
 ENDPROC1 FileStreamWrite64@RT:
%ENDMACRO FileStreamWriteRT
</pre>

<dl id="FileStreamWrite"><dt><a href="#top">FileStreamWrite</a> theFile, DataPtr1, DataSize1, DataPtr2, DataSize2,,,</dt>
<dd>This macro writes data to the file previously opened with
<a href="#FileStreamCreate">FileStreamCreate</a> or
<a href="#FileStreamAppend">FileStreamAppend</a>.
<br>Multiple data portions may be written in one macro invocation.</dd>
<dt>Input</dt><dd><b>theFile</b> is pointer to an open <a href="#FILE64">FILE64</a> object,
<br><b>DataPtr*</b> is pointer to the data to be written,
<br><b>DataSize*</b> is the size of the data in bytes to be written.
<!---->It may be bigger than the buffer size specified at opening the file.</dd>
<dt>Output</dt><dd><b>CF=</b>0
<br/><b>RAX=</b> Total written size in bytes.</dd>
<dt>Error</dt><dd><b>CF=</b>1
<br/><b>RAX=</b> errorCode as returned from GetLastError.</dd>
<dt>Depends on</dt><dd><a href="#FileStreamWriteRT">FileStreamWriteRT</a></dl><pre>
FileStreamWrite %MACRO theFile,DataPtr,DataSize,DataPtr2,DataSize2,,,
    %IF %# & 1 = 0
      %ERROR ID=5946, 'Macro "FileStreamWrite" expects odd number of arguments.'
      %EXITMACRO FileStreamWrite
    %ENDIF
    PUSHQ 0 ; Mark the end of arguments.
    ArgNr %FOR %#..2,STEP=-2
      PUSHQ %*{%ArgNr}, %*{%ArgNr-1}
    %ENDFOR ArgNr
    PUSHQ %theFile
    PUSH RSP
     ADDQ [RSP],(%#+1)*8
     CALL FileStreamWrite64@RT
    POP RSP
    FileStreamWriteRT             ; Invoke the common runtime macro.
 %ENDMACRO FileStreamWrite
</pre>

<dl id="FileStreamWriteLn"><dt><a href="#top">FileStreamWriteLn</a> theFile, DataPtr1, DataSize1, DataPtr2, DataSize2,,,</dt>
<dd>This macro writes data to the file previously opened with
<a href="#FileStreamCreate">FileStreamCreate</a> or
<a href="#FileStreamAppend">FileStreamAppend</a>.
<br>Multiple data portions may be written in one macro invocation.
<!---->End of line CR+LF characters are written in the end.</dd>
<dt>Input</dt><dd><b>theFile</b> is pointer to an open <a href="#FILE64">FILE64</a> object,
<br><b>DataPtr*</b> is pointer to the data to be written,
<br><b>DataSize*</b> is the size of the data to be written, including the CR+LF.
<!---->It may be bigger than the buffer size specified on opening the file.</dd>
<dt>Output</dt><dd><b>CF=</b>0
<br/><b>RAX=</b> total written size including CR+LF.</dd>
<dt>Error</dt><dd><b>CF=</b>1
<br/><b>RAX=</b> errorCode as returned from GetLastError.</dd>
<dt>Depends on</dt><dd><a href="#FileStreamWriteRT">FileStreamWriteRT</a></dl><pre>
FileStreamWriteLn %MACRO theFile,DataPtr,DataSize,DataPtr2,DataSize2,,,
    %IF %# & 1 = 0
      %ERROR ID=5947, 'Macro "FileStreamWriteLn" expects odd number of arguments.'
      %EXITMACRO FileStreamWriteLn
    %ENDIF
    PUSHQ 0x00000A0D               ; CR+LF.
    PUSHQ 0                        ; Mark the end of arguments.
    PUSHQ 2                        ; Size of CR+LF.
    PUSH  RSP
    ADDD [RSP],2*8                 ; Pointer to CR+LF.
    ArgNr %FOR %#..2,STEP=-2
      PUSHQ %*{%ArgNr}, %*{%ArgNr-1}
    %ENDFOR ArgNr
    PUSHQ %theFile
    PUSH RSP
     ADDQ [RSP],(%#+4)*8
     CALL FileStreamWrite64@RT
    POP RSP
    FileStreamWriteRT
 %ENDMACRO FileStreamWriteLn       ; Invoke the common runtime macro.
</pre>

<dl id="FileStreamWritedo"><dt><a href="#top">FileStreamWrite$</a> theFile, DataPtr$1, DataPtr$2,,,</dt>
<dd>This macro writes zero terminated ANSI string(s) to the file previously opened with
<a href="#FileStreamCreate">FileStreamCreate</a> or
<a href="#FileStreamAppend">FileStreamAppend</a>.
<br/>Multiple ASCIIZ strings may be written in one macro invocation.
<!---->The terminating zeros are not written to the file.</dd>
<dt>Input</dt><dd><b>theFile</b> is pointer to an open <a href="#FILE64">FILE64</a> object,
<br><b>DataPtr$*</b> are pointers to the zero terminated strings to be written.</dd>
<dt>Output</dt><dd><b>CF=</b>0
<br/><b>RAX=</b> total written size.</dd>
<dt>Error</dt><dd><b>CF=</b>1
<br/><b>RAX=</b> errorCode as returned from GetLastError.</dd>
<dt>Depends on</dt><dd><a href="#FileStreamWriteRT">FileStreamWriteRT</a></dl><pre>
FileStreamWrite$ %MACRO theFile,DataPtr1,DataPtr2,DataPtr3,,,
    PUSHQ 0 ; mark end of arguments
    ArgNr %FOR %#..2,STEP=-1
      PUSHQ RAX,%*{%ArgNr}
      CALL FileStreamWrite$size64@RT::
    %ENDFOR ArgNr
    PUSHQ %theFile
    PUSH RSP
     ADDQ [RSP],2 * %# * 8
     CALL FileStreamWrite64@RT
    POP RSP
    FileStreamWriteRT             ; Invoke the common runtime macro.
  %ENDMACRO FileStreamWrite$
</pre>

<pre>
  ENDHEAD winf64
</pre>
<!--TAILMENU-->
<!--Contents below the marker {!==TAILMENU==} was generated by "generate.php".-->
<br class='CLEAR'/><a id='bottom' href='#top'>&#x25B2;Back to the top&#x25B2;</a>
</body></html>
