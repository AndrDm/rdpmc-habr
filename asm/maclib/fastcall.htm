<!doctype html><html lang='en'><head>
<meta http-equiv='Content-Type' content='text/html; charset=utf-8'/>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=2.0, user-scalable=yes'>
<meta name='robots' content='ALL,FOLLOW'/>
<meta name='description' content='fastcall.htm macro library'/>
<meta name='version' content='20250318'/>
<meta name='author' content='Pavel vitsoft Šrubař'/>
<link rel='stylesheet' href='../euroasm.css' type='text/css'/>
<link rel='shortcut icon' href='../favicon.ico'/>
<title>fastcall.htm macro library</title>
</head>
<body class='MACLIB' id='top'><div class='HEADMENU'><table>
<tr><td rowspan='2' title='&euro;ASM - assembler and linker'><img src='../favicon.ico' alt='EuroAssembler' />
<td><a href='../index.htm' title='Alphabetical index of all &euro;ASM elements, directives and instructions'>Index</a></td>
<td><a href='../eadoc/' class='EADOC' title='Documentation of EuroAssembler'>Manual</a></td>
<td><a href='https://euroassembler.eu/download/' title='History &amp; download of the latest and previous versions'>Download</a></td>
<td><a href='../easource/' class='EASOURCE' title='Source files of EuroAssembler itself'>Source</a></td>
<td><a href='../maclib/' class='MACLIB' title='Macro libraries shipped with &euro;ASM'>Macros</a></td>
<td rowspan='2' title='Find the searched token in any text file on this site'>
<form method='post' action='../search.php' enctype='multipart/form-data' accept-charset='utf-8'>
<input type='text' id='q' placeholder='Searched word(s)' name='q' value=''/>
<br/><label title='Check the box to find the expression even if it is surrounded by other letters | digits.'>
<input type='checkbox' name='EW'/><small>Embedded word</small></label>
<br/><label title='Check the box for case-insensitive search.'>
<input type='checkbox' name='CI'/><small>Case ins.</small></label>
<input type='submit' title='Search for the specified word|expression in all site files.' name='find' value='Search'/>
</form></td></tr><tr>
<td><a href='../sitemap.htm' title='List of directories and files on this site'>Sitemap</a></td>
<td><a href='../eadoc/links.htm' class='EADOC' title='References and external links to resources used in EuroAssembler developement'>Links</a></td>
<td><a href='https://euroassembler.eu/forum/' title='Discussion forum concerning EuroAssembler'>Forum</a></td>
<td><a href='../eatests/' class='EATESTS' title='Program snippets for testing the function of &euro;ASM'>Tests</a></td>
<td><a href='../objlib/' class='OBJLIB' title='Skeletons and sample objects and projects shipped with &euro;ASM'>Projects</a></td>
</tr></table></div>
<!--Contents above the marker {!==/HEADMENU==} was generated by "generate.php".-->
<!--/HEADMENU-->
<h1>fastcall.htm
<br/><i>Enumeration</i>
<br/><a href="#pcFastCall">%FastCall</a>
<br/><i>Macros</i>
<br/><a href="#ClearLocalVar">ClearLocalVar</a>
<br/><a href="#EndProcedure">EndProcedure</a>
<br/><a href="#Invoke">Invoke</a>
<br/><a href="#LocalVar">LocalVar</a>
<br/><a href="#Procedure">Procedure</a>
<br/><a href="#SaveToShadow">SaveToShadow</a>
<br/><a href="#Uses">Uses</a>
</h1>
<p>This file can be included to <strong>64bit Windows programs</strong> written in EuroAssembler.
<!---->The library contains macroinstructions <code>Procedure, EndProcedure, Invoke
</code> which extend generic (pseudo)instructions <code>PROC, ENDPROC, CALL</code>.</p>
<p>Macroinstructions <code>Procedure</code> and <code>EndProcedure</code> implement the prologue and epilogue of
<dfn>Microsoft x64 calling convention</dfn> <a class="EXTL" href="../eadoc/links.htm#MSx64Conv">[MSx64conv]
</a>, where the arguments are pushed backwards and they are removed by the caller.
<br/>The first 4 arguments are provided in registers RCX, RDX, R8, R9 (or in XMM0, XMM1, XMM2, XMM3
<!---->when they are floating-point numbers).</p>
<p>The block of code defined between macros <a href="#Procedure">Procedure</a>&nbsp;..&nbsp;<a href="#EndProcedure">EndProcedure
</a> can be called by macro <a href="#Invoke">Invoke</a> or as a callback procedure from Windows library function,
<!---->for instance see <a class="EXT" href="../prowin64/skelet64.htm#WndProc">WndProc</a> in sample projects. </p>
<p>Macro <a href="#Invoke">Invoke</a> can be also used to call functions from third-party static or dynamically
<!---->linked libraries. Nevertheless, for invocation of Windows functions it's better to use specialized macros
<a class="EXT" href="winabi.htm#WinABI">WinABI</a> (64bit) or <a class="EXT" href="winapi.htm#WinAPI">WinAPI</a> (32bit).</p>
<p>Implementation of FastCall convention in &euro;ASM
<!---->allows to use formal %names for accessing Procedure parameters and local stack-memory variables.</p>
<p>Number of arguments provided in macro <a href="#Invoke">Invoke</a> must exactly match the number of arguments
<!---->declared in macro <a href="#Procedure">Procedure</a> or in the documentation of invoked function. </p>
<p>Macro <a class="#Invoke">Invoke</a> takes care of <strong>stack alignment</strong> to OWORD just before execution of instruction
<code>CALL MyProc</code> (<code>step 5.</code> in the following example). RSP at the Invoke entry might already have been OWORD aligned,
<!---->or it may be only QWORD aligned (=unaligned).
<!---->That is why RSP will be pushed once or twice in the prologue. Instructions of <code>step 2.</code> (<code>PUSH RSP
</code> and <code>ADD [RSP],8</code>) are emitted always but they will be skipped at run-time
<ol><li>when the number of arguments is odd (5, 7, 9, 11,,) and RSP is OWORD aligned,</li>
<li>or when the number of arguments is even (&lt;=4, 6, 8, 10,,) and RSP is unaligned.</li>
</ol><p> Thanks to this, RSP is always OWORD aligned before <code>step 5.</code> (<code>CALL MyProc</code>) is executed,
<!---->and the stack is restored to equilibrium (OrigRSP) after Invoke, no matter if it was OWORD aligned or not.</p>
<p>If macro <a href="#SaveToShadow">SaveToShadow</a> is used in Procedure block, it copies first four parameters
<!---->from registers into shadow space.
<!---->Thanks to this, those parameters are available not only in RCX,RDX,R8,R9,
<!---->but as stack variables %Arg1,%Arg2,%Arg3,%Arg4 alias their formal operand %names, too.</p>
<p>This implementation is compatible with <a class="EXTL" href="../eadoc/links.htm#MSx64Conv">[MSx64conv]
</a> convention and it allows to Invoke 64bit external or imported functions available in 3rd party libraries or in Windows ABI.
<!---->It also allows to create FastCall functions invokable from other libraries or as system callback procedures.</p>
<blockquote>If procedures of your 64bit program are private, i.e. they're called from this program only
<!---->(and not as callback from OS functions or statically linked to other programs),
<!---->you may find more effective to use homonymous macros which implement
<a class="EXT" href="stdcal64.htm">StdCall</a> convention or to invent your own register-calling convention
<!---->and use native <code>PROC, ENDPROC</code> pseudoinstructions instead of this more complicated FastCall library.</blockquote>
<dl id="FastCallFrame"><dt>Example</dt><dd>Definition of procedure MyProc with five parameters
<!---->and two local stack variables with sizes 8 and 16:</dd>
<dd class="PRE"><!---->MyProc Procedure Par1,Par2,Par3,Par4,Par5
<!---->       ; Parameters Par1,Par2,Par3,Par4 are loaded in RCX,RDX,R8,R9. Par5 is pushed on stack.
<!---->       SaveToShadow     ; Now are the parameter values available by formal names [%Par1],[%Par2],[%Par],[%Par4],[%Par5]
<!---->                        ;  and also by generic names [%Arg1],[%Arg2],[%Arg],[%Arg4],[%Arg5] (see <a href="#pcFastCall">%FastCall</a> assignment).
<!---->       Uses RDI         ; Exploit this macro only when some callee-save registers will be actually used in MyProc body.
<!----> LocV1 LocalVar         ; Reserve local stack variable with default size 8.
<!----> LocV2 LocalVar Size=16 ; Reserve another variable.
<!---->       ClearLocalVar    ; This fills all local stack variables with 0.
<!---->          ; Procedure parameters and local variables are available by formal name prefixed with <kbd>%</kbd>, e.g.
<!---->          MOV RAX,[%Par1]
<!---->          MOV [%LocV1],RAX
<!---->          ; Programmer should emit instructions of the <b>MyProc body</b> here
<!---->          ;   and load the result of MyProc into return-register (RAX or XMM0).
<!---->    EndProcedure MyProc ; This macro discards local variables, pops used callee-save registers,
<!---->                        ;    pops RBP and returns below Invoke statement at run-time.
</dd>
<dd><p>The following diagram shows the stack frame created by invoking MyProc defined in the example above.
<blockquote>Macros of fastcall convention will create and update the following &quot;global&quot; %variables at asm-time:
<br/><code>%ArgC_MyProc   %SETA 5</code> (number of arguments),
<br/><code>%Uses_MyProc   %SET RDI</code> (list of used callee-saved registers),
<br/><code>%LvSize_MyProc %SETA 8+16</code> (total size of local stack-variables),
<br/><code>%LocV1 %SET RBP-16</code> (1st local stack variable),
<br/><code>%LocV2 %SET RBP-32</code> (2nd local stack variable),
<br/><code>%Par1  %SET RBP+16</code> (1st parameter pushed on stack), valid only if SaveToShadow was used,
<br/><code>%Par2  %SET RBP+24</code> (2nd parameter pushed on stack), valid only if SaveToShadow was used,
<br/><code>%Par3  %SET RBP+32</code> (3rd parameter pushed on stack), valid only if SaveToShadow was used,
<br/><code>%Par4  %SET RBP+40</code> (4th parameter pushed on stack), valid only if SaveToShadow was used,
<br/><code>%Par5  %SET RBP+48</code> (5th parameter pushed on stack).
</blockquote></dd>
<dd class="PRE"><!---->                        <abbr> RSP after the step #.
<!---->                                &#x2502;
<!---->                                &#x2502;  Stack </abbr>
<!---->         &#x250C;                    0.&gt;&#x250C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2510;&lt;16.                        &#x2510;
<!---->         &#x2502;1.PUSH RSP             &#x2502;origRSP&#x2502;  16.POP RSP                &#x2502;
<!---->         &#x2502;                    1.&gt;&#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;                            &#x2502;
<!---->         &#x2502;2.PUSH RSP;ADD [RSP],8 &#x2502;origRSP&#x2502;                            &#x2502;
<!---->         &#x2502;                    2.&gt;&#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;&lt;15.                        &#x2502;
<!---->         &#x2502;3.PUSH Arg5            &#x2502; Arg5  &#x2502;  15.LEA RSP,[RSP+5*8]      &#x2502;
<!---->         &#x2502;                 &#x250C;  3.&gt;&#x251C;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2524;                            &#x251C; Invoke
<!---->Invoke   &#x2524;                 &#x2502;     &#x2502; undef &#x2502;                            &#x2502; epilogue
<!---->prologue &#x2502;                 &#x2502;     &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;                            &#x2502;
<!---->         &#x2502;                 &#x2502;     &#x2502; undef &#x2502;                            &#x2502;
<!---->         &#x2502;   shadow space &#x2500;&#x2524;     &#x251C;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2524;                            &#x2502;
<!---->         &#x2502;                 &#x2502;     &#x2502; undef &#x2502;                            &#x2502;
<!---->         &#x2502;                 &#x2502;     &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;                            &#x2502;
<!---->         &#x2502;4.SUB RSP,4*8    &#x2502;     &#x2502; undef &#x2502;                            &#x2518;
<!---->         &#x2502;   oword-aligned&gt;&#x2514;  4.&gt;&#x251C;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2524;&lt;14.                        &#x2510;
<!---->         &#x2502;5.CALL MyProc          &#x2502;return &#x2502;  14.RET                    &#x2502;
<!---->         &#x2514;                    5.&gt;&#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;&lt;13.                        &#x2502;
<!---->Procedure&#x2524;6.PUSH RBP;MOV RBP,RSP &#x2502;origRBP&#x2502;  13.POP RBP                &#x2502;
<!---->                              6.&gt;&#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;&lt;12.                        &#x2502;
<!---->Uses     &#x2524;7.PUSH RDI             &#x2502;origRDI&#x2502;  12.POP RDI                &#x2502;
<!---->         &#x250C;                    7.&gt;&#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;&lt;11.                        &#x251C;EndProcedure
<!---->         &#x2502;8.SUB RSP,8            &#x2502; LocV1 &#x2502;  11.ADD RSP,8+16           &#x2502;
<!---->         &#x2502;                    8.&gt;&#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;                            &#x2502;
<!---->LocalVar &#x2524;                       &#x2502;       &#x2502;                            &#x2502;
<!---->         &#x2502;                       &#x2502; LocV2 &#x2502;                            &#x2502;
<!---->         &#x2502;9.SUB RSP,16           &#x2502;       &#x2502;                            &#x2502;
<!---->         &#x2514;                    9.&gt;&#x2514;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2518;&lt;10.                        &#x2518;
<!---->
<!---->                              10. MyProc body
</dd></dl>
<br class="CLEAR"/><pre>
fastcall HEAD
</pre>
<dl id="pcFastCall"><dt><a href="#top">&uarr; %FastCall</a></dt>
<dd>Argument values pushed on stack during <a href="#Invoke">Invoke</a> and during <a href="#SaveToShadow">SaveToShadow
</a> are available inside the Procedure body as formal names or as <strong>generic names</strong> defined here:</dd>
</dl><pre>
%Arg8    %SET RBP+72
%Arg7    %SET RBP+64
%Arg6    %SET RBP+56
%Arg5    %SET RBP+48
%Arg4    %SET RBP+40
%Arg3    %SET RBP+32
%Arg2    %SET RBP+24
%Arg1    %SET RBP+16
</pre>

<dl id="Procedure"><dt><a href="#top">&uarr; Procedure</a> Operand1, Operand2,,,</dt>
<dd><p>This macro <dfn>Procedure</dfn> declares 64bit FastCall procedure prolog which,
<!---->unlike ordinary pseudoinstruction PROC, accepts ordinal operands
<!---->and expect them to be pushed on stack or loaded to registers.
<br/>Using of the macro Procedure requires the corresponding <a href="#EndProcedure">EndProcedure
</a> be used in the same program.</p>
<p>Macro operands will be assigned to preprocessing %variables
<!---->using the operand formal name prefixed with a percent sign
<kbd>%</kbd>. Arguments are available in Procedure block as formal names declared here in Procedure prototype (
<code>%Operand*</code>) or as generic names (<code>%Arg*</code>).
<br/>Pay attention that this is true for 5th and higher argument only. The first four arguments
<!---->are passed in registers, so if we want to access them by formal or generic name,
<!---->they have to be saved to shadow space in the beginning of our procedure, either by
<a href="#SaveToShadow">SaveToShadow</a>, or manually with</p></dd>
<dd class="PRE">  MOVQ [%Arg1],RCX ; or MOVQ [%Arg1],XMM0 (when the argument is floating-point number).
<!---->  MOVQ [%Arg2],RDX ; or MOVQ [%Arg2],XMM1 (when the argument is floating-point number).
<!---->  MOVQ [%Arg3],R8  ; or MOVQ [%Arg3],XMM2 (when the argument is floating-point number).
<!---->  MOVQ [%Arg4],R9  ; or MOVQ [%Arg4],XMM3 (when the argument is floating-point number).</dd>
<dt>Input</dt><dd>Label of <b>Procedure</b> statement is mandatory,
<!----> it gives the procedure a callable name.
<br/><b>Operand*</b> is the list of formal names for arguments passed to the procedure; their number is not limited.
</dd>
<dt>Output</dt><dd>Macroinstruction will define public symbol with procedure name and assign formal operand names
<!---->to the corresponding %variables.
<br/>It does not push registers (except for RBP). Programmer is responsible for saving and restoring
<!---->callee-save registers RBX, RSI, RDI, R12..R15, XMM6..XMM15 if they are used in procedure body.
<!---->This can be done either manually, or with macro <a href="#Uses">Uses</a>.
<br/>RBP must not be changed while the procedure body uses preprocessing %variables referring
<!---->the formal operands names, or if it declares and uses temporary stack local variables defined with
<a href="#LocalVar">LocalVar</a>.</dd>
<dt>Example</dt><dd class="PRE">
<!---->Move Procedure Source,Destination,Size  ; Declaration of procedure Move and its formal arguments.
<!---->      PUSH RSI,RDI                      ; Those registers must be unchanged by fastcall procedure.
<!---->       MOV [%Source],RCX                ; Saving register-passed arguments to shadow-space by formal name.
<!---->       MOV [%Arg2],RDX                  ; Ditto, saving by <a href="#pcFastCall">generic name</a>.
<!---->       MOV [%Arg3],R8                   ; Ditto, saving by <a href="#pcFastCall">generic name</a>.
<!---->       MOV RSI,[%Source]
<!---->       MOV RDI,[%Destination]
<!---->       MOV RCX,[%Size]
<!---->       REP MOVSB
<!---->      POP RDI,RSI                       ; Restore calee-save registers.
<!---->     EndProcedure Move                  ; Return from the procedure Move.
<!---->
<!---->;; With the knowledge of FastCall convention it may be also written more efficiently:
<!---->Move Procedure Source,Destination,Size  ; Declaration of procedure Move and its formal arguments.
<!---->      Uses RSI,RDI                      ; Those registers must be unchanged by fastcall Procedure.
<!---->      MOV RSI,RCX                       ; Source.
<!---->      MOV RDI,RDX                       ; Destination.
<!---->      MOV RCX,R8                        ; Size.
<!---->      REP MOVSB                         ; Perform the actual copy.
<!---->     EndProcedure Move                  ; Restore used registers RDI,RSI, return from the procedure Move.
<!---->
<!---->Macro <code>Move Procedure</code> in the previous example will assign
<!---->%ArgC_Move   %SET 3      ; This %variable propagates to the corresponding macro <code>EndProcedure Move</code>.
<!---->%Uses_Move   %SET        ; This %variable propagates to the macro Uses and EndProcedure.
<!---->%LvSize_Move %SETA 0     ; This %variable propagates to the macro LocalVar and EndProcedure.
<!---->%Source      %SET RBP+16 ; This %variable represents formal name of Arg1.
<!---->%Destination %SET RBP+24 ; This %variable represents formal name of Arg2.
<!---->%Size        %SET RBP+32 ; This %variable represents formal name of Arg3.
<!---->
<!---->Macro <code>Uses</code> in the previous example will assign
<!---->%Uses_Move   %SET RDI,RSI      ; This %variable propagates to the corresponding macro <code>EndProcedure Move</code>.
<!---->
<!---->   Invoke Move, RSI, OutBuffer, SIZE# OutBuffer  ; Example of procedure invocation.
</dd></dl><pre>
Procedure %MACRO FormalName1, FormalName2,,,,
LblCheck    %IF "%:" === ""
              %ERROR ID=5921, 'Macro "Procedure" requires a label.'
              %EXITMACRO Procedure
            %ENDIF LblCheck
%%ArgC_%:   %SETX %#                   ; Initialize with number of arguments.
%%Uses_%:   %SETX                      ; Initialize as empty list.
%%LvSize_%: %SETX 0                    ; Initialize as zero.
ArgNr       %FOR 1..%#, STEP= +1
%%%*{%ArgNr}  %SETX RBP+(8+%ArgNr*8)   ; Assign the formal name to the corresponding %variable.
            %ENDFOR ArgNr
%:::        PROC %=*, NESTINGCHECK=OFF ; Open the namespace and define entry symbol from macro label <code>%:</code> as GLOBAL.
            PUSH RBP
            MOV RBP,RSP                ; Initialize the frame pointer.
          %ENDMACRO Procedure
</pre>

<dl id="SaveToShadow"><dt><a href="#top">&uarr; SaveToShadow</a></dt>
<dd><p>Macro <dfn>SaveToShadow</dfn> stores the first four arguments of fast-called Procedure
<!---->to the shadow space reserved by Invoke. This enables the first four arguments be referred
<!---->by their %formal names or by generic names %Arg1, %Arg2, %Arg3, %Arg4.</p>
<p>Macro SaveToShadow should be used inside Procedure..EndProcedure block, near its beginning.
<br/>When it is omitted, the first four arguments are available only in registers RCX, RDX, R8, R9 (or XMM0..XMM3)
<!---->and the shadow space contains undefined garbage.</p>
<p>When some of arguments contains floating-point number, it is passed to Procedure in SIMD register
<!---->instead of GPR, and it must be therefore copied to the corresponding GPR prior to SaveToShadow. Example (Radius is FP):</dd>
<dd class="PRE"> MyCircle Procedure Xcoord, Ycoord, Radius
<!---->      MOVQ R8,XMM2 ; Copy the FP value from SIMD to the coresponding GPR.
<!---->      SaveToShadow
<!---->      ; Procedure body now has the 1st argument available at [RBP+16] alias [%Xcoord] alias [%Arg1] alias RCX. Et cetera.
<!---->      Uses RSI,RDI
<!---->MyLv1 LocalVar Size=16
<!---->MyLv2 LocalVar Size=24
<!---->      ClearLocalVar
<!---->      ; Procedure body now has the cleared 1st local variable available at [RBP-32] alias [%MyLv1].
<!---->      ; Instructions of Procedure body are here.
<!---->    EndProcedure MyCircle</dd>
<dt>Input</dt><dd><b>RCX, RDX, R8, R9</b> contain the first four arguments, respectively.</dd>
<dt>Output</dt><dd>Shadow space (4*8 bytes at RBP+16) is populated with Procedure arguments.</dd>
</dl><pre>
SaveToShadow %MACRO
InProcCheck  %IF "%^PROC" === ""
               %ERROR ID=5926,'Macro "%0" is unexpected here.'
             %ENDIF InProcCheck
             MOV [%Arg1],RCX
             MOV [%Arg2],RDX
             MOV [%Arg3],R8
             MOV [%Arg4],R9
           %ENDMACRO SaveToShadow
</pre>

<dl id="Uses"><dt><a href="#top">&uarr; Uses</a> Register1, Register2,,,,</dt>
<dd><p>Macro <dfn>Uses</dfn> specifies which callee-save registers does the Procedure use,
<!---->so they are pushed on stack here (and they will be restored in <a href="#EndProcedure">EndProcedure
</a> epilogue).</p>
<blockquote>Calling convention macros in 16bit and 32bit mode could save/restore all eight GPR
<!---->with a single PUSHA/POPA. This instruction is not available in 64bit mode, so we will use this macro instead.
</blockquote>
<p>Macro Uses can be used in 64bit mode only, right after the statement <a href="#Procedure">Procedure
</a> and before local stack variables are defined with <a href="#LocalVar">LocalVar</a>.</p>
<p>Callee-save registers RBX,RSI,RDI,R12..R15,XMM6..XMM15, should be enumerated here
<!---->if they are actually used in Procedure..EndProcedure block.
<br/>Callee-save registers RBP,RSP should not be mentioned here, they are always saved automatically in Procedure prologue.
<br/>It is useless to enumerate scratch registers RCX,RDX,R8..R11,XMM0..XMM5 here,
<!---->because the caller of our Procedure cannot expect them to be preserved.
<br/>Registers RAX,XMM0 may not be enumerated here, because they wouldn't return the expected value after their restoration.</p>
</dd>
<dt>Input</dt><dd><b>Register*</b> is GPR or XMM register. Only lower QWORD of XMM register is saved.</dd>
<dt>Output</dt><dd>Macro will push all enumerated registers on stack
<!---->and assign their list to a unique %variable named <code>%Uses_<em>ProcedureName</em>
</code> in reversed order. This %variable will be used by EndProcedure for restoration of callee-save registers.</dd>
</dl><pre>
Uses %MACRO Register1,Register2,...
InProcCheck   %IF "%^PROC" === ""
                %ERROR ID=5926,'Macro "%0" is unexpected here.'
              %ENDIF InProcCheck
%Uses         %SET2 %%Uses_%^PROC
reg           %FOR %*
                %IF REGTYPE#(%reg) = 'Q' ; General-purpose 64bit register.
                  PUSHQ %reg
%Uses             %SET %reg,%Uses        ; Accumulate register names in reversed order.
                %ENDIF
                %IF REGTYPE#(%reg) = 'X' ; SIMD XMM register.
                  SUB RSP,8
                  MOVQ [RSP],%reg
%Uses             %SET %reg,%Uses        ; Accumulate register names in reversed order.
                %ENDIF
RegTypeCheck    %IF REGTYPE#(%reg) != 'Q' && REGTYPE#(%reg) != 'X'
                   %ERROR ID=5927,'Macro "Uses" does not support operand "%reg".'
                %ENDIF RegTypeCheck
              %ENDFOR reg
%%Uses_%^PROC %SETX %Uses
            %ENDMACRO Uses
</pre>


<dl id="LocalVar"><dt><a href="#top">&uarr; LocalVar</a> Size=8</dt>
<dd>Macro <dfn>LocalVar</dfn> reserves and declares local memory variable with the given Size allocated on machine stack
<!---->and assigns its name to a preprocessing %variable which has its name derived from the label of macro LocalVar.
<br/>It can only be used inside <code>Procedure..EndProcedure</code> block.</dd>
<dt>Input</dt><dd>Plain identifier must be defined as a label of
<b>LocalVar</b> statement. It does not need to be unique in the program
<!---->because it does not declare assembly symbol. The name will be
<!----> prefixed with <kbd>%</kbd> and used as preprocessing %variable
<!---->for addressing the memory variable withing the procedure body.
<br/><b>Size=</b>8 specifies how many bytes should be reserved for the local stack variable.
<!---->The Size is automatically rounded up to the nearest multiple of 8.</dd>
<dt>Output</dt><dd>Macro will define a preprocessing %variable with
<!---->the name which was defined as the label but it is now prefixed with percent sign.
<!---->Then it will emit machine instruction <code>SUB RSP,%Size</code>
<!---->to reserve room on the machine stack.
<br/>Macro LocalVar also maintains the &quot;global&quot; preprocessing %variable
<code>%LvSize_<em>ProcedureName</em></code> which was initialized in macro <a href="#Procedure">Procedure
</a> and which will be used for zeroing local variables in
<a href="#ClearLocalVar">ClearLocalVar</a> and for discarding local variables in
<a href="#EndProcedure">EndProcedure</a>.</dd>
<dt>Example</dt><dd class="PRE">
<!---->ProcName: Procedure Param1    ; This example uses two local stack variables with sizes 8 and 1K.
<!---->           Uses RDI           ; Saved callee-save register is now available at <code>RBP-8</code>.
<!----> BlockSize LocalVar           ; <code>%BlockSize</code> is now assigned with <code>RBP-16</code> (8+8).
<!----> Block     LocalVar Size=1024 ; <code>%Block</code> is now assigned with <code>RBP-1040</code> (8+8+1024).
<!---->           ClearLocalVar      ; Fill %Block and %BlockSize with 0.
<!---->           MOV [%BlockSize],1K, DATA=QWORD
<!---->           LEA RDI,[%Block]
<!---->           ; more instructions...
<!---->          EndProcedure ProcName</dd>
</dl>
<pre>
LocalVar      %MACRO Size=8
InProcCheck     %IF "%^PROC" === ""
                  %ERROR ID=5926,'Macro "%0" is unexpected here.'
                  %EXITMACRO LocalVar
                %ENDIF InProcCheck
LblCheck        %IF "%:" === ""
                  %ERROR ID=5922, 'Macro "%0" requires a label.'
                  %EXITMACRO LocalVar
                %ENDIF
OrdCheck        %IF %#
                  %ERROR ID=5923, 'Macro "%0" does not expect ordinal parameters.'
                %ENDIF
%:              %COMMENT                          ; This empty comment block makes the label of macro void,
                %ENDCOMMENT %:                    ;   so it does not declare a symbol.
%ThisLvSize     %SETA (%Size + 7) & ~7            ; Round up to the nearest multiple of 8.
%GlbLvSize      %SET2 %%LvSize_%^PROC+%ThisLvSize ; Increase the total size of previously defined local variables.
%%LvSize_%^PROC %SETX %GlbLvSize                  ; Update the "global" %variable.
                SUB RSP, %ThisLvSize              ; Stack memory allocation.
%ThisUses       %SET2 %%Uses_%^PROC               ; Retrieve the list of used registers.
%ThisLen        %SETL %ThisUses                   ; Number of registers pushed by macro Uses.
%%%:            %SETX RBP-8*%ThisLen-(%GlbLvSize) ; Assign formal %name to the id <kbd>%:</kbd> specified as LocalVar label.
   %ENDMACRO LocalVar
</pre>

<dl id="ClearLocalVar">
<dt><a href="#top">&uarr; ClearLocalVar</a></dt>
<dd>This macro zeroes all variables on stack previously declared with
<a href="#LocalVar">LocalVar</a>. ClearLocalVar should be expanded
<!---->right after the last LocalVar declarations, before any stack operations are made.
<blockquote>We could as well decide to initialize each local variable individually, e.g.
<code>MOVQ [%MyLocalVar],0</code>,
<!---->and in this case the macro ClearLocalVar will not be used in the Procedure body at all.
</blockquote></dd>
<dt>Input</dt><dd>Macro does not use explicit parameters.
<!---->The cleared memory is pointed to with <code>RSP</code>,
<!---->its size is specified with &quot;global&quot; variable
<code>%LvSize_<em>ProcedureName</em></code>.</dd>
<dt>Output</dt><dd><b>RAX=</b>0
</dd></dl><pre>
ClearLocalVar %MACRO
InProcCheck %IF "%^PROC" === ""
              %ERROR ID=5926,'Macro "%0" is unexpected here.'
              %EXITMACRO ClearLocalVar
            %ENDIF
%GlbLvSize  %SET2 %%LvSize_%^PROC
            %IF %GlbLvSize  ; Do nothing if no LocalVar was used in this Procedure (%GlbLvSize=0).
              PUSH RCX,RDI
               LEA RDI,[RSP+2*8] ; Skip pushed RCX,RDI.
               MOV ECX,%GlbLvSize / 8
               XOR EAX,EAX
               REP STOSQ
              POP RDI,RCX
            %ENDIF
          %ENDMACRO ClearLocalVar
</pre>

<dl id="EndProcedure">
<dt><a href="#top">&uarr; EndProcedure</a> ProcName</dt>
<dd><p>Macro <dfn>EndProcedure</dfn> terminates context of the previously opened
<a href="#Procedure">Procedure
</a>. This epilogue of FastCall convention will</p><ul>
<li> discard local variables defined by <a href="#LocalVar">LocalVar</a> using machine instructions
<code>MOV RSP,RBP</code>,</li>
<li>restore callee-save registers saved by <a href="#Uses">Uses</a> with <code>POP registers</code>,</li>
<li>restore caller's frame pointer with <code>POP RBP</code> and then</li>
<li>return with near <code>RET</code> to the parent code
<!---->which the Procedure was invoked from.</li></ul>
<p>Operands are not removed from stack, that's the job of <a href="#Invoke">Invoke</a>.</p>
<blockquote> Programmer should never use explicit machine instruction <code>RET</code>
 <!----> to return from the block defined with <code>Procedure .. EndProcedure</code>.
 <br/>If premature return is required, jump to the label of <code>EndProcedure
</code> statement instead.</blockquote>
</dd>
<dt>Input</dt><dd>
<b>ProcName</b> This macroinstruction requires exactly one operand
<!---->which is identical with the label of previous corresponding
<code>Procedure</code> statement.</dd>
<dt>Output</dt><dd>Stack frame is released, current process returns below
<code>Invoke</code> statement.</dd></dl><pre>
EndProcedure %MACRO ProcName
OpCheck    %IF %# <> 1
             %ERROR ID=5924, 'Macro "EndProcedure" requires one operand.'
             %EXITMACRO EndProcedure
           %ENDIF
%NameStrip %SET %ProcName
Decolonize %WHILE "%NameStrip[%&]" === ":" ; Get rid of trailing colon(s), if used.
%NameStrip   %SET %NameStrip[1..%&-1]
           %ENDWHILE Decolonize
NestCheck  %IF "%NameStrip" !=== "%^PROC"
             %ERROR ID=5925, 'Nesting mismatch, "%ProcName Procedure" missing.'
             %EXITMACRO EndProcedure
           %ENDIF NestCheck
%GlbLvSize %SET2 %%LvSize_%^PROC
           %IF %GlbLvSize
             ADD RSP,%GlbLvSize            ; Discard local variables.
           %ENDIF
%ThisUses  %SET2 %%Uses_%^PROC
reg        %FOR %ThisUses                  ; Callee-save registers saved by macro Uses.
             %IF REGTYPE#(%reg) = 'Q'      ; General-purpose 64bit register.
               POPQ %reg
             %ENDIF
             %IF REGTYPE#(%reg) = 'X'      ; SIMD XMM register.
                MOVQ %reg,[RSP]
                ADD RSP,8
             %ENDIF
           %ENDFOR reg
           POP RBP                         ; Restore caller's frame pointer.
           RET                             ; Return below Invoke which called %ProcName.
           ENDP %ProcName, NESTINGCHECK=OFF
         %ENDMACRO EndProcedure
</pre>

<dl id="Invoke"><dt><a href="#top">&uarr; Invoke</a> Function, Arg1, Arg2,,, Fastmode=%Fastmode</dt>
<dd><p>Macro <dfn>Invoke</dfn> is a replacement of standard CALL instruction which can pass parameters
<!----> to the Procedure in <strong>FastCall convention</strong>.</p>
<blockquote>This FastCall macro Invoke is similar to macroinstruction
<a class="EXT" href="winabi.htm#WinABI">WinABI</a>, which is specialized on invokation of functions
<!---->exported from MS Windows 64bit by <a class="EXTL" href="../eadoc/links.htm#WindowsAPI">[WindowsAPI]</a>.
<br/>WinABI in addition takes care of ANSI | WIDE variants of invoked function name, and declares the function
<!---->as imported from DLL specified by keyword <code>Lib=</code>.</blockquote>
 <p>According to FastCall convention, arguments are pushed backwards on stack as QWORDs,
<!----> starting from the last to the fifth. The first four parameters are loaded to RCX, RDX, R8, R9
<!---->and not pushed on stack. Nevertheless, room for the first four arguments is always reserved on stack
<!---->(so called <em>shadow space</em>) even when the invoked function has less than four arguments.
<br/>When the Procedure expects argument in floating-point format instead of integer, pointer or immediate,
<!---->the first four arguments are loaded to XMM0, XMM1, XMM2, XMM3 rather than to GPR.
<br/>Stack pointer will be OWORD aligned before the CALL instruction is performed.</p>
<p>Invoked procedure does not remove arguments from stack, it terminates with a simple near RET.
<!---->Epilogue of macro Invoke restores RSP to its original value.</p>
<dt>Input</dt><dd><b>Function</b> is the name of invoked procedure. This can be a function from
<!---->statically linked library, MS Windows function imported from system DLL, or it can be
<!---->a block defined with Procedure, EndProcedure from this FastCall macrolibrary.
<br/>Function may also be provided in the form of GPR containing the entry address of the function.
<br/><b>Arg*</b> can be a SIMD register or anything pushable:<ul>
<li>XMM register with floating-point value in its lower bits, for instance <code>XMM15</code>,</li>
<li>64bit GP register with integer value or pointer, for instance <code>RBX</code>,</li>
<li>segment register <code>FS</code> or <code>GS</code>,</li>
<li>32bit immediate integer value (it will be sign-extended by CPU), for instance
<code>0</code> or <code>-11</code>,</li>
<li>numeric symbol, for instance <code>GMEM_FIXED</code>,</li>
<li>literal or address symbol, for instance <code>="Hello, world!"</code> or <code>MyCallback:</code>.</li>
<li>64bit memory variable, for instance <code>[RBP+32]</code> or <code>[MyTable+RSI]</code> or <code>[=Q 22.5]#SD</code>.</li>
</ul>It is programmer's responsibility to provide exactly that many arguments as is specified in Function documentation.
<br/>Any argument may be suffixed with type specificator <code>#SS</code> or <code>#SD</code> (case insensitive),
<!---->which signalizes that it represents floating-point value in <em>Scalar Single</em> or
<em>Scalar Double</em> precision format, and that it should be therefore passed to the Function in XMM register instead of GPR.
<br/>Suffix is not necessary with XMM register (argument passed in XMM is always assumed to contain floating-point number).
<br/>Suffix is not necessary when Fastmode=No, because the robust version transfers the first four arguments
<!---->simultaneously in SIMD and GP registers anyway, no matter if they are float or integer.
<br/>Suffix is not necessary in 5th and higher arguments in both modes (they are passed via machine stack regardless of their type).
<br/><b>Fastmode=No</b> is an <a class="EXT" href="../eadoc/#BooleansExt">extended Boolean</a> switch. When it's
<em>false</em> or omitted (default),
<!---->the Invoke macro preserves all registers except for RAX and XMM0 which return the result of Function,
<!---->similary to other robust macros from EuroAssembler libraries.
<br/>Although Microsoft ABI specifies fastcall convention with floating-point parameters %1..%4
<!---->delivered in XMM0, XMM1, XMM2, XMM3, and with parameters %1..%4 of all other types delivered in RCX, RDX, R8, R9,
<!---->arguments of Invoke in robust mode (Fastmode=No) may be supplied in those registers too in arbitrary order, for instance
<code> Invoke MessageBox,RDX,R8,R8,MB_OK</code>.
<br/><b>Fastmode=Yes</b> is the macro expansion mode where Invoke does not preserve caller-save registers and
<!---->it loads the first four arguments directly to
<code>XMM0, XMM1, XMM2, XMM3</code> when they are floating-point values, and to
<code>RCX, RDX, R8, R9</code> in all other cases, so the invokation is faster.
<!---->Registers RCX, RDX, R8, R9, XMM0..XMM3 cannot be used as macro arguments,
<!---->because they are being overwritten in prologue. Or they should be only used in the exact ABI-specified order, e.g.
<code>Invoke Function, RCX, XMM1, R8, XMM3</code>.
<!---->Similary, registers RCX, RDX, R8, R9 cannot be used instead of Function name in fast mode. Use other GPR, e.g.
<code><br/>IMPORT WriteConsole,Lib=kernel32.dll
<br/>LEA RDI, [WriteConsole]
<br/>Invoke Fastmode=Yes, RDI, RBX, Message, SIZE# Message, WrittenChars, 0</code>
</dd>
<dt>Output</dt><dd><b>RAX, XMM0, RFlags</b> are set as returned from the invoked Function.
<br/><b>RBX,RBP,RSP,RSI,RDI,R12..R15,XMM6..XMM15</b> are preserved (callee-save registers).
<br/>Other XMM and GPR are preserved only if Fastmode=No.</dd>
<dt>Documentation</dt><dd>Microsoft FastCall convention is described in
<a class="EXTL" href="../eadoc/links.htm#WinABI64">[WinABI64]</a> and
<a class="EXTL" href="../eadoc/links.htm#MSx64Conv">[MSx64Conv]</a>.</dd>
<dt>Example</dt><dd>Expansion of Invoke invokation of the function CreateFile with seven arguments in both modes:
<code> Invoke CreateFileA, FileName, GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0</code>
 <samp>|                          | ; <b>Fast Version</b>.
<!---->|00000000:                 |   Invoke CreateFileA, FileName, GENERIC_READ, FILE_SHARE_READ, 0, \
<!---->|00000000:                 |                       OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,0, Fastmode=Yes
<!---->|00000000:54               +          PUSH RSP                    ; Store original stack pointer value (equilibrum).
<!---->|00000001:40F6C408         +          TEST SPL,1000b              ; Test RSP OWORD alignment at run-time.
<!---->|00000005:7506             +          JNZ .Invoke1:
<!---->|00000007:54               +          PUSH RSP                    ; Store and update 2nd copy of original RSP (equilibrum).
<!---->|00000008:4883042408       +          ADDQ [RSP],8                ; Those two instructions aren't executed if RSP was properly aligned.
<!---->|0000000D:                 + .Invoke1:
<!---->|0000000D:6A00             +          PUSHQ 0                     ; Push 7th argument.
<!---->|0000000F:6880000000       +          PUSHQ FILE_ATTRIBUTE_NORMAL ; Push 6th argument.
<!---->|00000014:6A03             +          PUSHQ OPEN_EXISTING         ; Push 5th argument.
<!---->|00000016:41B900000000     +          MOV R9,0                    ; Load 4th argument.
<!---->|0000001C:41B801000000     +          MOV R8,FILE_SHARE_READ      ; Load 3rd argument.
<!---->|00000022:BA00000080       +          MOV RDX,GENERIC_READ        ; Load 2nd argument.
<!---->|00000027:488D0D(00000000) +          LEA RCX,[FileName]          ; Load 1st argument.
<!---->|0000002E:4883EC20         +          SUB RSP,4*8                 ; Make room for <b>shadow space in fast mode</b>. RSP is OWORD-aligned.
<!---->|00000032:E8(00000000)     +          CALL CreateFileA            ; <b>Call the imported function</b>.
<!---->|00000037:488D642438       +          LEA RSP,[RSP+7*8]           ; Discard transferred arguments, keep RFlags.
<!---->|0000003C:5C               +          POP RSP                     ; Restore RSP to equilibrum from 1st or 2nd copy.
<!---->|0000003D:                 | ; Invoke in fast mode occupies 61 bytes of code.
</samp>
<samp>|00000000:                 | ; <b>Robust version</b>.
<!---->|00000000:                 |   Invoke CreateFileA, FileName, GENERIC_READ, FILE_SHARE_READ, 0, \
<!---->|00000000:                 |                       OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,0, Fastmode=No
<!---->|00000000:6A00             +          PUSHQ 0                     ; Push 7th argument.
<!---->|00000002:6880000000       +          PUSHQ FILE_ATTRIBUTE_NORMAL ; Push 6th argument
<!---->|00000007:6A03             +          PUSHQ OPEN_EXISTING         ; Push 5th argument
<!---->|00000009:6A00             +          PUSHQ 0                     ; Push 4th argument
<!---->|0000000B:6A01             +          PUSHQ FILE_SHARE_READ       ; Push 3rd argument
<!---->|0000000D:6800000080       +          PUSHQ GENERIC_READ          ; Push 2nd argument
<!---->|00000012:50               +          PUSH RAX                    ; Alloc 1st argument on stack.
<!---->|00000013:488D05(00000000) +          LEA RAX,[FileName]          ; Load 1st argument.
<!---->|0000001A:48870424         +          XCHG RAX,[RSP]              ; Transfer the pointer without clobbering RAX.
<!---->|0000001E:6A07             +          PUSHQ 7                     ; Push the number of arguments.
<!---->|00000020:488D05(00000000) +          LEA RAX,[CreateFileA]       ; Load the function address (pointer to its thunk in [.idata]).
<!---->|00000027:E805000000       +          CALL Invoke@RT              ; <b>Call the runtime</b> with function in RAX.
<!---->|0000002C:488D642440       +          LEA RSP,[RSP+8*8]           ; Restore stack to equilibrum, preserving RFlags.
<!---->|00000031:                 | ; Invoke in robust mode occupies 49 bytes of code (plus 190 bytes of runtime code, once per program).
</samp></dd>
<dt>Remark</dt><dd>Macros Invoke can be expanded in one of two modes:
<ul><li><strong>Fast</strong> where the first four arguments are loaded directly to fixed registers
<!---->according to ABI specification and all scratch registers are destroyed.
<!---->Arguments %1..%4 are copied to transfer registers with <code>MOV reg,value</code>(5 bytes).
<!---->64bit pointers are transferred by the help of temporary register with
<code>LEA reg,[address]</code> using RIP-relative addressing (7 bytes) resolvable at link time.</li>
<li><strong>Robust</strong> mode uses its own runtime procedure
<!---->for preservation of scratch registers and allows to use them
<!---->for passing of arguments in arbitrary order. Small scalar arguments are copied
<!---->to the transfer registers with <code>PUSH value ; POP reg</code> (2+1 bytes).</li></ul>
<p>Selection of the mode depends on optimisation criterion:<ul>
<li>If you optimise for speed, use Fastmode=Yes.</li>
<li>If you optimise for programmer's convenience, use Fastmode=No.</li>
<li>If you optimise for code size, it depends on the number and type of arguments.</li></ul>
<p>Robust variant of Invoke is often shorter, but it emits 190 additional bytes
<!---->of runtime procedure (only once in a program), so it is profitable when we have
<!---->more than cca twenty invocations in the program. Robust variant may also spare
<!---->some push/pops because it doesn't change any scratch registers.</p>
<blockquote>When you want to switch on the Fastmode for all Invoke invokations, you don't have to append
<code>,Fastmode=Yes</code> to every <code>Invoke</code> if you set preprocessing variable %Fastmode
<!---->in the beginning of your program: <code>%Fastmode %SETB On</code>.</blockquote>
</dd>
<dt>Stack alignment</dt><dd>See the identical
<a class="EXT" href="winabi.htm#WinABI_StackAlignment">example of stack layout</a> of macro WinABI.</dd>
</dl><pre>
Invoke %MACRO Function, Arg1, Arg2,,, Fastmode=%Fastmode, Lib=
%Fast   %SETB %Fastmode
%Robust %SETB ! %Fast
Fa      %IF %Fast                       ; <b>Align stack in fast mode</b> only.
          PUSH RSP                      ; Store original stack pointer value (equilibrum).
          TEST SPL,1000b                ; Test stack OWORD alignment at run-time.
FaEv      %IF %# & 1b || %# <= 5        ;>If the number of Function arguments is 0,1,2,3,4,6,8,10,,(even),
            JZ .Invoke%.:               ;   store 2nd copy of equilibrum when RSP is OWORD-unaligned.
          %ELSE FaEv                    ; If the number of arguments is 5,7,9,11,,, (odd),
            JNZ .Invoke%.:              ;   store 2nd copy of equilibrum when RSP is OWORD-aligned.
          %ENDIF FaEv
          PUSH RSP                      ; Store and update 2nd copy of original RSP (equilibrum).
          ADDQ [RSP],8                  ; Those two instructions aren't executed if RSP was properly aligned.
.Invoke%.:
        %ENDIF Fa
%GPR    %SET  RCX,RDX,R8,R9             ; Enumerate registers for transfer of integer|pointer values.
%SIMD   %SET  XMM0,XMM1,XMM2,XMM3       ; Enumerate registers for transfer of floating-point values.
%ArgNr  %SETA %#                        ; Number of macro ordinals, i.e. number of Function arguments + 1.
Arg     %WHILE %ArgNr > 1
%Arg     %SET %*{%ArgNr}                ; <b>Transfer all Function arguments</b>, start with the last one.
%ArgNr   %SETA %ArgNr-1                 ; %ArgNr is now the ordinal Nr of Function argument (,,3,2,1).
%suffix  %SET Q                         ; %suffix of MOV will be Q, SS or SD (MOVQ, MOVSS or MOVSD).
         %IF '%Arg[%&-2..%&-1]'=='#S'   ; If suffix #SS or #SD is present in argument notation,
%suffix    %SET %Arg[%&-1..%&]          ;  let %suffix be SS or SD
%Arg       %SET %Arg[1..%&-3]           ;  and remove it from the argument.
         %ENDIF                         ; %Arg may be GPR,SIMD,imm@abs,ptr@rel,[mem@abs],[mem@rel].
Rb       %IF %ArgNr>4 || %Robust        ; <b>Transfer %Arg via stack</b>.
RbSc       %IF TYPE#(SEGMENT#(%Arg))='N'; %Arg is not relocatable (scalar).
RbScRg       %IF TYPE#(%Arg) = 'R'      ; It can be GPR,SIMD,imm@abs,[mem@abs].
RbScRgXm       %IF REGTYPE#(%Arg)='X'   ; %Arg is a GP or SIMD register.
                 SUB RSP,8
                 MOV%suffix [RSP],%Arg  ; %Arg is a SIMD register.
               %ELSE RbScRgXm
                 PUSHQ %Arg             ; %Arg is a GP register.
               %ENDIF RbScRgXm
             %ELSE RbScRg               ; %Arg it not a register.
               PUSHQ %Arg               ; %Arg is scalar immediate or [mem], e.g. 1 or [RBP+16].
             %ENDIF RbScRg
           %ELSE RbSc                   ; %Arg is relocatable (vector), e.g. Symbol or [Symbol+RSI].
RbVeM        %IF '%Arg[1]' === '['      ; Argument is passed by value, via a temporary GPR.
               PUSH RAX                 ; Original contents of the borrowed RAX must be kept.
               LEA RAX,%Arg             ; Use relative addressing frame for relocatable %Arg.
               MOV RAX,[RAX]            ; Dereference the argument value.
               XCHG RAX,[RSP]           ; Transfer the value.
             %ELSE RbVeM                ; Relocatable argument is passed by reference, e.g. Symbol.
               PUSH RAX                 ; Original contents of the borrowed RAX must be kept.
               LEA RAX,[%Arg]           ; Use relative addressing frame for relocatable %Arg.
               XCHG RAX,[RSP]           ; Transfer the pointer.
             %ENDIF RbVeM
           %ENDIF RbSc
         %ELSE Rb                       ; Fastmode=Yes and %ArgNr=4,3,2,1. <b>Transfer via registers</b>.
FaSc       %IF TYPE#(SEGMENT#(%Arg))='N'; %Arg is not relocatable (scalar).
FaScRg       %IF TYPE#(%Arg) = 'R'      ; It can be GPR,SIMD,imm@abs,[mem@abs].
FaScRgXm       %IF REGTYPE#(%Arg)='X'   ; %Arg is a GP or SIMD register.
                 %IF "%SIMD{%ArgNr}" !== "%Arg"  ; %Arg is XMM. Skip when it's already there.
                   MOV%suffix %SIMD{%ArgNr},%Arg ; Copy SIMD %Arg to other SIMD (XMM0..XMM3).
                 %ENDIF
               %ELSE FaScRgXm           ; %Arg is GPR.
                 %IF "%GPR{%ArgNr}" !== "%Arg"   ; Skip when it's already there.
                    MOV %GPR{%ArgNr},%Arg        ; Copy GPR to other GPR (R9,R8,RDX,RCX).
                 %ENDIF
               %ENDIF FaScRgXm
             %ELSE FaScRg               ; %Arg is scalar immediate or [mem], e.g. 1 or [RBP+16].
FaScIm         %IF '%suffix' === 'Q'
                 MOV %GPR{%ArgNr},%Arg  ; %Arg is integer value.
               %ELSE FaScIm
                 MOV%suffix %SIMD{%ArgNr},%Arg ; %Arg is FP value, e g. [RSI].
               %ENDIF FaScIm
             %ENDIF FaScRg
           %ELSE FaSc                   ; %Arg is relocatable (vector), e.g. Symbol or [Symbol+RSI].
FaVeM        %IF '%Arg[1]' === '['      ; Argument is passed by value, via this GPR.
               LEA %GPR{%ArgNr},%Arg
               MOV %GPR{%ArgNr},[%GPR{%ArgNr}] ; Dereference the argument value, transfer the value.
             %ELSE FaVeM                ; Argument is passed by reference, e.g. Symbol.
               LEA %GPR{%ArgNr},[%Arg]  ; Transfer the pointer.
             %ENDIF FaVeM
           %ENDIF FaSc
         %ENDIF Rb
        %ENDWHILE Arg
Fa       %IF %Fast                      ;
           SUB RSP,4*8                  ; Make room for <b>shadow space in fast mode</b>. RSP is OWORD-aligned.
FaRg       %IF REGTYPE# %Function = 'Q' ; Function was specified as 64bit GPR.
             %IF "%Function"=="RCX"||"%Function"=="RDX"||"%Function"=="R8"||"%Function"=="R9"
               %ERROR ID=5956,'%0 function cannot be supplied in scratch register %Function when Fastmode=Yes.'
               %EXITMACRO Invoke
             %ENDIF
           %ENDIF FaRg                  ; Function was specified by name.
           CALL %Function               ; <b>Call the function</b> in fast mode.
           %IF %# > 5
             LEA RSP,[RSP+8*(%#-1)]     ; Discard transferred arguments, keep RFlags.
           %ELSE
             LEA RSP,[RSP+8*4]          ; Discard transferred arguments, keep RFlags.
           %ENDIF
           POP RSP                      ; Restore RSP to equilibrum from 1st or 2nd copy.
         %ELSE Fa                       ; Use helper runtime procedure in <b>robust mode</b>.
           PUSHQ %#-1                   ; Push the number of Function arguments.
RbRg       %IF REGTYPE# %Function = 'Q' ; Function was specified as 64bit GPR.
             %IF '%Function' !== 'RAX'  ; Skip if it's already in RAX.
               MOV RAX,%Function
             %ENDIF
           %ELSE RbRg                   ; Function was specified by name.
             LEA RAX,[%Function]        ; RVA of the Function (pointer to its thunk in [.idata]).
           %ENDIF RbRg
           CALL Invoke@RT               ; Arguments+their number are on stack. Function is in RAX.
           LEA RSP,[RSP + 8 * %#]       ; Restore stack to equilibrum, preserving RFlags.
Invoke@RT::PROC1                        ; Macro emits the <b>runtime subroutine</b>, which is expanded only once in program.
            PUSH RSI,RDI,R12            ; Calee-save registers used by Invoke@RT procedure.
            PUSH RCX,RDX,R8,R9,R10,R11  ; Robust version preserves scratch GP registers.
            MOVQ RDX,XMM1
            MOVQ  R8,XMM2
            MOVQ  R9,XMM3
            MOVQ R10,XMM4
            MOVQ R11,XMM5
            PUSH RDX,R8,R9,R10,R11      ; Robust version preserves scratch SIMD registers.
            MOV ECX,[RSP+15*8]          ; Number of Function arguments.
            LEA RSI,[RSP+16*8]          ; Pointer to %Arg1 in Invoke@RT stack frame.
            CMP ECX,4                   ; Number of arguments is 0|1|2|3|4|5|6...
            JAE .AtLeast4:
            MOV CL,4                    ; Number is saturated to 4|4|4|4|4|5|6...
  .AtLeast4:MOV R12,RSP                 ; Save (perhaps unaligned) RSP to callee-preserved register.
            ; <b>Align stack pointer</b> as dictated by ABI specification.
            MOV EDX,ECX                 ; Saturated number of operands (4,5,6,,,).
            SHL EDX,3                   ; RDX bit 3 is set if saturated number of arguments is odd (5,7,9,,).
            XOR EDX,ESP                 ; RDX will be 8 when number of arguments is even and RSP is OWORD unaligned,
            AND EDX,0000_1000b          ;   or when it's odd and RSP is already OWORD aligned. Otherwise RDX=0.
            SUB RSP,RDX                 ; Align RSP to OWORD.
            ; <b>Copy ECX arguments from RSI to the callee's shadow space</b>.
            MOV EDX,ECX
            SHL EDX,3
            SUB RSP,RDX                 ; Alloc Function frame (<b>shadow space</b> + possible other arguments).
            MOV RDI,RSP                 ; RSP is OWORD aligned at this moment.
            REP MOVSQ                   ; Copy all pushed arguments.
            ; <b>Load first four arguments to GP registers</b>.
            MOVQ RCX,[RSP+00]
            MOVQ RDX,[RSP+08]
            MOVQ R8, [RSP+16]
            MOVQ R9, [RSP+24]
            ; <b>Copy first four arguments to SIMD registers</b> (for the case they were floating-point).
            MOVQ XMM0,RCX
            MOVQ XMM1,RDX
            MOVQ XMM2,R8
            MOVQ XMM3,R9
            CALL RAX                    ; <b>Call the Function</b> in robust mode.
            MOV RSP,R12                 ; Discard Function frame plus possible stack-alignment stuff.
            POP R11,R10,R9,R8,RDX
            MOVQ XMM5,R11
            MOVQ XMM4,R10
            MOVQ XMM3,R9
            MOVQ XMM2,R8
            MOVQ XMM1,RDX               ; Restore SIMD scratch registers.
            POP R11,R10,R9,R8,RDX,RCX   ; Restore GP scratch registers.
            POP R12,RDI,RSI             ; Restore used callee-save registers.
            RET
           ENDP1 Invoke@RT::
         %ENDIF  Fa
       %ENDMACRO Invoke
</pre>

<pre>
  ENDHEAD fastcall
</pre>


<!--TAILMENU-->
<!--Contents below the marker {!==TAILMENU==} was generated by "generate.php".-->
<br class='CLEAR'/><a id='bottom' href='#top'>&#x25B2;Back to the top&#x25B2;</a>
</body></html>
