<!doctype html><html lang='en'><head>
<meta http-equiv='Content-Type' content='text/html; charset=utf-8'/>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=2.0, user-scalable=yes'>
<meta name='robots' content='ALL,FOLLOW'/>
<meta name='description' content='string32.htm macro library'/>
<meta name='version' content='20250318'/>
<meta name='author' content='Pavel vitsoft Šrubař'/>
<link rel='stylesheet' href='../euroasm.css' type='text/css'/>
<link rel='shortcut icon' href='../favicon.ico'/>
<title>string32.htm macro library</title>
</head>
<body class='MACLIB' id='top'><div class='HEADMENU'><table>
<tr><td rowspan='2' title='&euro;ASM - assembler and linker'><img src='../favicon.ico' alt='EuroAssembler' />
<td><a href='../index.htm' title='Alphabetical index of all &euro;ASM elements, directives and instructions'>Index</a></td>
<td><a href='../eadoc/' class='EADOC' title='Documentation of EuroAssembler'>Manual</a></td>
<td><a href='https://euroassembler.eu/download/' title='History &amp; download of the latest and previous versions'>Download</a></td>
<td><a href='../easource/' class='EASOURCE' title='Source files of EuroAssembler itself'>Source</a></td>
<td><a href='../maclib/' class='MACLIB' title='Macro libraries shipped with &euro;ASM'>Macros</a></td>
<td rowspan='2' title='Find the searched token in any text file on this site'>
<form method='post' action='../search.php' enctype='multipart/form-data' accept-charset='utf-8'>
<input type='text' id='q' placeholder='Searched word(s)' name='q' value=''/>
<br/><label title='Check the box to find the expression even if it is surrounded by other letters | digits.'>
<input type='checkbox' name='EW'/><small>Embedded word</small></label>
<br/><label title='Check the box for case-insensitive search.'>
<input type='checkbox' name='CI'/><small>Case ins.</small></label>
<input type='submit' title='Search for the specified word|expression in all site files.' name='find' value='Search'/>
</form></td></tr><tr>
<td><a href='../sitemap.htm' title='List of directories and files on this site'>Sitemap</a></td>
<td><a href='../eadoc/links.htm' class='EADOC' title='References and external links to resources used in EuroAssembler developement'>Links</a></td>
<td><a href='https://euroassembler.eu/forum/' title='Discussion forum concerning EuroAssembler'>Forum</a></td>
<td><a href='../eatests/' class='EATESTS' title='Program snippets for testing the function of &euro;ASM'>Tests</a></td>
<td><a href='../objlib/' class='OBJLIB' title='Skeletons and sample objects and projects shipped with &euro;ASM'>Projects</a></td>
</tr></table></div>
<!--Contents above the marker {!==/HEADMENU==} was generated by "generate.php".-->
<!--/HEADMENU-->
<h1>String32.htm
<br/><i>Macros</i>
<br/><a href="#Comparedo">Compare$</a>
<br/><a href="#Concatdo">Concat$</a>
<br/><a href="#DecodeUTF8">DecodeUTF8</a>
<br/><a href="#EncodeUTF8">EncodeUTF8</a>
<br/><a href="#GetLengthdo">GetLength$</a>
</h1>
<p>This file can be included to <b>32bit</b> programs written in Euro Assembler.
<br/>It contains <b>OS-independent</b> macros for operations with zero-terminated (ASCIIZ)
<!---->strings in ANSI or WIDE (Unicode) encoding.
<br/>Unicode string must always be word aligned and terminated with
<!---->the zero UNICHAR (word).</p>
<blockquote>Macros may crash the process when the input string is not properly zero-terminated
<!---->and the following memory is not available for reading.</blockquote>
<p>All functions expect zeroed direction flag on input and they do not change it.</p>
<p>ANSI or WIDE functionality is selected by the current
<code>EUROASM UNICODE=</code> boolean option. Its value is available in system variable
<code>%^UNICODE</code>.</p>
<p>Similar macros with identical names for different program width are defined in
<a href="string16.htm">string16.htm</a> and
<a href="string64.htm">string64.htm</a>.</p>
<br class="CLEAR"/>
<pre>
 string32 HEAD
</pre>  

<dl id="GetLengthdo"><dt><a href="#top">&uarr; GetLength$</a> String, Unicode=%^UNICODE</dt>
<dd>This macro returns the size of the string in bytes.</dd>
<dt>Input</dt>
<dd><b>String</b> is pointer to a zero terminated string of ANSI or WIDE
<!---->characters. It may also be a literal string.
<br/><b>Unicode=</b> is a logical parameter which tells whether the strings
<!---->are ANSI or WIDE. By default (if not specified) it is the same as the system preprocessing variable
<code>%^UNICODE</code> at invocation time.</dd>
<dt>Output</dt><dd><b>ECX</b>= size of the string without the terminating NUL
<!---->in bytes. The result is even for WIDE strings.</dd>
<dt>Example</dt><dd class="PRE"> SomeText  DU "Hi!",0
<!---->     ; SomeText was defined as WIDE characters, regardless of current UNICODE status.
<!---->     ; <code>SIZE# SomeText</code> is 8, memory contains <code>4800_6900_2100_0000h</code>
<!---->    EUROASM UNICODE=YES
<!---->    GetLength$ SomeText  ; ECX is now 6 (3 nonzero UNICHARS).
<!---->    EUROASM UNICODE=NO
<!---->    GetLength$ SomeText  ; ECX is now 1 (1 nonzero BYTE).</dd></dl><pre>
GetLength$ %MACRO String, Unicode=%^UNICODE
     PUSHD %String
     %IF %Unicode
       CALL GetLength$W@RT:
       GetLength$W@RT: PROC1
         PUSHD EAX,EDI
           SUB EAX,EAX
           XOR ECX,ECX
           MOV EDI,[ESP+12] ; Pointer to String$.
           DEC ECX
           REPNE SCASW
           NOT ECX
           DEC ECX
           SHL ECX,1
         POP EDI,EAX
         RET 4
       ENDPROC1 GetLength$W@RT:
     %ELSE ; Not %Unicode.
      CALL GetLength$A@RT:
       GetLength$A@RT: PROC1
          PUSHD EAX,EDI
            XOR EAX,EAX
            XOR ECX,ECX
            MOV EDI,[ESP+12] ; Pointer to String$.
            DEC ECX
            REPNE SCASB
            NOT ECX
            DEC ECX
         POP EDI,EAX
         RET 4
       ENDPROC1 GetLength$A@RT:
     %ENDIF
    %ENDMACRO GetLength$
 </pre>

 <dl id="Concatdo"><dt><a href="#top">&uarr; Concat$</a> Destination, Size=, Source1, Source2,,, Unicode=%^UNICODE</dt>
 <dd>Macro will concatenate one or more zero-terminated source strings (ANSI or WIDE) to a destination string.</dd>
 <dt>Input</dt>
 <dd><b>Destination</b> is a pointer to memory where the result
 <!---->of concatenation will be stored as zero-terminated string.
 <br/><b>Size=</b> is the size in bytes allocated for the output destination buffer
 <!---->including the zero terminator. By default it is set to <code>SIZE# %Destination</code>.
 <br/><b>Source*</b> operands are pointers to the strings which are to be
 <!---->concatenated. The first one (Source1) may be identical
 <!---->with the destination, when we need to append something
 <!---->to an existing string.
 <br/><b>Unicode=</b> is a logical parameter which tells whether
 <!---->the strings are ANSI or WIDE. By default (if not specified) it is the same as
 <!---->the system preprocessing variable <code>%^UNICODE</code> at invocation time.
 <br/>Unicode should be FALSE when the concatenated string are in UTF-8.</dd>
 <dt>Output</dt><dd><b>CF</b>=0, Destination is filled with concatenation, all registers are preserved.
 <br/><b>CF</b>=1 when the Size= is not long enough. The output buffer Size
 <!---->is never exceeded.</dd>
 <dt>Example</dt><dd class="PRE">Concat$ FullName$,Path$,FileName$,=".htm"</dd>
 </dl><pre>
Concat$ %MACRO Destination, Source1,Source2,,, Size=, Unicode=%^UNICODE
   %IF %# < 2                                                                                  ; >>
     %ERROR ID=5930, 'Missing operand of macro "Concat$".'
     %EXITMACRO Concat$
   %ENDIF
   PUSH EBP      ; Variable number of arguments uses a special stack frame.
     MOV EBP,ESP ; Store stack pointer.
     ArgNr %FOR %#..2, STEP= -1
       PUSHD %*{%ArgNr} ; All Source pointers, starting with the last.
     %ENDFOR ArgNr
     PUSHD %# - 1 ; Number of Source strings to concatenate.
     %IF "%Size" === ""
       PUSHD SIZE# %Destination
     %ELSE
       PUSHD %Size
     %ENDIF
     PUSHD %Destination
     %IF %Unicode
       CALL Concat$W@RT:
Concat$W@RT: PROC1
       PUSHAD
         MOV EBP,ESP
         MOV EDI,[EBP+36]    ; %Destination.
         MOV EDX,[EBP+40]    ; %Size.
         MOV ECX,[EBP+44]    ; Number of Source strings.
         LEA EDX,[EDI+EDX-2] ; End of allocated Destination.
         XOR EAX,EAX
    .20: MOV ESI,[EBP+48]    ; Pointer to %Source.
    .30: LODSW
         TEST EAX            ; Check if it's end of source string.
         JZ .40:
         CMP EDI,EDX         ; Check if it's end of destination string.
         CMC
         JC .80:             ; If destination size overflowed.
         STOSW
         JMP .30:
    .40: ADD EBP,4           ; The next Source pointer on stack frame.
         LOOP .20:
    .80: MOV AX,0            ; Finally zero-terminate the destination.
         STOSW
       POPAD
       RET                   ; CF=overflow
      ENDPROC1 Concat$W@RT:
     %ELSE                   ; If not %Unicode.
       CALL Concat$A@RT:
Concat$A@RT: PROC1
       PUSHAD
         MOV EBP,ESP
         MOV EDI,[EBP+36]    ; %Destination.
         MOV EDX,[EBP+40]    ; %Size.
         MOV ECX,[EBP+44]    ; Number of Source strings.
         LEA EDX,[EDI+EDX-1] ; End of allocated Destination.
         XOR EAX,EAX
    .20: MOV ESI,[EBP+48]    ; Pointer to %Source.
    .30: LODSB
         TEST EAX            ; Check if it's end of source string.
         JZ .40:
         CMP EDI,EDX         ; Check if it's end of destination string.
         CMC
         JC .80:             ; If destination size overflowed.
         STOSB
         JMP .30:
    .40: ADD EBP,4           ; The next Source pointer on stack frame.
         LOOP .20:
    .80: MOV AL,0            ; Finally zero-terminate the destination.
         STOSB
       POPAD
       RET                   ; CF=overflow
      ENDPROC1 Concat$A@RT:
     %ENDIF
     MOV ESP,EBP             ; Restore the stack.
   POP EBP
  %ENDMACRO Concat$
</pre>

<dl id="Comparedo"><dt><a href="#top">&uarr; Compare$</a> String1, String2, Unicode=%^UNICODE</dt>
<dd>Compare two zero-terminated ANSI or WIDE strings.</dd>
<dt>Input</dt>
<dd><b>String1</b> is pointer to the first ANSI or WIDE zero-terminated strings. ESI is assumed when the first operand is omitted.
<br/><b>String2</b> is pointer to the second ANSI or WIDE zero-terminated strings. EDI is assumed when the second operand is omitted.
<br/><b>Unicode=</b> is a logical parameter which tells whether
<!---->the strings are ANSI or WIDE. By default (if not specified) it is the same as
<!---->the system preprocessing variable <code>%^UNICODE</code> at invocation time.
<br/>In non-flat memory model DS=ES are assumed to specify segment of both strings.</dd>
<dt>Output</dt><dd><b>ZF</b>=1 if both string are identical,
<br/><b>ZF</b>=0 otherwise.</dd></dl><pre>
Compare$ %MACRO String1, String2, Unicode=%^UNICODE
   %IF "%String2" === ""
      PUSHD EDI
   %ELSE
      PUSHD %String2
   %ENDIF
   %IF "%String1" === ""
      PUSHD ESI
   %ELSE
      PUSHD %String1
   %ENDIF
   %IF %Unicode
     CALL Compare$W@RT:
Compare$W@RT: PROC1
       PUSHAD
         MOV EBP,ESP
         SUB EAX,EAX
         SUB ECX,ECX
         MOV EDI,[EBP+40] ; %String2.
         DEC ECX
         MOV EBX,EDI
         REPNE:SCASW      ; Search for the terminator.
         SUB EDI,EBX      ; Size of String2 in bytes including the UNICHAR NUL.
         MOV EDX,EDI
         MOV EDI,[EBP+36] ; %String1.
         MOV ESI,EDI
         REPNE:SCASW      ; Search for the terminator.
         MOV ECX,EDI
         SUB ECX,ESI      ; Size of %String1 in bytes including the UNICHAR NUL.
         CMP ECX,EDX      ; Compare string sizes.
         JNE .90          ; If sizes do not match.
         MOV EDI,EBX      ; String2.
         REPE CMPSB
   .90:POPAD
       RET 2*4
      ENDPROC1 Compare$W@RT:
     %ELSE                ; If not %Unicode.
       CALL Compare$A@RT:
Compare$A@RT: PROC1
       PUSHAD
         MOV EBP,ESP
         SUB EAX,EAX
         SUB ECX,ECX
         MOV EDI,[EBP+40] ; %String2.
         DEC ECX
         MOV EBX,EDI
         REPNE:SCASB      ; Search for the terminator.
         SUB EDI,EBX      ; Size of String2 in bytes including the NUL.
         MOV EDX,EDI
         MOV EDI,[EBP+36] ; %String1.
         MOV ESI,EDI
         REPNE:SCASB      ; Search for the terminator.
         MOV ECX,EDI
         SUB ECX,ESI      ; Size of %String1 in bytes including the NUL.
         CMP EDX,ECX      ; Compare string sizes.
         JNE .90          ; If sizes do not match.
         MOV EDI,EBX      ; String2.
         REPE CMPSB
   .90:POPAD
       RET 2*4
      ENDPROC1 Compare$A@RT:
     %ENDIF
  %ENDMACRO Compare$
</pre>

<dl id="DecodeUTF8"><dt><a href="#top">DecodeUTF8</a> Source, CallbackProc, Size=-1, Width=16</dt>
<dd><p>Macro <dfn>DecodeUTF8</dfn> converts Source UTF-8 string to UTF-16 or UTF-32 string.
<br/>Source string is either zero-terminated, or its Size= must be specified.
<!---->Conversion stops at NUL byte, which is not converted to output.
<!---->Input never reads beyond Source+Size.</p>
<p>If <em>Byte Order Mark</em> (BOM, <code>0xEF,0xBB,0xBF
</code>) is detected at the beginning of the Source string, it is ignored.</p>
<p>Invalid UTF-8 sequence will send a <em>replacement character</em> <code>0xFFFD</code>
<kbd>&#xfffd;</kbd> to the output.</p>
<p>Byte order in output encoding is always LittleEndian, the same which is used in MS Windows WIDE functions.</p>
<blockquote>If you want to produce UTF-16BE, perform <code>XCHG AL,AH</code> in CallbackProc.
<br/>If you want to produce UTF-32BE, perform <code>BSWAP EAX</code> in CallbackProc.
<br/>If you want to prefix the output string with BOM, store it to destination buffer
<!---->before invoking DecodeUTF8.
<br/>If you don't like replacement characters (usually displayed as little squares
<kbd>&#xfffd;</kbd>), filter them out in CallbackProc.</blockquote></dd>
<dt>Documented</dt><dd> <a class="EXTL" href="../eadoc/links.htm#UTF8">[UTF8]</a>,
<a class="EXTL" href="../eadoc/links.htm#UTF16">[UTF16]</a>,
<a class="EXTL" href="../eadoc/links.htm#UTF32">[UTF32]</a></dd>
<dt>Input</dt><dd><b>Source</b> is pointer to the first byte of UTF8-encoded string.
<br/><b>Size=</b> -1 is the maximal possible size of source string in bytes.
<!---->It may be left on default when the Source string is terminated with NUL byte
<!---->(this NUL is not written to output).
<br/>If Size is not -1, exactly that many input bytes are decoded, including NUL bytes.
<br/><b>Width=</b>16 or 32 specifies the output encoding UTF-16 or UTF-32, respectively.
<br/><b>CallbackProc</b> is pointer to the procedure which stores one converted character.
<dl><dt>CallbackProc</dt><dd>is called with <em>register calling convention</em>.
<br/>It is expected to store the UTF-16 or UTF-32 character obtained in EAX and return with CF=0.</dd>
<dt>Input</dt><dd><b>CF=DF=0</b>
<br/><b>EAX=</b> one converted character encoded in UTF-16 or UTF-32.
<br/>EAX may contain surrogate code <code>0x0000_D800..0x0000_DFFF</code> when the input UTF-8 character
<!---->belongs to Unicode supplementary planes (Emoji, Asian characters etc).
<br/>EAX may also contain the replacement <code>0x0000_FFFD</code> when the input UTF-8 string is malformed.
<br/><b>EBP=</b> original value of EBP on input to the macro.
<!---->Usually it is the frame pointer of the function which expanded DecodeUTF8,
<!---->thus arguments and local variables of the function can be used in CallbackProc.
<br/><b>EDI=</b> original value of EDI on input to the macro. It may be used in STOS,
<!---->incremented value of EDI will be supplied on the next invocation of CallbackProc.
<br/><b>EBX,ECX,EDX,ESI</b> should be considered undefined.</dd>
<dt>Output</dt><dd><b>CF=</b>0 when a character from EAX was successfully stored to destination
<!---->buffer by CallbackProc and macro should continue with parsing the next UTF-8 characters.
<br/><b>CF=</b>1 signalizes that the macro should cancel further conversion.
<!---->CF propagates to the output of DecodeUTF8.
<br/>EAX,EBX,ECX,EDX,ESI,EDI may be changed in Callback procedure. The value of
<br/><b>EDI</b> will be saved and provided in the next call of CallbackProc,
<!---->thus EDI can be used in CallbackProc as an output pointer for decoded data.</dd>
</dl></dd>
<dt>Output</dt><dd><b>CF=0, ECX=</b>number of unprocessed bytes at the end of text (0..3)
<!---->due to incompleteness of the last UTF-8 character in input text block.
<!---->The caller of DecodeUTF8 should seek the input file by ECX bytes back
<!---->before reading the next block of text.
<br/><b>EDI=</b> as returned from CallbackProc. <br/>All other registers are preserved.
</dd>
<dt>Example</dt><dd class="PRE">       MOV EDI,DestString ; It should be long enough for the decoded string.
<!---->       DecodeUTF8 SourceString, Store:
<!----> Store:PROC1  ; Thanks to using PROC1 instead of PROC it doesn't need bypass by JMP.
<!---->        STOSW ; Store UTF-16 character from AX and advance EDI to the next free room.
<!---->        RET   ; Return to DecodeUTF-8 macro with CF=0.
<!---->       ENDPROC1 Store:
<!---->       SUB EAX,EAX
<!---->       STOSW ; Zero-terminate DestString. Now it can be used in TextOutW, MessageBoxW etc.
</dd></dl>
<pre>
DecodeUTF8 %MACRO Source, CallbackProc, Size=-1, Width=16
    %IF %Width != 16 && %Width != 32
      %ERROR ID=5932,'Macro "DecodeUTF8" requires Width=16 or Width=32.'
      %EXITMACRO DecodeUTF8
    %ENDIF
    PUSHD %Width, %Size, %CallbackProc, %Source
    CALL DecodeUTF8@RT:
DecodeUTF8@RT: PROC1
    PUSHAD
      SUB ECX,ECX
      MOV [ESP+24],ECX  ; Initialize %ReturnECX to 0.
      MOV EDI,[ESP+36]  ; %Source.
      MOV ECX,[ESP+44]  ; %Size.
      MOV ESI,EDI
      MOV EAX,ECX
      INC EAX
      JZ .Scan:         ; If Size=-1, EAX=0 and the Source size will be scanned.
      LEA EDI,[ESI+ECX] ; Otherwise use the explicit %Size.
      JMP .No0:
.Scan:REPNE:SCASB
      JNE .No0:
      DEC EDI          ; Omit the terminator from conversion.
.No0: ; Source string without NUL is now at ESI..EDI.
 BOM  %FOR 0xEF,0xBB,0xBF ; Little-Endian BOM (<code>0xFEFF</code>) encoded in UTF-8.
        CMP ESI,EDI
        JNB .NoBOM:
        LODSB
        CMP AL,%BOM
        JNE .NoBOM:
      %ENDFOR BOM
      JMP .Start:       ; BOM was detected, ESI is advanced just behind it.
.NoBOM:MOV ESI,[ESP+36] ; No BOM detected, restore ESI to the start of Source again.
.Start:CMP ESI,EDI
      JNB .End:
      XOR EBX,EBX
      LODSB
      MOV BL,AL
      NOT BL
      BSR ECX,EBX ; Scan bits 7..0 of inverted first byte of 1,2,3,4 bytes long UTF-8 character.
      MOV BL,AL   ; First byte of 1,2,3,4 bytes long UTF-8 character (not inverted).
      MOV DL,0x7F ; Prepare mask for payload bits in the 1st UTF-8 byte.
      SUB ECX,7   ; ECX=7,5,4,3 change to ECX=0,-2,-3,-4.
      JZ .Out:    ; When EBX is codepoint 0..0x7F (7bit ASCII character).
      NEG ECX     ; ECX=2,3,4 (number of bytes in UTF-8 character).
      SHR DL,CL   ; DL=0x1F,0x0F,0x07 is payload mask.
      AND BL,DL   ; EBX will accumulate payload bits of codepoint.
      CMP CL,2
      JB .Bad:
      CMP CL,4
      JBE .Good:
.Bad: MOV EAX,0xFFFD ; Invalid UTF-8 detected, output the replacement.
      JMP .NoSg:
.Good:DEC ECX     ; ECX=1, 2 or 3 continuation bytes expected.
      LEA EAX,[ESI+ECX]
      CMP EAX,EDI ; Check if there's that many input bytes left.
      JBE .Cont:
      DEC ESI     ; Rollback, the last UTF-8 character is incomplete.
      SUB EDI,ESI ; EDI characters (1..3) were not decoded.
      MOV [ESP+24],EDI ; %ReturnECX.
      JMP .End:   ; CF=0.

.OutEAX: ; PROC1             ; Send EAX to callback. Preserves EBX,ESI,EDI, updates ReturnEDI.
          PUSH EBX,ESI,EDI
            MOV EDI,[ESP+16]  ; ReturnEDI restore.
            CALL [ESP+56]     ; CallbackProc.
            MOV [ESP+16],EDI  ; ReturnEDI update.
          POP EDI,ESI,EBX
          RET
       ; ENDPROC1 .OutEAX:

.Cont:LODSB       ; Continuation byte AL=10xxxxxxb expected.
      BTR EAX,7   ; Reset the marker bit 7.
      JNC .Bad:
      BTR EAX,6
      JC .Bad:
      SHL EBX,6   ; Make room in EBX for the next 6 bits.
      OR  BL,AL   ; Accumulate them.
      DEC ECX
      JNZ .Cont:
.Out: MOV EAX,EBX ; EAX=EBX is now the decoded codepoint 0..0x10_FFFF.
      ; Check for overlong encodings. DL=0x7F,0x1F,0x0F,0x07 for 1,2,3,4 bytes in UTF-8 character.
      CMP EBX,0x01_0000   ; Codepoint 0x01_0000..0x10_FFFF should be encoded in 4 bytes.
      JAE .NoOverlong:
      CMP EBX,0x00_0800   ; Codepoint 0x00_0800..0x00_FFFF should be encoded in 3 bytes.
      JB .2Bts:
      CMP DL,0x0F
      JE  .NoOverlong:
      JMP .Bad:
.2Bts:CMP EBX,0x00_0080   ; Codepoint 0x00_0080..0x00_07FF should be encoded in 2 bytes.
      JB .1Bts:
      CMP DL,0x1F
      JE .NoOverlong:
      JMP .Bad:
.1Bts:CMP DL,0x7F         ; Codepoint 0x00_0000..0x00_007F should be encoded in 1 byte.
      JE .NoOverlong:
      TEST EBX
      JNZ .Bad:
      CMP DL,0x1F         ; Exception: codepoint 0 may be encoded in 1 or 2 bytes.
      JNE .Bad:
.NoOverlong:
      SHR EBX,11          ; Check for surrogate codepoints.
      CMP BL,0x1B
      JE .Bad:            ; Do not accept surrogates 0xD800..0xDFFF from input.
      TEST BX,0x3E0
      JZ .NoSg:           ; If codepoint EAX is below 0x0001_0000, surrogates do not apply.
      CMPD [ESP+48],16    ; Output UTF %Width (16 or 32).
      JNE .NoSg:          ; UTF-32 does not need surrogates.
      SUB EAX,0x0001_0000 ; Codepoint EAX was not encodable in one UTF-16 character.
      MOV EBX,0x0000_03FF ; Use two surrogate Unichars.
      AND EBX,EAX
      SHR EAX,10
      ADD EBX,0x0000_DC00 ; EBX is now low surrogate.
      ADD EAX,0x0000_D800 ; EAX is now high surrogate.
      CALL .OutEAX:       ; High surrogate first.
      MOV EAX,EBX         ; Low surrogate.
      JC .End:            ; If aborted by CallbackProc.
.NoSg:CALL .OutEAX:       ; Low surrogate or BMP codepoint or UTF-32.
      JNC .Start:         ; Parse the next UTF-8 character from the string ESI..EDI.

.End:POPAD
     RET 4*4
   ENDP1 DecodeUTF8@RT:
 %ENDMACRO DecodeUTF8
</pre>

<dl id="EncodeUTF8"><dt><a href="#top">EncodeUTF8</a></dt>
<dd><p>Macro <dfn>EncodeUTF8</dfn> converts a codepoint to an UTF-8 character and stores it into the string at EDI.</p></dd>
<dt>Documented</dt><dd> <a class="EXTL" href="../eadoc/links.htm#UTF8">[UTF8]</a></dd>
<dt>Input</dt><dd><b>EAX</b> is the converted codepoint (ordinal number of the character in UNICODE chart) in the range 0..0x1F_FFFF.
<br/><b>DF=0, EDI</b> is pointer to the output string. It will be incremented with each stored byte.</dd>
<dt>Output</dt><dd><b>DF=0, EDI=</b> increased by the number of stored bytes (1..4).
<br/>All other registers are preserved.</dd>
<dt>Example</dt><dd class="PRE">       MOV EDI,DestStringUtf8 ; It should be long enough for the decoded string.
<!---->       MOV ESI,InputStringUtf16
<!---->Again: MOVZXW EAX,[ESI]
<!---->       CMP  AX,0
<!---->       JZ End
<!---->       EncodeUTF8
<!---->       JMP Again:
</dd></dl>
<pre>
EncodeUTF8 %MACRO
     CALL EncodeUTF8@RT:
EncodeUTF8@RT: PROC1
     CMP EAX,0x0000_0080
     JAE .10:
     STOSB
     RET
.10: PUSH EAX,ECX
      MOV ECX,EAX
      CMP EAX,0x0000_0800
      JAE .30:
      SHR EAX,6
      OR AL,0xC0
.20:  STOSB
      MOV EAX,ECX
      AND AL,0xBF
      OR AL,0x80
      STOSB
     POP ECX,EAX
     RET
.30:  CMP EAX,0x0001_0000
      JAE .40:
      XCHG AL,AH
      SHR AL,4
      OR AL,0xE0
      STOSB
      MOV EAX,ECX
      SHL EAX,2
      XCHG AL,AH
      AND AL,0xBF
      OR  AL,0x80
      JMP .20:
.40:  SHR EAX,18
      AND AL,0xF7
      OR AL,0xF0
      STOSB
      MOV EAX,ECX
      SHR EAX,12
      AND AL,0xBF
      OR AL,0x80
      STOSB
      MOV EAX,ECX
      SHR EAX,6
      AND AL,0xBF
      OR AL,0x80
      JMP .20:
    ENDP1 EncodeUTF8@RT:
   %ENDMACRO EncodeUTF8
</pre>

<pre>
  ENDHEAD string32
</pre>
<!--TAILMENU-->
<!--Contents below the marker {!==TAILMENU==} was generated by "generate.php".-->
<br class='CLEAR'/><a id='bottom' href='#top'>&#x25B2;Back to the top&#x25B2;</a>
</body></html>
