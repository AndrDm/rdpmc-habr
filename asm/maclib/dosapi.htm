<!doctype html><html lang='en'><head>
<meta http-equiv='Content-Type' content='text/html; charset=utf-8'/>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=2.0, user-scalable=yes'>
<meta name='robots' content='ALL,FOLLOW'/>
<meta name='description' content='dosapi.htm macro library'/>
<meta name='version' content='20250318'/>
<meta name='author' content='Pavel vitsoft Šrubař'/>
<link rel='stylesheet' href='../euroasm.css' type='text/css'/>
<link rel='shortcut icon' href='../favicon.ico'/>
<title>dosapi.htm macro library</title>
</head>
<body class='MACLIB' id='top'><div class='HEADMENU'><table>
<tr><td rowspan='2' title='&euro;ASM - assembler and linker'><img src='../favicon.ico' alt='EuroAssembler' />
<td><a href='../index.htm' title='Alphabetical index of all &euro;ASM elements, directives and instructions'>Index</a></td>
<td><a href='../eadoc/' class='EADOC' title='Documentation of EuroAssembler'>Manual</a></td>
<td><a href='https://euroassembler.eu/download/' title='History &amp; download of the latest and previous versions'>Download</a></td>
<td><a href='../easource/' class='EASOURCE' title='Source files of EuroAssembler itself'>Source</a></td>
<td><a href='../maclib/' class='MACLIB' title='Macro libraries shipped with &euro;ASM'>Macros</a></td>
<td rowspan='2' title='Find the searched token in any text file on this site'>
<form method='post' action='../search.php' enctype='multipart/form-data' accept-charset='utf-8'>
<input type='text' id='q' placeholder='Searched word(s)' name='q' value=''/>
<br/><label title='Check the box to find the expression even if it is surrounded by other letters | digits.'>
<input type='checkbox' name='EW'/><small>Embedded word</small></label>
<br/><label title='Check the box for case-insensitive search.'>
<input type='checkbox' name='CI'/><small>Case ins.</small></label>
<input type='submit' title='Search for the specified word|expression in all site files.' name='find' value='Search'/>
</form></td></tr><tr>
<td><a href='../sitemap.htm' title='List of directories and files on this site'>Sitemap</a></td>
<td><a href='../eadoc/links.htm' class='EADOC' title='References and external links to resources used in EuroAssembler developement'>Links</a></td>
<td><a href='https://euroassembler.eu/forum/' title='Discussion forum concerning EuroAssembler'>Forum</a></td>
<td><a href='../eatests/' class='EATESTS' title='Program snippets for testing the function of &euro;ASM'>Tests</a></td>
<td><a href='../objlib/' class='OBJLIB' title='Skeletons and sample objects and projects shipped with &euro;ASM'>Projects</a></td>
</tr></table></div>
<!--Contents above the marker {!==/HEADMENU==} was generated by "generate.php".-->
<!--/HEADMENU-->
<h1>dosapi.htm
<br/><i>Enumerations</i>
<br/><a href="#pcStdCall16">%StdCall16</a>
<br/><i>Macros</i>
<br/><a href="#DosAPI">DosAPI</a>
<br/><a href="#GetArg">GetArg</a>
<br/><a href="#GetArgCount">GetArgCount</a>
<br/><a href="#GetEnv">GetEnv</a>
<br/><a href="#StdInput">StdInput</a>
<br/><a href="#StdOutput">StdOutput</a>
<br/><a href="#TerminateProgram">TerminateProgram</a>
<br/><a href="#TerminateStayResident">TerminateStayResident</a>
</h1>
<p><p>This file can be included to <strong>16bit DOS</strong> programs written in EuroAssembler.
<br/>It declares macroinstructions for interaction with
<em>Disk Operation System</em> - <dfn>DOS</dfn>.</p>
<p>DOS services run in 16bit real CPU mode.</p>
<br clear="all"><pre>
dosapi HEAD  ; Start of interface block includable to other programs.
       INCLUDEHEAD1 "cpuext.htm", "status16.htm"
</pre>
<dl id="pcStdCall16"><dt><a href="#top">&uarr; %StdCall16</a></dt>
<dd>This assignments define preprocessing %variables useful to refer stack frame in 16bit StdCall calling convention.</dd>
<dt>Example</dt><dd class="PRE">         PUSH Factor3,Factor2,Factor1
<!---->         CALL Multiply            ; Calculate product.
<!---->         ; Do something with product in DX:AX.
<!---->Multiply PROC1 ; Return product of three pushed factors in DX:AX. CF=overflow.
<!---->          PUSHAW
<!---->           MOV BP,SP
<!---->           MOV AX,[%Par1]         ; AX=Factor1
<!---->           MUL [%Par2],DATA=WORD  ; DX:AX=Factor1 * Factor2
<!---->           JC .Overflow:
<!---->           MUL [%Par3],DATA=WORD  ; DX:AX=Factor1 * Factor2 * Factor3
<!----> .Overflow:MOV [%ReturnAX],AX
<!---->           MOV [%ReturnDX],DX
<!---->          POPAW
<!---->          RET 3*2                 ; Discard three pushed factors.
<!---->         ENDPROC1 Multiply
</dd></dl><pre>
 %Par4     %SET BP+24
 %Par3     %SET BP+22
 %Par2     %SET BP+20
 %Par1     %SET BP+18
 %ReturnAX %SET BP+14
 %ReturnCX %SET BP+12
 %ReturnDX %SET BP+10
 %ReturnBX %SET BP+08
 %ReturnSP %SET BP+06
 %ReturnBP %SET BP+04
 %ReturnSI %SET BP+02
 %ReturnDI %SET BP+00
</pre>

<dl id="DosAPI"><dt><a href="#top">&uarr; DosAPI</a> INT=21h, reg1=value1, reg2=value2,,,</dt>
<dd>Macro <dfn>DosAPI</dfn> provides interaction with Disk Operation System (DOS),
<!---->with the help of software-called interruptions.</dd>
<dt>Documented</dt><dd><a class="EXTL" href="../eadoc/links.htm#IntList">[IntList]</a></dd>
<dt>Input</dt><dd><b>INT=</b> is the interrupt number, if other than 0x21.
<br/><b>regX=valueX</b>. Arbitrary number of keyword parameters can be specified
<!---->and the corresponding 8bit or 16bit general-purpose or segment register
<!---->will be loaded with its specified value before the interrupt is called.
<br/>Registers are loaded in the order as specified in the macro invocation.
<br/>Names of registers and the INT= keyword are case-sensitive but both uppercase or lowercase may be used.</dd>
<dt>Output</dt><dd>Values returned from interrupt service are defined in the documentation.</dd>
<dt>Error</dt><dd>As specified in the documentation.</dd>
<dt>Examples</dt>
<dd class="PRE">    LDS DX,[NewTimerHandlerFarProc]
<!---->    DosAPI AH=0x25,AL=8 ; Set new vector DS:DX for interrupt 8.
<!---->  ; DosAPI AX=0x2508    ; This equivalent invocation is 1 byte shorter.</dd>
<dt>See also</dt><dd><a class="EXT" href="biosapi.htm#BiosAPI">BiosAPI</a></dd>
</dl><pre>
DosAPI %MACRO INT=21h, \
        AL=,AH=,CL=,CH=,DL=,DH=,BL=,BH=,AX=,CX=,DX=,BX=,BP=,SP=,SI=,DI=,DS=,ES=, \
        al=,ah=,cl=,ch=,dl=,dh=,bl=,bh=,ax=,cx=,dx=,bx=,bp=,sp=,si=,di=,ds=,es=
%intNr  %SET 0x21     ; Interrupt <kbd>0x21</kbd> will be used if not specified otherwise.
%kwlength %SETA %=#   ; %kwlength is now the number of keyword operands in DosAPI invocation.
k   %FOR 1..%kwlength ; Loop through all keyword operands in DosAPI invocation.
%kw     %SET %=*{%k}  ; %kw is now something like <kbd>AH=5</kbd> or <kbd>INT=21h</kbd>.
%kwsize %SETS %kw     ; Number of characters in keyword operand %kw.
%key    %SET          ; Split the operand by = to %key and %value. Start with empty %key.
%i      %SETA 1       ; Start with the 1st character.
        %REPEAT
          %IF "%kw[%i]" === "="
            %EXITREPEAT           ; Equal-sign found, the split is done.
          %ELSE
            %key %SET %key%kw[%i] ; Append the %i-th character and continue.
            %i %SETA %i + 1
          %ENDIF
        %UNTIL %i > %kwsize
        %value %SET %kw[%i+1..%&]
        %IF "%key" == "INT"
          %intNr %SET %value ; Save the interrupt number for later to the variable %intNr.
        %ELSE
          %IF "%key"==="" || "%value"===""
             %ERROR ID=5910,'Bad parameter "%key=%value", ignored.'
          %ELSE
            %IF "%key" !== "%value"
              MOV %key,%value ; Emit the instruction which loads the register %key.
            %ENDIF
          %ENDIF
        %ENDIF
    %ENDFOR k                ; Process the next keyword operand.
    INT %intNr               ; Finally emit the DOS service call.
  %ENDMACRO DosAPI
</pre>


<dl id="GetArg"><dt><a href="#top">&uarr; GetArg</a> &nbsp; ArgNumber</dt>
<dd><p>Macro <dfn>GetArg</dfn> retrieves ArgNumber-th parameter provided on command line.
<br/>Parameters on the command line may be separated with unquoted
<!---->white spaces or unquoted commas. Single aphostrophe cannot be used as quote.</p>
<p>The returned argument is not zero terminated.
<!---->Quotes surrounding the argument are returned, too, but separating
<!---->white spaces and commas are stripped off.</p>
<p>Runtime procedure GetArg@RT is also used in macro <a href="#GetArgCount">GetArgCount
</a>, its functionality is controlled by the ArgNumber parameter.</p></dd>
<dd><blockquote>Dump of PSP:80h when the DOS program launched with parameters
<code>/1 "2"</code>:</blockquote></dd>
<dd class="PRE"><blockquote>07 20 2F 31 20 22 32 22 0D
<!---->       /  1     "  2  " CR </blockquote></dd>
<dd><blockquote>Dump of PSP:80h when the DOS program launched without parameters:</blockquote></dd>
<dd class="PRE"><blockquote>00 0D
<!---->   CR </blockquote></dd>
<dt>Input</dt><dd><b>ArgNumber</b> is ordinal number (1..254) of the required
<!---->command-line parameter. It can also be provided in 16bit register or memory variable.
<blockquote>ArgNumber=-1 is a special case when this macro is used by
<a href="#GetArgCount">GetArgCount</a> and it returns number of arguments in AX
<!---->instead of argument string in ES:SI,CX.</blockquote>
<b>ES=</b> is paragraph address of <a class="EXT" href="doss.htm#PSP">PSP
</a>, as it was set when DOS program starts.</dd>
<dt>Output</dt><dd><b>CF</b>=0,
<br/><b>SI</b> is offset of the first byte of argument in PSP segment ES,
<br/><b>CX</b> is the size of argument in bytes. CX=0 when the argument is empty (white spaces only).</dd>
<dt>Error</dt><dd><b>CF</b>=1 bad syntax - odd number of quotes.
<br/><b>CX=</b>0,
<br/><b>SI=</b> unchanged.</dd>
<dt>Example</dt><dd class="PRE">CmdLine:    <abbr>/C "file1", "file2" --help</abbr>
<!---->GetArg 4:   &#x2502;  &#x2502;        &#x2502;       &#x2514;SI CX=6
<!---->GetArg 3:   &#x2502;  &#x2502;        &#x2514;SI CX=7
<!---->GetArg 2:   &#x2502;  &#x2514;SI CX=7
<!---->GetArg 1:   &#x2514;SI CX=2 AX=1</dd>
<dt>See also</dt><dd><a href="#GetArgCount">GetArgCount</a></dd>
</dl><pre>
GetArg %MACRO ArgNumber
        PUSHW %ArgNumber
        CALL GetArgDos16@RT
GetArgDos16@RT:: PROC1
   PUSHAW
    MOV BP,SP
    SUB AX,AX      ; AL will be the parsed character.
    SUB CX,CX      ; CX is argument counter.
    MOV [%ReturnCX],CX
    MOV SI,0x80    ; Offset of <kbd>PSP.CmdArgSize</kbd> byte.
    CLD
    LODSB [ES:SI]  ; ES is paragraph address of PSP.
    MOV DX,SI
    MOV BX,SI
    ADD DX,AX      ; ES:DX now points to the CR which terminates command-line parameters.
.10:MOV DI,SI
    CMP CX,[%Par1] ; %Par1 is the number of requested argument.
    JAE .50:
.20:CMP SI,DX      ; End of command-line reached?
    JNB .50:       ; If no more arguments are available.
    LODSB [ES:SI]
    CMP AL,' '
    JBE .20:       ; Ignore the separator (space).
    DEC SI
    INC CX
    MOV BX,SI      ; BX points to the brutto begining of CX-th argument.
    MOV DI,SI      ; DI points to the brutto end of current argument.
.30:CMP SI,DX
    JNB .10:
    LODSB [ES:SI]
    CMP AL,'"'
    JNE .40:
.35:CMP SI,DX
    CMC
    JC .90:        ; CF signalizes syntax error - unpaired quotes.
    LODSB [ES:SI]
    CMP AL,'"'
    JNE .35:       ; Inside the quoted string.
    JMP .30:
.40:CMP AL,','
    JE .10:
    CMP AL,' '
    JA .30:
.45:CMP SI,DX
    JNB .10:
    LODSB [ES:SI]
    CMP AL,' '
    JNA .45:
    CMP AL,','
    JE .10:
    DEC SI
    JMP .10:        ; Parse the next argument.
.50:CMPW [%Par1],-1 ; Test if invoked from GetArgCount with ArgNr= -1.
    JNE .60:
    MOV [%ReturnCX],CX
    JMP .80:
.60:CMP CX,[%Par1]
    STC
    JNE .90:
    MOV SI,BX      ; Brutto CX-th argument found at SI..DI. Trim spaces and commas.
.65:CMP SI,DI
    JNB .75:
    LODSB [ES:SI]
    CMP AL,' '
    JBE .65:
    CMP AL,','
    JE .65:
    DEC SI
.70:DEC DI
    MOV AL,[ES:DI]
    CMP AL,' '
    JBE .70:
    CMP AL,','
    JE .70:
    INC DI         ; Netto argument is now at SI..DI.
.75 MOV [%ReturnSI],SI
    SUB DI,SI
    JC .80:        ; Return CX=0 when the netto size is not positive.
    MOV [%ReturnCX],DI
.80:CLC
.90:POPAW
   RET 2
  ENDPROC1 GetArgDos16@RT::
 %ENDMACRO GetArg
</pre>

<dl id="GetArgCount"><dt><a href="#top">&uarr; GetArgCount</a></dt>
<dd>This macro counts arguments provided on the command line of the executed program.
<br/>Arguments may be separated with unquoted spaces or unquoted commas.
<!---->Multiple white-space separators are treated like a single space.
<!---->Single apostrophe cannot be used as a quote.</dd>
<dt>Input</dt><dd><b>ES=</b> is paragraph address of <a class="EXT" href="doss.htm#PSP">PSP
</a>, as it was set when DOS program starts.</dd>
<dt>Output</dt><dd><b>CF=</b>0,
<br/><b>CX</b>=number of arguments on the command line which launched the program.
<dt>Error</dt><dd><b>CF</b>=1 bad syntax of arguments,
<br/><b>CX=</b>0.</dd>
<dt>Depends on</dt><dd><a href="#GetArg">GetArg</a></dd>
<dt>Example</dt><dd>All examples of the command lines below will return ArgCount=4.
<div class="PRE"> Program.exe arg1 arg2 arg3 arg4
<!----> Program.exe "arg1",arg2 "arg3" arg4
<!----> Program.exe arg1,arg2, "arg3,arg3" "arg4</div></dd>
</dl><pre>
GetArgCount %MACRO
     GetArg -1
   %ENDMACRO GetArgCount
</pre>


<dl id="GetEnv"><dt><a href="#top">&uarr; GetEnv</a> &nbsp; EnvNamePtr, Size=-1</dt>
<dd><p>Macro <dfn>GetEnv</dfn> retrieves value of environment-variable with specified name
<em>EnvName</em> at run-time. The zero-terminated value is returned in ES:SI,CX.
<br/>Requested name should be in <strong>upper case</strong> and either zero-terminated,
<!---->or its EnvNameSize= explicitly specified.</p>
<blockquote>Environment variables in DOS are stored in segment identified by current process' PSP at
<a class="EXT" href="doss.htm#PSP">PSP.EnvSeg</a> in the format <code>EnvName=EnvValue
</code> where each definition is zero-terminated and one more zero (NULL character)
<!---->terminates the whole array of ASCIIZ environment strings.
<br/>Remember that most DOS versions convert all environment names to uppercase.
<br/>In TINY COM programs are all segment registers permanently set to PSP.
<!---->In DOS programs are DS and ES set to PSP when the executable MZ program starts,
<!---->this value should be provided to the macro GetEnv in register ES.</blockquote>
</dd>
<dt>Input</dt><dd><b>DS=</b> is segment (paragraph address) of EnvName.
<br/><b>ES=</b> is segment (paragraph address) of <a class="EXT" href="doss.htm#PSP">PSP
</a>, as it was set when DOS program started.
<br/><b>EnvNamePtr</b> offset in DS of environment-variable name (in upper case).
<br/><b>Size=-1</b> netto size of EnvName in bytes. If this keyword argument is omitted,
<!---->EnvName must be zero-terminated.
</dd>
<dt>Output</dt><dd><b>CF=0</b>
<br/><b>ES=</b>segment of environment strings (different from PSP),
<br/><b>SI=</b>offset in ES of environment variable value, NULL-terminated,
<br/><b>CX=</b>size of environment variable value in bytes without the terminating NULL,
</dd>
<dt>Error</dt><dd><b>CF=1</b> when the variable EnvName was not found in environment.
<br/><b>ES=</b>segment of environment strings (different from PSP),
<br/><b>SI=</b>0,
<br/><b>CX=0</b>.</dd>
<dt>Example</dt><dd class="PRE">; SMALL MZ program to show environment variable specified as argument %1:
<!---->ShowEnv PROGRAM Format=MZ,Entry=Start:
<!---->          INCLUDE dosapi.htm
<!---->Start:    GetArg 1             ; Return 1st argument (EnvName) in ES:SI,CX.
<!---->          JCXZ .NotFound:      ; If no EnvName was specified on command-line.
<!---->          StdOutput SI,Size=CX,Eol=Yes ; Echo the argument (EnvName). Assume DS=SEGMENT# PSP.
<!---->          GetEnv SI,Size=CX    ; Value of EnvName ES:SI,CX is returned in ES:SI,CX.
<!---->          JC .NotFound:
<!---->          PUSH ES
<!---->          POP DS               ; Load DS with environment segment ES.
<!---->          StdOutput SI,Eol=Yes ; Display ASCIIZ string DS:SI (env.value) on console.
<!---->          TerminateProgram Errorlevel=0
<!---->.NotFound:PUSH PARA# [DATA]    ; Segment of data (literals).
<!---->          POP DS
<!---->          StdOutput =B" was not found in environment.",Eol=Yes
<!---->          TerminateProgram Errorlevel=4
<!---->        ENDPROGRAM ShowEnv
</dd>
<dt>Tested by</dt><dd><a class="EXT" href="../prodos16/tdosapi.htm">tdosapi.htm</a></dd>
</dl><pre>
GetEnv %MACRO EnvNamePtr, Size= -1
         PUSHW %Size, %EnvNamePtr
         CALL GetEnvDos16@RT::
GetEnvDos16@RT:: PROC1
          PUSHAW
           MOV BP,SP
           MOV ES,[ES:0x002C]  ; <a class="EXT" href="doss.htm#PSP">PSP.EnvSeg</a>.
           MOV SI,[%Par1]      ; EnvNamePtr.
           MOV DX,[%Par2]      ; EnvNameSize.
           MOV BX,SI
           SUB DI,DI
           SUB AX,AX           ; AL=NULL.
           CLD
           JMPS .20:
.10:       MOV CX,-1           ; Try the next string.
           REPNE SCASB [ES:DI] ; Search for the terminating NULL.
           CMP AL,[ES:DI]      ; Second NULL terminates the whole set of environment strings.
           MOV CX,AX           ; Zero in case that EnvName was not found.
           MOV [%ReturnSI],AX  ; Zero in case that EnvName was not found.
           STC
           JZ .90:             ; End of the set of strings, CX=SI=0, CF=1, nothing found.
.20:       MOV SI,BX           ; EnvNamePtr.
           MOV CX,DX           ; EnvName Size. DS:SI is EnvName, max CX bytes or terminated with NULL.
           REPE CMPSB          ; ES:DI is <code>name=value</code>, perhaps the desired one.
           JCXZ .30:           ; If EnvNameSize was specified, omit the check on terminating NULL.
           DEC DI
           CMP [DS:SI-1],AL
.30:       JNE .10:
           CMPB [ES:DI],'='
           JNE .10:
           INC DI
           MOV [%ReturnSI],DI  ; EnvName was found, ES:DI is pointer to its value.
           MOV CX,-1
           REPNE SCASB [ES:DI] ; Find the size of ASCIIZ value ES:DI.
           NOT CX
           DEC CX
.90:       MOV [%ReturnCX],CX
          POPAW
          RET 2*2
         ENDP1 GetEnvDos16@RT::
       %ENDMACRO GetEnv
</pre>

<dl id="StdOutput"><dt><a href="#top">&uarr; StdOutput</a> String1, String2,,, Size=-1, Handle=1, Eol=No</dt>
<dd><p>Macro <dfn>StdOutput</dfn> writes one or more concatenated strings to the standard output
<!---->or to other equipment identified by the DOS device Handle number.</p>
<p>Strings are either zero-terminated, or the keyword
<code>Size=</code> must specify their size in bytes. The terminating NULL character is never written.</p>
<p>If keyword <code>Eol=Yes</code>, macro writes CR+LF after all strings.</p>
<dt>Input</dt><dd><b>DS=</b> segment of all strings.
<br/><b>StringX</b> is offset of (ASCIIZ) string of 8byte characters. Its segment is DS.
<br/><b>Size=</b>-1 is the maximal possible string size. If its left to -1 (default),
<!---->strings must be zero-terminated. This parameter applies to all ordinal operads.
<br/><b>Handle=</b>1 is the number of device handle for the output. Standard output handles are<ul>
<li>1=StdOutput (console screen),</li>
<li>2=StdError  (nonredirectable console screen),</li>
<li>3=StdAux    (auxilliary output, serial port COM1),</li>
<li>4=StdPrn    (line printer, paralel port LPT1).</li></ul>
<b>Eol=</b>No. If Yes, two additional characters CR and LF will be written on output
<!---->after all strings have been written.</dd>
<dt>Output</dt><dd><b>CF=</b>0</dd>
<dt>Error</dt><dd><b>CF=</b>1</dd>
<dt>Depends on</dt><dd><a href="#DosAPI">DosAPI</a></dd>
<dt>Examples</dt>
<dd class="PRE">   StdOutput Message, Eol=Yes
<!---->   StdOutput Eol=Yes ; Write new line (CR+LF) only.
<!---->   StdOutput =B"Page header",=B(12),Handle=4 ; Print header and then eject page from the printer at LPT1.</dd>
</dl><pre>
StdOutput %MACRO String1,String2,,,Size=-1, Handle=1, Eol=No
OpNr %FOR 1..%#, STEP=1
       PUSHW %Handle, %Size, %1
       CALL StdOutputDos16@RT:
       %SHIFT 1
     %ENDFOR OpNr
     %IF %Eol
       PUSHW %Handle, 2, -1
       CALL StdOutputDos16@RT:
     %ENDIF
StdOutputDos16@RT:: PROC1 ; StdCalled with %Par1=StringPtr,%Par2=Size,%Par3=Handle.
   PUSHAW
    MOV BP,SP
    PUSH ES,DS
     POP ES
     MOV DI,[%Par1] ; Pointer to String.
     MOV CX,[%Par2] ; String maximal size.
     MOV BX,[%Par3] ; Standard handle.
     JCXZ .90:
     CMP DI,-1      ; This sginalizes Eol request.
     JE .Eol:
     MOV DX,DI
     SUB AX,AX
     CLD
     REPNE SCASB
     JNE .50:
     DEC DI
.50: SUB DI,DX
     DosAPI AH=0x40,BX=BX,CX=DI,DX=DX ; WRITE TO FILE OR DEVICE.
.80: JC .90:
     CMP AX,CX      ; Set CF in not all characters have been written.
.90:POP ES
    POPAW
   RET 3*2
.Eol:PUSH DS
      PUSH SS
      POP DS
      PUSHW 0x0A0D  ; Temporary store CR+LF on stack.
      DosAPI AH=0x40,BX=BX,CX=CX,DX=SP ; WRITE TO FILE OR DEVICE.
      INC SP,SP     ; Discard CR+LF, preserve CF.
     POP DS
     JMPS .80:
   ENDPROC1 StdOutputDos16@RT::
  %ENDMACRO StdOutput
</pre>


<dl id="StdInput"><dt><a href="#top">&uarr; StdInput</a> Buffer, Size=, Handle=0</dt>
<dd><p>Macro <dfn>StdInput</dfn> reads a line terminated with CR (ASCII 13) from standard input
<!---->or from other equipment identified by the DOS device Handle number.</p>
<dt>Input</dt><dd><b>Buffer</b> is offset of memory where the input line will be stored.
<br/><b>DS=</b> segment of the Buffer.
<br/><b>Size=</b> is the Buffer size. If omitted (default), macro will use SIZE# attribute of the Buffer.
<br/><b>Handle=</b>0 is the number of device handle for the input. Standard input handles are<ul>
<li>0=StdInput  (keyboard),</li>
<li>3=StdAux    (auxilliary input, serial port COM1).</li></ul></dd>
<dt>Output</dt><dd><b>CF=</b>0,
<br/><b>CX=</b>number of bytes actually read and stored to Buffer.</dd>
<dt>Error</dt><dd><b>CF=</b>1,
<br/><b>CX=</b>DOS error code.</dd>
<dt>Depends on</dt><dd><a href="#DosAPI">DosAPI</a></dd>
<dt>Remark</dt><dd>Input from keyboard is terminated with the
<kbd>Enter</kbd> key. CR+LF are stored to Buffer, too.</dd>
<dt>See also</dt><dd><a href="#DosAPI">DosAPI AX=0x3301</a> how to abort the input by <kbd>Ctrl-Break</kbd>.
<br/><a class="EXT" href="biosapi.htm#BiosAPI">BiosAPI INT=0x16</a> for keyboard functions.</dd>
</dl><pre>
StdInput %MACRO Buffer, Size=, Handle=0
    %IF "%Size" === ""
       PUSHW %Handle, SIZE# %Buffer, %Buffer
    %ELSE
       PUSHW %Handle, %Size, %Buffer
    %ENDIF
    CALL StdInputDos16@RT
StdInputDos16@RT:: PROC1 ; StdCalled with %Par1=Buffer,%Par2=Size,%Par3=Handle.
    PUSHAW
      MOV BP,SP
      DosAPI AH=0x3F,BX=[%Par3],DX=[%Par1],CX=[%Par2] ; READ FROM FILE OR DEVICE.
      MOV [%ReturnCX],AX
    POPAW
    RET 3*2
   ENDP1 StdInputDos16@RT::
  %ENDMACRO StdInput
</pre>

<dl id="TerminateProgram"><dt><a href="#top">&uarr; TerminateProgram</a> Errorlevel=0</dt>
<dd>This macro exits from the running DOS program and returns to DOS.
<br/>It also specifies the Errorlevel (plain number 0..255)  which can be used to inform the batch script
<!---->which launched the program whether the it terminated normally or with some error condition.
<br/>Programs in COM format can alternatively terminate with a simple instruction
<code>RETN</code> if registers CS, SS, SP have the same value which they had at the  program entry.</dd>
<dt>Documented</dt><dd><a class="EXTL" href="../eadoc/links.htm#IntList">[IntList]</a></dd>
<dt>Input</dt><dd><b>Errorlevel=</b>0 is immediate byte or 8bit register or memory operand.
<br/>Beside the keyword <code>Errorlevel=</code>, this value may also be specified as an ordinal operand.
<br/>When this argument is omitted, it defaults to 0.</dd>
<dt>Output</dt><dd>is not applicable.</dd>
<dt>Depends on</dt><dd><a href="#DosAPI">DosAPI</a></dd>
<dt>See also</dt><dd><a href="#TerminateStayResident">TerminateStayResident</a></dd>
<dt>Remark</dt><dd>This macro is equivalent to <code> DosAPI AH=0x4C,AL=Errorlevel</code>.</dd>
<dt>Examples</dt>
<dd class="PRE">    TerminateProgram Errorlevel=[WorstErrLevel] ; Keyword value (from memory).
<!---->    TerminateProgram [WorstErrLevel]            ; Ordinal value (from memory).
<!---->    TerminateProgram 8                          ; Immediate value.</dd>
</dl><pre>
TerminateProgram %MACRO Errorlevel=0
     %IF %# = 1   ; If ordinal provided.
        %IF "%1" !== "AL"
          MOV AL,%1
        %ENDIF
     %ELSE        ; Errorlevel is specified as keyword.
        %IF "%Errorlevel" !== "AL"
          MOV AL,%Errorlevel
        %ENDIF
     %ENDIF
     DosAPI AH=0x4C,AL=AL ; TERMINATE WITH RETURN CODE.
    %ENDMACRO TerminateProgram
</pre>

<dl id="TerminateStayResident"><dt><a href="#top">&uarr; TerminateStayResident</a> &nbsp; ResidentParagraphs, Errorlevel=0</dt>
<dd>This macro exits the running DOS program and returns to DOS, but leaves part of its memory allocated (resident).
<br/>It also specifies the Errorlevel (plain number 0..255)  which can be used to inform the batch script
<!---->which launched the program whether it terminated normally or due to some error.</dd>
<dt>Documented</dt><dd><a class="EXTL" href="../eadoc/links.htm#IntList">[IntList]</a></dd>
<dt>Input</dt><dd><b>ResidentParagraphs</b> is the size of resident memory in 16byte paragraphs (OWORDs).
<br/>It may be immediate value or 16bit memory variable or register (preferably DX).
<br/><b>Errorlevel=</b>0 is immediate byte or 8bit register other than DL,DH, or memory operand.
<br/>Beside the keyword <code>Errorlevel=</code>, this value may also be specified as an ordinal operand.
<br/>When this argument is omitted, it defaults to 0.</dd>
<dt>Output</dt><dd>is not applicable.</dd>
<dt>Depends on</dt><dd><a href="#DosAPI">DosAPI</a></dd>
<dt>See also</dt><dd><a href="#TerminateProgram">TerminateProgram</a></dd>
<dt>Remark</dt><dd>This macro is equivalent to <code> DosAPI AH=0x31,AL=Errorlevel,DX=ResidentParagraphs</code>.</dd>
<dt>Examples</dt>
<dd class="PRE">    TerminateStayResident DX,0 ;</dd>
</dl><pre>
TerminateStayResident %MACRO ResidentParagraphs, Errorlevel=0
     %IF "%1" !== "DX"
       MOV DX,%1
     %ENDIF
     %IF %# = 2   ; If two ordinals provided.
       MOV AL,%2
     %ELSE
       MOV AL,%Errorlevel
     %ENDIF
     DosAPI AH=0x31,AL=AL,DX=DX ; TERMINATE AND STAY RESIDENT.
   %ENDMACRO TerminateStayResident
</pre>


<pre>
 ENDHEAD dosapi ; End of interface block.
</pre>

<!--TAILMENU-->
<!--Contents below the marker {!==TAILMENU==} was generated by "generate.php".-->
<br class='CLEAR'/><a id='bottom' href='#top'>&#x25B2;Back to the top&#x25B2;</a>
</body></html>
