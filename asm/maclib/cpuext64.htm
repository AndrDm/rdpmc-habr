<!doctype html><html lang='en'><head>
<meta http-equiv='Content-Type' content='text/html; charset=utf-8'/>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=2.0, user-scalable=yes'>
<meta name='robots' content='ALL,FOLLOW'/>
<meta name='description' content='cpuext64.htm macro library'/>
<meta name='version' content='20250318'/>
<meta name='author' content='Pavel vitsoft Šrubař'/>
<link rel='stylesheet' href='../euroasm.css' type='text/css'/>
<link rel='shortcut icon' href='../favicon.ico'/>
<title>cpuext64.htm macro library</title>
</head>
<body class='MACLIB' id='top'><div class='HEADMENU'><table>
<tr><td rowspan='2' title='&euro;ASM - assembler and linker'><img src='../favicon.ico' alt='EuroAssembler' />
<td><a href='../index.htm' title='Alphabetical index of all &euro;ASM elements, directives and instructions'>Index</a></td>
<td><a href='../eadoc/' class='EADOC' title='Documentation of EuroAssembler'>Manual</a></td>
<td><a href='https://euroassembler.eu/download/' title='History &amp; download of the latest and previous versions'>Download</a></td>
<td><a href='../easource/' class='EASOURCE' title='Source files of EuroAssembler itself'>Source</a></td>
<td><a href='../maclib/' class='MACLIB' title='Macro libraries shipped with &euro;ASM'>Macros</a></td>
<td rowspan='2' title='Find the searched token in any text file on this site'>
<form method='post' action='../search.php' enctype='multipart/form-data' accept-charset='utf-8'>
<input type='text' id='q' placeholder='Searched word(s)' name='q' value=''/>
<br/><label title='Check the box to find the expression even if it is surrounded by other letters | digits.'>
<input type='checkbox' name='EW'/><small>Embedded word</small></label>
<br/><label title='Check the box for case-insensitive search.'>
<input type='checkbox' name='CI'/><small>Case ins.</small></label>
<input type='submit' title='Search for the specified word|expression in all site files.' name='find' value='Search'/>
</form></td></tr><tr>
<td><a href='../sitemap.htm' title='List of directories and files on this site'>Sitemap</a></td>
<td><a href='../eadoc/links.htm' class='EADOC' title='References and external links to resources used in EuroAssembler developement'>Links</a></td>
<td><a href='https://euroassembler.eu/forum/' title='Discussion forum concerning EuroAssembler'>Forum</a></td>
<td><a href='../eatests/' class='EATESTS' title='Program snippets for testing the function of &euro;ASM'>Tests</a></td>
<td><a href='../objlib/' class='OBJLIB' title='Skeletons and sample objects and projects shipped with &euro;ASM'>Projects</a></td>
</tr></table></div>
<!--Contents above the marker {!==/HEADMENU==} was generated by "generate.php".-->
<!--/HEADMENU-->
<h1>cpuext64.htm
<br/><i>Macros</i>
<br/><a href="#Align2Qword">Align2Qword</a>
<br/><a href="#Clear">Clear</a>
<br/><a href="#Compare">Compare</a>
<br/><a href="#CopyTo">CopyTo</a>
<br/><a href="#LodD">LodD</a>
<br/><a href="#LodH">LodH</a>
<br/><a href="#StoD">StoD</a>
<br/><a href="#StoH">StoH</a>
<br/><a href="#StripApostrophes">StripApostrophes</a>
<br/><a href="#StripColons">StripColons</a>
<br/><a href="#StripQuotes">StripQuotes</a>
<br/><a href="#StripSpaces">StripSpaces</a>
</h1>
<p>This file can be included to <b>64bit</b> programs written in Euro Assembler.
<br/> The library contains <b>OS-independent</b> macroinstructions
<!----> with calling convention similar to the standard Intel machine instruction set.
<!----> They mostly pass operands in general-purpose registers and change
<!----> the register contents on return.</p>
<p><strong>Align*</strong> performs alignment at run time,
<br/><strong>Clear, Compare, CopyTo</strong> provide some string operations,
<br/><strong>Lod*</strong> converts numbers from human-readable notation to a binary number,
<br/><strong>Sto*</strong> does the opposite,
<br/><strong>Strip*</strong> trims the string from garbage characters which may surround it.</p>
<p>Similar macros with identical names for different program width are defined in
<a href="cpuext16.htm">cpuext16.htm</a> and
<a href="cpuext32.htm">cpuext32.htm</a>.</p>
<p>See also <a class="EXT" href="cpuext.htm">cpuext.htm</a> for width-indepentent macros.</p>
<br clear="all"><pre>
cpuext64 HEAD
</pre><pre>
; Definition of flags used by macros in this library.
%cpuextMinus    %SETA 0x80
%cpuextSigned   %SETA 0x40
%cpuextAlignL   %SETA 0x20
%cpuextLeading0 %SETA 0x10
%cpuextLowCase  %SETA 0x08
</pre>

<dl id="Align2Qword"><dt><a href="#top">&uarr; Align2Qword</a></dt>
<dd>This inline macro will align the 64bit GPR or contents of memory variable to QWORD value upward.</dd>
<dt>Input</dt><dd><b>Variable</b> is a 32bit register or memory operand.</dd>
<dt>Output</dt><dd>CF=0, other registers unchanged.</dd>
<dt>Examples</dt><dd class="PRE"> Align2Qword RCX
<!----> Align2Qword [QwPointer]</dd></dl>
<pre>
Align2Qword %MACRO Variable
               ADDQ %Variable,  7
               ANDQ %Variable, ~7
            %ENDMACRO Align2Qword
</pre>

<dl id="Clear"><dt><a href="#top">&uarr; Clear</a> Operand, Size=, Filler=0</dt>
<dd>This macro will fill the string in memory at Operand offset with
<!---->the character Filler=. </dd>
<dt>Input</dt><dd><b>Operand</b> is pointer to a memory variable.
<br/><b>Size=</b> specifies number of bytes to fill. By default it is
<code>SIZE# Operand</code>.
<br/><b>Filler=0</b> is QWORD value whose LSB will be used
<!---->to fill the Operand.</dd>
<dt>Output</dt><dd>All registers are preserved.</dd>
<dt>Examples</dt><dd class="PRE"> Clear Buffer1, Filler=" " ; Fill the whole memory variable Buffer1 with spaces.
<!----> Clear RDI, Size=80, Filler=RAX ; Fill the memory at RDI with the contents of AL.</dd></dl><pre>
Clear %MACRO Operand, Size=, Filler=0
        PUSHQ %Operand
        %IF "%Size" !=== ""
          PUSHQ %Size
        %ELSE
          PUSHQ SIZE#(%Operand)
        %ENDIF
        PUSHQ %Filler
        CALL Clear64@RT::
Clear64@RT:: PROC1
    PUSH RAX,RCX,RDX,RDI
      MOV RDX,[RSP+40] ; %Filler.
      MOV ECX,8
.00:  SHRD RAX,RDX,8
      DEC ECX
      JNZ .00: ; Broadcast DL to all bytes or RAX.
      MOV RCX,[RSP+48] ; %Size.
      MOV RDI,[RSP+56] ; %Operand.
      SHR ECX,1
      JNC .10
      STOSB
.10:  SHR ECX,1
      JNC .20
      STOSW
.20:  SHR ECX,1
      JNC .30:
      STOSD
.30:  JRCXZ .90
      REP:STOSQ
.90:POP RDI,RDX,RCX,RAX
    RET 3*8
   ENDP1 Clear64@RT::
%ENDMACRO Clear
</pre>

<dl id="Compare"><dt><a href="#top">&uarr; Compare</a> Data1Ptr, Data1Size, Data2Ptr, Data2Size</dt>
<dd>This macro will compare two data fields (strings) byte per byte.</dd>
<dt>Input</dt><dd><b>Data1Ptr</b> and <b>Data1Size</b> specify the first data field,
<br/><b>Data2Ptr</b> and<b>Data2Size</b> the second one.
<br/>The last parameter (Data2Size) may be omitted and it equals
<!---->to Data1Size in this case.</dd>
<dt>Output</dt><dd><b>ZF</b>=1 if both fields are identical, otherwise ZF=0.
<!---->All registers are preserved, .</dd>
<dt>Examples</dt><dd class="PRE">Compare F1, SIZE# F1, F2, SIZE# F2
<!---->Compare RDI,RSI,RCX</dd> </dl><pre>
Compare  %MACRO Data1Ptr,Data1Size,Data2Ptr,Data2Size
         %IF %# < 3                                                                                ; >
           %ERROR ID=5911, "Macro Compare requires 3 or 4 parameters."
           %EXITMACRO Compare
         %ENDIF
         %IF %# > 3
           PUSHQ %Data2Size,%Data2Ptr,%Data1Size,%Data1Ptr
         %ELSE
           PUSHQ %Data1Size,%Data2Ptr,%Data1Size,%Data1Ptr
         %ENDIF
         CALL Compare64@RT::
Compare64@RT:: PROC1
       PUSH RCX,RSI,RDI
        MOV RSI,[RSP+32] ; %Data1Ptr
        MOV RCX,[RSP+40] ; %Data1Size
        MOV RDI,[RSP+48] ; %Data2Ptr
        CMP RCX,[RSP+56] ; %Data2Size
        JNE .90:
        REPE:CMPSB
   .90:POP RDI,RSI,RCX
       RET 4*8
  ENDP1 Compare64@RT::
%ENDMACRO Compare
</pre>

<dl id="CopyTo"><dt><a href="#top">&uarr; CopyTo</a> Destination, Source, Size=</dt>
<dd>This macro will copy the memory content from Source to Destination.</dd>
<dt>Input</dt><dd><b>Destination</b> is a pointer to target memory.
<br/><b>Source</b> is a pointer to the source of data.
<br/><b>Size=</b> specifies number of bytes to copy. By default it is
<!---->the SIZE# Destination attribute, if possible. The size may be
<!---->alternatively specified with the keyword Size=.</dd>
<dt>Output</dt><dd>All registers are preserved.</dd>
<dt>Examples</dt><dd class="PRE">CopyTo Buffer1, Buffer2
<!---->CopyTo RDI,RSI,RCX
<!---->CopyTo RDI,Line,Size=80</dd> </dl><pre>
CopyTo  %MACRO Destination, Source, Size=
        %IF "%Size" !=== ""
          PUSHQ %Size
        %ELSE
          %IF TYPE# %Destination = 'R'
            %ERROR ID=5912, "CopyTo data size not specified."
            %EXITMACRO CopyTo
          %ELSE
            PUSHQ SIZE# (%Destination)
          %ENDIF
         %ENDIF
      PUSHQ %Source, %Destination
      CALL CopyTo64@RT::
CopyTo64@RT:: PROC1
       PUSH RCX,RSI,RDI
        MOV RCX,[RSP+48] ; %Size
        MOV RSI,[RSP+40] ; %Source
        MOV RDI,[RSP+32] ; %Destination
        SHR ECX,1
        JNC .10:
        MOVSB
   .10: SHR ECX,1
        JNC .20:
        MOVSW
   .20: SHR ECX,1
        JNC .30:
        MOVSD
   .30: JRCXZ .90
        REP:MOVSD
   .90:POP RDI,RSI,RCX
       RET 3*8
  ENDPROC1 CopyTo64@RT::
%ENDMACRO CopyTo
</pre>

<dl id="LodD"><dt><a href="#top">&uarr; LodD</a> Source, Size=</dt>
<dd>Load signed or unsigned integer number in decimal notation and return its binary value in RAX.
<br/>LodD tolerates leading white spaces before the number and underscores
<kbd>_</kbd> inside the notation. The number may begin with <kbd>+</kbd> or
<kbd>-</kbd>, at least one digit must immediately follow the sign.
<br/>Parsing stops when non-digit character is encountered or when
<!---->the number of characters specified with Size= has been examinated.</dd>
<dt>Input</dt><dd><b>Source</b> is a pointer to ANSI-encoded decimal number.
<br/>When the Source operand is not specified explicitly, RSI is assumed.
<br/><b>Size=</b> specifies length of the source field in characters (=bytes). By default it is unlimited.
</dd><dt>Output</dt><dd><b>CF</b>=0, <b>RAX</b>=loaded number
<!---->in the range -9_223_372_036_854_775_808 .. 18_446_744_073_709_551_615.
<br/><b>RSI</b> points behind the last parsed digit.</dd>
<dt>Error</dt><dd><b>CF=1, RAX,RSI</b> undefined
<br/>when the source number has wrong format:
<br>1. After skipping the leading white spaces Source does not start with a digit or sign.
<br>2. No digit immediately follows the sign.
<br>3. Loaded number does not fit into 64 bits.</dd>
<dt>Example</dt><dd class="PRE">InputField DB " -123.45"
<!---->  LodD InputField ; Loads RAX with -123d=0xFFFFFFFF_FFFFFF85</dd>
<dt>Tested by</dt><dd><a class="EXT" href="../prowin64/tmac64.htm">tmac64.htm</a></dd>
</dl><pre>
LodD  %MACRO  Source, Size=
    %IF "%Size" === ""
      %IF "%Source" === "" || TYPE# %Source = 'R'
        PUSHQ -1
      %ELSE
        PUSHQ SIZE# (%Source)
      %ENDIF
    %ELSE
      PUSHQ %Size
    %ENDIF
    %IF "%Source" === ""
      PUSH RSI
    %ELSE
      PUSHQ %Source
    %ENDIF
    CALL LodD64@RT::
LodD64@RT:: PROC1
     PUSH RCX,RDX,RBX,RDI
       MOV RDX,[RSP+48] ; Size.
       MOV RSI,[RSP+40] ; Source.
       MOV RCX,RDX
       ADD RDX,RSI      ; Parse end limit.
       INC RCX
       JNZ .00:
       MOV RDX,-1
 .00:  SUB EAX,EAX
       SUB ECX,ECX      ; Signum.
       SUB EBX,EBX      ; Output value accumulator.
       MOV EDI,10
 .10:  CMP RSI,RDX
       JNB .Error:
       LODSB
       CMP AL,' '
       JBE .10:         ; Skip leading white spaces.
       ; Sign or digit expected.
       CMP AL,'+'
       JE .20:
       CMP AL,'-'
       JNE .30:
       DEC RCX          ; RCX is Minus flag.
 .20: ; At least one digit expected behind the signum, otherwise error.
       CMP RSI,RDX
       JNB .Error:
       LODSB
 .30:  SUB AL,'0'
       JB .Error:
       CMP AL,9
       JA .Error:
       MOV EBX,EAX      ; Most significant digit loaded.
 .40: ; Other digits or underscores are expected, otherwise the parsing stops.
       CMP RSI,RDX
       JNB .EndOfNumber:
       LODSB
       CMP AL,'_'
       JE .40:
       SUB AL,'0'
       JB .EndOfNumber1:
       CMP AL,9
       JA .EndOfNumber1:
       XCHG RAX,RBX
       PUSH RDX
        MUL RDI
       POP RDX
       JC .Error:
       ADD RBX,RAX
       JC .Error:
       SUB EAX,EAX
       JMP .40:
 .Error:DEC RSI
       STC
       JMP .95:
 .EndOfNumber1:DEC RSI
 .EndOfNumber:
       TEST ECX       ; Minus?
       JZ .90:
       NEG RBX
  .90: CLC
       MOV RAX,RBX
  .95:POP RDI,RBX,RDX,RCX
     RET 2*8
  ENDPROC1 LodD64@RT::
%ENDMACRO LodD
</pre>

<dl id="LodH"><dt><a href="#top">&uarr; LodH</a> Source, Size=, Align=left</dt>
<dd>Load 64bit number in hexadecimal notation to register RAX.
<!---->Number may contain hexadecimal digits '0'..'9', 'a'..'f', 'A'..'F'
<!---->optionally prefixed with '+' or '-' sign. LodH tolerates underscore '_' among digits.
<!---->At least one hexadecimal digit should immediately follow the sign. Parsing stops
<!---->when other non-hexadigit character is encountered or when Size= is exhausted.
<br>Prefix <code>0x</code> is not supported (LodH would return RAX=0 and RSI behind the <code>0x</code>.
</dd>
<dt>Input</dt><dd><b>Source</b> is a pointer to the ANSI-encoded hexadecimal number.
<br/>RSI is assumed when the Source operand is not specified explicitly.
<br/><b>Size=</b> is number of characters in the source field. When the size
<!---->is not explicitly specified, <code>SIZE# %Source</code> is assumed.
<!---->Size is not limited if it cannot be determined from %Source.
<br><b>Align=left</b>. By default the source must start with sign or hexadecimal digit.
<!---->LodH tolerates leading white spaces only when Align=right.</dd>
<dt>Output</dt><dd><b>CF</b>=0, <b>RAX</b>=loaded number
<br/><b>RSI</b>= pointer behind the last parsed source digit.</dd>
<dt>Error</dt><dd><b>CF</b>=1, <b>RAX,RSI</b> undefined
<br/>when the source number has wrong format:
<br>1. source does not start with a hexadecimal digit or sign,
<br>2. no hexadecimal digit immediately follows the sign,
<br>3. loaded number does not fit into 64 bits.</dd>
<dt>Example</dt><dd class="PRE">InputField DB "3FCh"
<!----> LodH InputField ; loads RAX with 0x3FC=1020, RSI points to 'h'</dd>
</dl><pre>
LodH  %MACRO  Source, Size=, Align=left
    %LodHflags %SETA  %cpuextAlignL & "%Align[1]" == "L"
    PUSHQ %LodHflags
    %IF "%Size" === ""
      %IF "%Source" === "" || TYPE# %Source = 'R'
        PUSHQ -1
      %ELSE
        PUSHQ SIZE# (%Source)
      %ENDIF
    %ELSE
      PUSHQ %Size
    %ENDIF
    %IF "%Source" === ""
      PUSH RSI
    %ELSE
      PUSHQ %Source
    %ENDIF
    CALL LodH64@RT::
LodH64@RT:: PROC1
     PUSH RCX,RDX,RBX
       MOV RDX,[RSP+48] ; %LodHflags.
       MOV RCX,[RSP+40] ; %LodHSize.
       MOV RSI,[RSP+32] ; %LodHSource.
       SUB EAX,EAX
       SUB EBX,EBX      ; RBX will accumulate the binary value.
       JRCXZ .20:
       TEST DL,%cpuextAlignL
       JNZ .30:
  .10: LODSB            ; White spaces are tolerated when Align=right.
       CMP AL,' '
       JA .40:
       DEC ECX
       JNZ  .10:
  .20: STC ; Error.
       JMP .95:
  .30: LODSB            ; Signum or digit expected.
  .40: CMP AL,'+'
       JE .70:
       CMP AL,'-'
       JNE .60:
       OR DL, %cpuextMinus
       JMP .70:
  .50: LODSB            ; Digit expected.
  .60: CMP AL,'_'
       JE .70:
       SUB AL,'0'
       JB .80:
       CMP AL,9
       JNA .65:
       SUB AL,'A'-'0'-10
       JB .80:
       CMP AL,15
       JNA .65
       SUB AL,'a'-'A'
       JB .80:
       CMP AL,15
       JA .80:
  .65: SAL RBX,4
       ADD RBX,RAX
       OR DL, %cpuextLeading0 ; At least one digit was found.
  .70: DEC ECX
       JNZ .50:
  .80: TEST DL, %cpuextLeading0
       JZ .20:                ; Error if no digit was parsed.
       TEST DL, %cpuextMinus
       JZ .90:
       NEG RBX
  .90: CLC
       MOV RAX,RBX
 .95:POP RBX,RDX,RCX
     RET 3*8
  ENDP1 LodH64@RT::
%ENDMACRO LodH
</pre>

<dl id="StoD"><dt><a href="#top">&uarr; StoD</a> Destination, Size=, Signed=yes, Align=left, LeadingZeroes=no</dt>
<dd>Store 64bit integer from RAX in decimal notation.</dd>
<dt>Input</dt><dd><b>RAX</b> contains the input number.
<br><b>Destination</b> is a pointer to memory where the decimal
<!---->number will be stored. RDI is assumed when Destination is omitted.
<br/><b>Size=</b> specifies length of the Destination field. When the size
<!---->is not explicitly specified, it is taken from <code>SIZE# %Destination
</code>. Size is not limited if it cannot be determined from %Destination.
<!---->Size will never exceed 20 characters. The output string is ANSI (1byte per digit).
<br/><b>Signed=yes</b> specifies whether the input number is treated as signed.
<!---->Negative numbers will be prefixed with minus sign <kbd>-</kbd>, positive sign is not used.
<br/><b>Align=left</b> specifies alignment (justification) of the number in Destination field.
<!---->If Size= cannot be determined, this parameter is ignored.
<!---->When Align=right and Size= is specified, the vacant characters on the
<!---->left side will be filled with spaces or unsignificant leading zeroes.
<br/><b>LeadingZeroes=no</b> specifies if the whole field should be filled
<!---->with unsignificant <kbd>0</kbd> from the left side. Otherwise spaces would be used.
<br/>When Align=left or when the Size= is not specified, leading zeroes|spaces are not used.</dd>
<dt>Output</dt><dd><b>CF=0</b>,
<br/><b>RDI</b> points behind the last stored digit.</dd>
<dt>Error</dt><dd><b>CF=1</b> if Size= is not long enough,
<br/><b>RDI</b> points to Destination, nothing is stored.</dd>
<dt>Example</dt><dd class="PRE">OutputField DB 20 * B '?'
<!---->  MOV EAX,123
<!---->  StoD OutputField
<!---->  MOV AL,'.'
<!---->  STOSB
<!---->  MOV EAX,45
<!---->  StoD ; OutputField is now "123.45??????????????",
<!---->       ; RDI points to the 1st question mark</dd>
<dt>Layout</dt><dd class="PRE">
<!---->MOV RAX, 12345              MOV RAX, -12345
<!---->StoD Size=8                 StoD Size=8
<!---->&#x250C;&#x2500;&#x252C;&#x2500;&#x252C;&#x2500;&#x252C;&#x2500;&#x252C;&#x2500;&#x252C;&#x2500;&#x252C;&#x2500;&#x252C;&#x2500;&#x2510;           &#x250C;&#x2500;&#x252C;&#x2500;&#x252C;&#x2500;&#x252C;&#x2500;&#x252C;&#x2500;&#x252C;&#x2500;&#x252C;&#x2500;&#x252C;&#x2500;&#x2510;
<!---->&#x2502;1&#x2502;2&#x2502;3&#x2502;4&#x2502;5&#x2502; &#x2502; &#x2502; &#x2502;           &#x2502;-&#x2502;1&#x2502;2&#x2502;3&#x2502;4&#x2502;5&#x2502; &#x2502; &#x2502;
<!---->&#x2514;&#x2500;&#x2534;&#x2500;&#x2534;&#x2500;&#x2534;&#x2500;&#x2534;&#x2500;&#x2534;&#x2500;&#x2534;&#x2500;&#x2534;&#x2500;&#x2518;           &#x2514;&#x2500;&#x2534;&#x2500;&#x2534;&#x2500;&#x2534;&#x2500;&#x2534;&#x2500;&#x2534;&#x2500;&#x2534;&#x2500;&#x2534;&#x2500;&#x2518;
<!---->           ^                             ^
<!---->          RDI                           RDI
<!---->
<!---->MOV RAX, 12345               MOV RAX, -12345
<!---->StoD Size=8, Align=right     StoD Size=8, Align=right
<!---->&#x250C;&#x2500;&#x252C;&#x2500;&#x252C;&#x2500;&#x252C;&#x2500;&#x252C;&#x2500;&#x252C;&#x2500;&#x252C;&#x2500;&#x252C;&#x2500;&#x2510;           &#x250C;&#x2500;&#x252C;&#x2500;&#x252C;&#x2500;&#x252C;&#x2500;&#x252C;&#x2500;&#x252C;&#x2500;&#x252C;&#x2500;&#x252C;&#x2500;&#x2510;
<!---->&#x2502; &#x2502; &#x2502; &#x2502;1&#x2502;2&#x2502;3&#x2502;4&#x2502;5&#x2502;           &#x2502; &#x2502; &#x2502;-&#x2502;1&#x2502;2&#x2502;3&#x2502;4&#x2502;5&#x2502;
<!---->&#x2514;&#x2500;&#x2534;&#x2500;&#x2534;&#x2500;&#x2534;&#x2500;&#x2534;&#x2500;&#x2534;&#x2500;&#x2534;&#x2500;&#x2534;&#x2500;&#x2518;           &#x2514;&#x2500;&#x2534;&#x2500;&#x2534;&#x2500;&#x2534;&#x2500;&#x2534;&#x2500;&#x2534;&#x2500;&#x2534;&#x2500;&#x2534;&#x2500;&#x2518;
<!---->                 ^                           ^
<!---->                RDI                         RDI
<!---->
<!---->MOV RAX, 12345              MOV RAX, -12345
<!---->StoD Size=8, Align=right,\  StoD Size=8, Align=right,\
<!---->     LeadingZeroes=yes           LeadingZeroes=yes
<!---->&#x250C;&#x2500;&#x252C;&#x2500;&#x252C;&#x2500;&#x252C;&#x2500;&#x252C;&#x2500;&#x252C;&#x2500;&#x252C;&#x2500;&#x252C;&#x2500;&#x2510;           &#x250C;&#x2500;&#x252C;&#x2500;&#x252C;&#x2500;&#x252C;&#x2500;&#x252C;&#x2500;&#x252C;&#x2500;&#x252C;&#x2500;&#x252C;&#x2500;&#x2510;
<!---->&#x2502;0&#x2502;0&#x2502;0&#x2502;1&#x2502;2&#x2502;3&#x2502;4&#x2502;5&#x2502;           &#x2502;-&#x2502;0&#x2502;0&#x2502;1&#x2502;2&#x2502;3&#x2502;4&#x2502;5&#x2502;
<!---->&#x2514;&#x2500;&#x2534;&#x2500;&#x2534;&#x2500;&#x2534;&#x2500;&#x2534;&#x2500;&#x2534;&#x2500;&#x2534;&#x2500;&#x2534;&#x2500;&#x2518;           &#x2514;&#x2500;&#x2534;&#x2500;&#x2534;&#x2500;&#x2534;&#x2500;&#x2534;&#x2500;&#x2534;&#x2500;&#x2534;&#x2500;&#x2534;&#x2500;&#x2518;
<!---->                 ^                           ^
<!---->                RDI                         RDI
</dd><dt>Tested by</dt><dd><a class="EXT" href="../prowin64/tmac64.htm">tmac64.htm</a></dd>
</dl><pre>
StoD  %MACRO  Destination, Size=, Signed=Yes, Align=Left, LeadingZeroes=No
    %StoDflags %SETA              %cpuextSigned   & "%Signed[1]" == "Y"
    %StoDflags %SETA %StoDflags | %cpuextAlignL   & "%Align[1]" == "L"
    %StoDflags %SETA %StoDflags | %cpuextLeading0 & "%LeadingZeroes[1]" !== "N"
    %IF "%Align[1]" !== "L" && "%Size" === "" && ("%Destination" === "" || "%Destination" == "RDI")
      %ERROR ID=5913, "StoD cannot Align=Right when Size= is not specified."
      %StoDflags %SETA %StoDflags | %cpuextAlignL
    %ENDIF
    PUSHQ %StoDflags
    %IF "%Size" === ""
      %IF "%Destination" === "" || TYPE# %Destination = 'R'
        PUSHQ -1
      %ELSE
        PUSHQ SIZE# (%Destination)
      %ENDIF
    %ELSE
      PUSHQ %Size
    %ENDIF
    %IF "%Destination" === ""
      PUSH RDI
    %ELSE
      PUSHQ %Destination
    %ENDIF
    CALL StoD64@RT::
StoD64@RT:: PROC1
    PUSH RAX,RCX,RDX,RBX,RBP,RSI
      SUB RSP,20+4       ; Room for temporary destination.
      MOV RDI,RSP
      MOV RCX,[RSP+96]   ; %StoDflags.
      MOV RBX,RAX        ; The input integer number is now in RBX.
      TEST CL,%cpuextSigned
      JZ .10:
      TEST RBX
      JNS .10:
      NEG RBX            ; Convert RBX to positive number.
      OR CL,%cpuextMinus ; Result will be prefixed with '-'.
.10:
divsr %FOR 10000000000000000000, \ 10<sup>19</sup>.
            1000000000000000000, \ 10<sup>18</sup>.
             100000000000000000, \ 10<sup>17</sup>.
              10000000000000000, \ 10<sup>16</sup>.
               1000000000000000, \ 10<sup>15</sup>.
                100000000000000, \ 10<sup>14</sup>.
                 10000000000000, \ 10<sup>13</sup>.
                  1000000000000, \ 10<sup>12</sup>.
                   100000000000, \ 10<sup>11</sup>.
                    10000000000, \ 10<sup>10</sup>.
                     1000000000, \ 10<sup>9</sup>.
                      100000000, \ 10<sup>8</sup>.
                       10000000, \ 10<sup>7</sup>.
                        1000000, \ 10<sup>6</sup>.
                         100000, \ 10<sup>5</sup>.
                          10000, \ 10<sup>4</sup>.
                           1000, \ 10<sup>3</sup>.
                            100, \ 10<sup>2</sup>.
                             10  ; 10<sup>1</sup>.
        MOV RBP,%divsr
        CALL .Divide:
 .Divide:PROC1           ; Divide divident RBX by divisor RBP.
          SUB EDX,EDX
          XCHG RBX,RAX   ; Zero extend divident RBX to RDX:RAX.
          DIV RBP        ; RAX is now 0..9.
          ADD AL,'0'     ; Convert to decimal digit.
          STOSB          ; Store to temporary destination.
          XCHG RDX,RBX   ; Copy remainder to RBX.
          RET
         ENDP1 .Divide:
      %ENDFOR divsr      ; Repeat with smaller divisor.
      MOV AL,BL          ; The last remainder.
      ADD AL,'0'         ; Convert to decimal digit.
      STOSB              ; String of 20 digits at RSP now contains the temporary result.
      MOV RSI,RSP        ; Pointer to temporary result with leading decimal zeros.
      LEA RBX,[RSP+20-1] ; Pointer to the last digit in temporary result.
.20:  CMP RSI,RBX
      JNB .30:           ; If no more zeros to skip.
      LODSB
      CMP AL,'0'
      JE .20:            ; Skip leading unsignificant zeros.
      DEC RSI
.30:  INC RBX
      SUB RBX,RSI        ; Unsigned result without leading zeros is now in RSI,RBX.
      MOV RDX,[RSP+88]   ; %StoDSize.
      MOV RDI,[RSP+80]   ; %StoDDestination.
      TEST RDX
      STC
      JZ .Overflow:
      TEST CL,%cpuextMinus
      JZ .40:
      DEC RDX
.40:  SUB RDX,RBX        ; RDX is now the number of padding bytes in destination.
      JC .Overflow:
      TEST CL,%cpuextAlignL
      JZ .50:
      TEST CL,%cpuextMinus
      JZ .90:
      MOV AL,'-'
      STOSB
      JMP .90:
.50:  ; Justify the result to the right.
      TEST CL,%cpuextMinus
      JZ .70:
      TEST CL,%cpuextLeading0
      MOV ECX,EDX
      JZ .60:
      MOV AL,'-'
      STOSB
      MOV AL,'0'
      REP:STOSB
      JMP .90:
.60:  MOV AL,' '
      REP STOSB
      MOV AL,'-'
      STOSB
      JMP .90:
.70:  TEST CL,%cpuextLeading0
      MOV AL,' '
      JZ .80:
      MOV AL,'0'
.80:  MOV ECX,EDX
      REP:STOSB
.90:  MOV ECX,EBX
      REP:MOVSB
.Overflow:  ; CF signalizes error.
      LEA RSP,[RSP+20+4]
    POP RSI,RBP,RBX,RDX,RCX,RAX
    RET 3*8
  ENDP1 StoD64@RT::
%ENDMACRO StoD
</pre>

<dl id="StoH"><dt><a href="#top">&uarr; StoH</a> Destination, Size=, Signed=no, Case=upper, Align=right, LeadingZeroes=yes</dt>
<dd>Store 64bit integer number from RAX converted to hexadecimal notation (without radix modifier
<kbd>0x</kbd> and <kbd>H</kbd>. The number is always treated as signed. When it is negative,
<!---->its converted first significant digit has the MSbit=1 (<kbd>8..F</kbd>). First significant digit of positive number is
<kbd>1..7</kbd>.</dd>
<dt>Input</dt><dd><b>RAX</b> contains the input binary number.
<br><b>Destination</b> is a pointer to memory where the number in hexadecimal notation
<!---->will be stored. RDI is assumed when Destination is omitted.
<br/><b>Size=</b> specifies the number of bytes in the Destination field. When the size
<!---->is not explicitly specified, it is taken from <code>SIZE# %Destination</code>.
<!---->Size is not limited if it cannot be determined from %Destination
<!---->but it will never exceed 16 bytes. The output string is ANSI (1byte per digit).
<br/><b>Signed=no</b> if the number should be treated as signed.
<br/><b>Case=upper</b> (or lower). This parameter will select between
<code>ABCDEF</code> and <code>abcdef</code> digits.
<br/><b>Align=right</b> (or left) specifies alignment (justification) of the number in Destination field.
<!---->If Size= cannot be determined, this parameter is ignored and the result is left-justified.
<!---->Only significant hexadecimal digits are stored (at least one).
<br/>When Align=right and Size= is specified, the vacant room on the
<!---->left side will be filled with spaces or unsignificant leading characters <kbd>0</kbd> or
<kbd>F</kbd> (this depends on the signum of input value).
<br/><b>LeadingZeroes=yes</b> (or no) specifies if the whole field should be filled
<!---->from the left side with unsignificant <kbd>0</kbd> or <kbd>F</kbd>. When Align=left or when
<!---->the Size= is not determined, leading characters are not used and only significant nibbles are stored.</dd>
<dt>Output</dt><dd><b>CF=0</b>,
<br/><b>RDI</b> points behind the last stored destination digit.</dd>
<dt>Error</dt><dd><b>CF=1</b> if Size= is not long enough to store all significant digits without overflow,
<br/><b>RDI</b> points to Destination, nothing is stored.</dd>
<dt>Layout</dt><dd class="PRE">
<!---->MOV RAX, 0x123              MOV RAX, -0x123
<!---->StoH Size=8                 StoH Size=8, Signed=yes
<!---->&#x250C;&#x2500;&#x252C;&#x2500;&#x252C;&#x2500;&#x252C;&#x2500;&#x252C;&#x2500;&#x252C;&#x2500;&#x252C;&#x2500;&#x252C;&#x2500;&#x2510;           &#x250C;&#x2500;&#x252C;&#x2500;&#x252C;&#x2500;&#x252C;&#x2500;&#x252C;&#x2500;&#x252C;&#x2500;&#x252C;&#x2500;&#x252C;&#x2500;&#x2510;
<!---->&#x2502;0&#x2502;0&#x2502;0&#x2502;0&#x2502;0&#x2502;1&#x2502;2&#x2502;3&#x2502;           &#x2502;F&#x2502;F&#x2502;F&#x2502;F&#x2502;F&#x2502;E&#x2502;D&#x2502;D&#x2502;
<!---->&#x2514;&#x2500;&#x2534;&#x2500;&#x2534;&#x2500;&#x2534;&#x2500;&#x2534;&#x2500;&#x2534;&#x2500;&#x2534;&#x2500;&#x2534;&#x2500;&#x2518;           &#x2514;&#x2500;&#x2534;&#x2500;&#x2534;&#x2500;&#x2534;&#x2500;&#x2534;&#x2500;&#x2534;&#x2500;&#x2534;&#x2500;&#x2534;&#x2500;&#x2518;
<!---->                 ^                           ^
<!---->                RDI                         RDI
<!---->
<!---->MOV RAX, 0x123              MOV RAX, -0x123
<!---->StoH Size=8, \              StoH Size=8, Signed=yes, \
<!---->     LeadingZeroes=no            LeadingZeroes=no
<!---->&#x250C;&#x2500;&#x252C;&#x2500;&#x252C;&#x2500;&#x252C;&#x2500;&#x252C;&#x2500;&#x252C;&#x2500;&#x252C;&#x2500;&#x252C;&#x2500;&#x2510;           &#x250C;&#x2500;&#x252C;&#x2500;&#x252C;&#x2500;&#x252C;&#x2500;&#x252C;&#x2500;&#x252C;&#x2500;&#x252C;&#x2500;&#x252C;&#x2500;&#x2510;
<!---->&#x2502; &#x2502; &#x2502; &#x2502; &#x2502; &#x2502;1&#x2502;2&#x2502;3&#x2502;           &#x2502; &#x2502; &#x2502; &#x2502; &#x2502; &#x2502;E&#x2502;D&#x2502;D&#x2502;
<!---->&#x2514;&#x2500;&#x2534;&#x2500;&#x2534;&#x2500;&#x2534;&#x2500;&#x2534;&#x2500;&#x2534;&#x2500;&#x2534;&#x2500;&#x2534;&#x2500;&#x2518;           &#x2514;&#x2500;&#x2534;&#x2500;&#x2534;&#x2500;&#x2534;&#x2500;&#x2534;&#x2500;&#x2534;&#x2500;&#x2534;&#x2500;&#x2534;&#x2500;&#x2518;
<!---->                 ^                           ^
<!---->                RDI                         RDI
<!---->
<!---->MOV RAX, 0x123               MOV RAX, -0x123
<!---->StoH Size=8, Align=left      StoH Size=8, Signed=yes, Align=left
<!---->&#x250C;&#x2500;&#x252C;&#x2500;&#x252C;&#x2500;&#x252C;&#x2500;&#x252C;&#x2500;&#x252C;&#x2500;&#x252C;&#x2500;&#x252C;&#x2500;&#x2510;           &#x250C;&#x2500;&#x252C;&#x2500;&#x252C;&#x2500;&#x252C;&#x2500;&#x252C;&#x2500;&#x252C;&#x2500;&#x252C;&#x2500;&#x252C;&#x2500;&#x2510;
<!---->&#x2502;1&#x2502;2&#x2502;3&#x2502; &#x2502; &#x2502; &#x2502; &#x2502; &#x2502;           &#x2502;E&#x2502;D&#x2502;D&#x2502; &#x2502; &#x2502; &#x2502; &#x2502; &#x2502;
<!---->&#x2514;&#x2500;&#x2534;&#x2500;&#x2534;&#x2500;&#x2534;&#x2500;&#x2534;&#x2500;&#x2534;&#x2500;&#x2534;&#x2500;&#x2534;&#x2500;&#x2518;           &#x2514;&#x2500;&#x2534;&#x2500;&#x2534;&#x2500;&#x2534;&#x2500;&#x2534;&#x2500;&#x2534;&#x2500;&#x2534;&#x2500;&#x2534;&#x2500;&#x2518;
<!---->       ^                           ^
<!---->      RDI                         RDI
</dd><dt>Tested by</dt><dd><a class="EXT" href="../prowin64/tmac64.htm">tmac64.htm</a></dd>
</dl><pre>
StoH  %MACRO  Destination, Size=, Case=Upper, Align=Right, LeadingZeroes=Yes, Signed=No
    %StoHflags %SETA              %cpuextLowCase  & "%Case[1]"   !== "u"
    %StoHflags %SETA %StoHflags | %cpuextSigned   & "%Signed[1]" !== "n"
    %StoHflags %SETA %StoHflags | %cpuextAlignL   & "%Align[1]"  !== "r"
    %StoHflags %SETA %StoHflags | %cpuextLeading0 & "%LeadingZeroes[1]" == "y"
    %IF "%Align[1]" == "R" && "%Size" === "" && ("%Destination" === "" || "%Destination" == "RDI")
      %ERROR ID=5915, "StoH cannot Align=Right when Size= is not specified."
      %StoHflags %SETA %StoHflags | %cpuextAlignL
    %ENDIF
    PUSHQ %StoHflags
    %IF "%Size" === ""
      %IF "%Destination" === "" || TYPE# %Destination = 'R'
        PUSHQ -1
      %ELSE
        PUSHQ SIZE# (%Destination)
      %ENDIF
    %ELSE
      PUSHQ %Size
    %ENDIF
    %IF "%Destination" === ""
      PUSH RDI
    %ELSE
      PUSH %Destination
    %ENDIF
    CALL StoH64@RT::
StoH64@RT:: PROC1
     PUSH RAX,RCX,RDX,RBX,RBP,RSI
       SUB RSP,16               ; Room for temporary destination.
       MOV RDI,RSP
       MOV RDX,[RSP+11*8]       ; %StoHflags.
       MOV RBX,RAX              ; Input value.
       MOV ECX,16               ; Number of 4bit nibbles in RBX.
       TEST DL,%cpuextLowCase
       JZ .10:
       OR DH,'x'^'X'            ; DH is 0x00 or 0x20 for upper or lower case.
.10:   ROL RBX,4                ; Start with the most significant nibble.
       MOV AL,0x0F
       AND AL,BL
       OR  AL,'0'
       CMP AL,'9'
       JBE .20:
       ADD AL,'A'-'0'-10        ; AL='A'..'F'.
       OR  AL,DH                ; Convert to lower case if DH=0x20.
.20:   STOSB
       DEC RCX
       JNZ .10:
       TEST DL,%cpuextSigned
       JNZ .50:
       MOV RSI,RSP              ; 16 bytes of temporary room at RSI is filled with hexadecimal digits.
       MOV CL,16
.25:   LODSB
       CMP AL,'0'
       JNE .30:
       LOOP .25:
       INC ECX
.30:   DEC RSI                  ; RCX is the number of significant digits.
       MOV RBP,[RSP+10*8]       ; %StoHSize.
       TEST RBP
       JNS .35:
       MOV EBP,ECX
.35:   CMP RBP,RCX
       JC .Overflow:
       MOV RDI,[RSP+9*8]        ; %Destination.
       TEST DL,%cpuextAlignL
       JNZ .85:
.40:   ; Right align RCX significant digits from RSI to RDI..RDI+RBP.
       SUB EBP,ECX              ; RBP is number of unsignificant zeroes.
       JNA .85:
       MOV AL,'0'
       TEST DL,%cpuextLeading0
       JNZ .45:
       MOV AL,' '
.45:   STOSB
       DEC EBP
       JNZ .45:
       JMP .85:
.50:   TEST RBX                 ; 16 bytes of temporary room at RSP is filled with hexadecimal digits.
       JNS .55:
       OR DH,'F'                ; Prepare DH=unsignificant digit 'F' or 'f'.
       JMP .60:
.55:   MOV DH,'0'               ; Prepare DH=unsignificant digit '0'.
       JNZ .60:
       INC BL                   ; If input number = 0, one significant digit '0' is stored.
       JMP .70:
.60:   BSR RCX,RBX              ; Find the most significat bit for both positive and negative value.
       NOT RBX
       BSR RBX,RBX
       CMP BL,CL
       JB .65:
       XCHG BL,CL               ; Select the minimum.
.65:   ADD BL,5
       SHR BL,2                 ; RBX is now the number of significant output nibbles (1..16).
.70:   LEA RSI,[RSP+ 2*8]       ; End of temporary room.
       MOV RCX,[RSP+10*8]       ; %StoHSize.
       MOV RDI,[RSP+ 9*8]       ; %StoHDestination.
       SUB RSI,RBX              ; RSI now points to 1st significant digit.
       TEST DL,%cpuextAlignL
       JNZ .80:
       SUB RCX,RBX
       JC .Overflow:
       MOV AL,DH
       TEST DL,%cpuextLeading0
       JNZ .75:
       MOV AL,' '
.75:   REP:STOSB                ; Store RCX spaces or unsignificant digits.
.80:   MOV RCX,RBX
.85:   REP:MOVSB                ; Store significant digits.
.Overflow:                      ; CF signalizes error.
       LEA RSP,[RSP+2*8]
     POP RSI,RBP,RBX,RDX,RCX,RAX
     RET 3*8
  ENDP1 StoH64@RT::
 %ENDMACRO StoH
</pre>

<dl id="StripColons"><dt><a href="#top">&uarr; StripColons</a> PtrReg, SizeReg, Unicode=%^UNICODE</dt>
<dd>Remove leading and trailing colon(s) <kbd>:</kbd> from input field.</dd>
<dt>Input</dt><dd><b>PtrReg</b> is a register which points to the input field.
<br><b>SizeReg</b> is a register with size of the input field in bytes.
<!---->Both arguments must be specified as general purpose 64bit registers.
<br/><b>Unicode=</b> is a logical parameter which tells whether the strings is ANSI or WIDE.</dd>
<dt>Output</dt><dd>Both input registers are changed if the field
<!---->begins and|or ends with colons.
<!---->If the input field only contains one or more colons,
<!---->the 2nd register will return 0.
</dd></dl><pre>
StripColons %MACRO PtrReg, SizeReg, Unicode=%^UNICODE
      %IF TYPE#%PtrReg <> 'R' || TYPE#%SizeReg <> 'R'
        %ERROR ID=5918, "Both arguments of StripColons must be GPR."
        %EXITMACRO StripColons
      %ENDIF
      %IF %Unicode ; <b>WIDE variant</b>.
 StripColons1%.:
        CMP %SizeReg,2
        JL StripColons9%.:
        CMPW [%PtrReg+%SizeReg-2],":"
        JNE StripColons2%.:
        SUB %SizeReg,2
        JMP StripColons1%.:
 StripColons2%.:
        CMPW [%PtrReg],":"
        JNE StripColons9%.:
        ADD %PtrReg,2
        CMP %SizeReg,2
        JL StripColons9%.:
        SUB %SizeReg,2
        JMP StripColons2%.:
 StripColons9%.:
      %ELSE ; <b>ANSI variant</b>.
        TEST %SizeReg
        JZ StripColons9%.:
 StripColons1%.:
        CMPB [%PtrReg+%SizeReg-1],':'
        JNE StripColons2%.:
        DEC %SizeReg
        JNG StripColons9%.:
        JMP StripColons1%.:
 StripColons2%.:
        CMPB [%PtrReg],':'
        JNE StripColons9%.:
        INC %PtrReg
        DEC %SizeReg
        JMP StripColons2%.:
      %ENDIF
 StripColons9%.:
 %ENDMACRO StripColons
</pre>

<dl id="StripQuotes"><dt><a href="#top">&uarr; StripQuotes</a> PtrReg, SizeReg, Unicode=%^UNICODE</dt>
<dd>Remove leading and trailing double quote <kbd>&quot;</kbd> from input field.</dd>
<dt>Input</dt><dd><b>PtrReg</b> is a register which points to the input field.
<br><b>SizeReg</b> is the register with size of the input field in bytes.
<!---->Both arguments must be specified as general purpose 64bit registers.
<br/><b>Unicode=</b> is a logical parameter which tells whether the strings is ANSI or WIDE.</dd>
<dt>Output</dt><dd>Both input registers are changed if the field
<!---->begins and/or ends with double quote.
<!---->If the input field only contains two quotes,
<!---->the 2nd register will return 0.
</dd></dl><pre>
StripQuotes %MACRO PtrReg, SizeReg, Unicode=%^UNICODE
      %IF TYPE#%PtrReg <> 'R' || TYPE#%SizeReg <> 'R'
        %ERROR ID=5919, "Both arguments of StripQuotes must be GPR."
        %EXITMACRO StripQuotes
      %ENDIF
      %IF %Unicode  ; <b>WIDE variant</b>.
        CMP %SizeReg,2*2
        JB StripQuotes9%.:
        CMPW [%PtrReg+%SizeReg-2],'"'
        JNE StripQuotes1%.:
        SUB %SizeReg,2
 StripQuotes1%.:
        CMPW [%PtrReg],'"'
        JNE StripQuotes9%.:
        ADD %PtrReg,2
        SUB %SizeReg,2
 StripQuotes9%.:
      %ELSE  ; <b>ANSI variant</b>.
        CMP %SizeReg,2
        JB StripQuotes9%.:
        CMPB [%PtrReg+%SizeReg-1],'"'
        JNE StripQuotes1%.:
        DEC %SizeReg
 StripQuotes1%.:
        CMPB [%PtrReg],'"'
        JNE StripQuotes9%.:
        INC %PtrReg
        DEC %SizeReg
StripQuotes9%.:
     %ENDIF
 %ENDMACRO StripQuotes
</pre>

<dl id="StripApostrophes"><dt><a href="#top">&uarr; StripApostrophes</a> PtrReg, SizeReg, Unicode=%^UNICODE</dt>
<dd>Remove leading and trailing single quote <kbd>'</kbd> from input field.</dd>
<dt>Input</dt><dd><b>PtrReg</b> is a register which points to the input field.
<br><b>SizeReg</b> is register with size of the input field in bytes.
<!---->Both arguments must be specified as general purpose 64bit registers.
<br/><b>Unicode=</b> is a logical parameter which tells whether the strings is ANSI or WIDE.</dd>
<dt>Output</dt><dd>Both input registers are changed if the field
<!---->begins and/or ends with apostrophe.
<!---->If the input field only contains two apostrophes,
<!---->the 2nd register will return 0.
</dd></dl><pre>
StripApostrophes %MACRO PtrReg, SizeReg, Unicode=%^UNICODE
      %IF TYPE#%PtrReg <> 'R' || TYPE#%SizeReg <> 'R'
        %ERROR ID=5917, "Both arguments of StripApostrophes must be GPR."
        %EXITMACRO StripApostrophes
      %ENDIF
      %IF %Unicode  ; <b>WIDE variant</b>.
        CMP %SizeReg,2*2
        JB StripApostrophes9%.:
        CMPW [%PtrReg+%SizeReg-2],"'"
        JNE StripApostrophes1%.:
        SUB %SizeReg,2
 StripApostrophes1%.:
        CMPW [%PtrReg],"'"
        JNE StripApostrophes9%.:
        ADD %PtrReg,2
        SUB %SizeReg,2
 StripApostrophes9%.:
      %ELSE  ; <b>ANSI variant</b>.
        CMP %SizeReg,2
        JB StripApostrophes9%.:
        CMPB [%PtrReg+%SizeReg-1],"'"
        JNE StripApostrophes1%.:
        DEC %SizeReg
 StripApostrophes1%.:
        CMPB [%PtrReg],"'"
        JNE StripApostrophes9%.:
        INC %PtrReg
        DEC %SizeReg
 StripApostrophes9%.:
      %ENDIF
 %ENDMACRO StripApostrophes
</pre>


<dl id="StripSpaces"><dt><a href="#top">&uarr; StripSpaces</a> PtrReg, SizeReg, Unicode=%^UNICODE</dt>
<dd>Remove white spaces (characters equal or below ASCII 32) which surround the input field.</dd>
<dt>Input</dt><dd><b>PtrReg</b> is a register which points to the input field.
<br><b>SizeReg</b> is a register with size of the input field in bytes.
<!---->Both arguments must be specified as general purpose 64bit registers.
<br/><b>Unicode=</b> is a logical parameter which tells whether the strings is ANSI or WIDE.</dd>
<dt>Output</dt><dd>Both input registers are changed if the field
<!---->begins and/or ends with white spaces. If the input field contains
<!---->nothing but spaces, the 2nd register will return 0.
<dt>Example</dt><dd class="PRE">Field: DB " some text ",13,10,0
<!----> MOV ESI,Field
<!----> MOV ECX,SIZE# Field ; 14
<!----> StripSpaces ESI,ECX
<!----> ; ESI=Field+1    ECX=9</dd>
<dt>Tested by</dt><dd><a class="EXT" href="../prowin64/tmac64.htm">tmac64.htm</a></dd>
</dl><pre>
StripSpaces %MACRO PtrReg, SizeReg, Unicode=%^UNICODE
      %IF TYPE#%PtrReg <> 'R' || TYPE#%SizeReg <> 'R'
        %ERROR ID=5920, "Both arguments of StripSpaces must be GPR."
        %EXITMACRO StripSpaces
      %ENDIF
      %IF %Unicode ; <b>WIDE variant</b>.
 StripSpaces1%.:
        CMP %SizeReg,2
        JL StripSpaces9%.:
        CMPW [%PtrReg+%SizeReg-2]," "
        JA StripSpaces2%.:
        SUB %SizeReg,2
        JMP StripSpaces1%.:
 StripSpaces2%.:
        CMPW [%PtrReg]," "
        JA StripSpaces9%.:
        ADD %PtrReg,2
        CMP %SizeReg,2
        JL StripSpaces9%.:
        SUB %SizeReg,2
        JMP StripSpaces2%.:
 StripSpaces9%.:
      %ELSE  ; <b>ANSI variant</b>.
        TEST %SizeReg
        JZ StripSpaces9%.:
 StripSpaces1%.:
        CMPB [%PtrReg+%SizeReg-1]," "
        JA StripSpaces2%.:
        DEC %SizeReg
        JNG StripSpaces9%.:
        JMP StripSpaces1%.:
 StripSpaces2%.:
        CMPB [%PtrReg]," "
        JA StripSpaces9%.:
        INC %PtrReg
        DEC %SizeReg
        JMP StripSpaces2%.:
 StripSpaces9%.:
      %ENDIF
 %ENDMACRO StripSpaces
</pre>

<pre>
 ENDHEAD cpuext64
</pre>
<!--TAILMENU-->
<!--Contents below the marker {!==TAILMENU==} was generated by "generate.php".-->
<br class='CLEAR'/><a id='bottom' href='#top'>&#x25B2;Back to the top&#x25B2;</a>
</body></html>
