<!doctype html><html lang='en'><head>
<meta http-equiv='Content-Type' content='text/html; charset=utf-8'/>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=2.0, user-scalable=yes'>
<meta name='robots' content='ALL,FOLLOW'/>
<meta name='description' content='stdcal32.htm macro library'/>
<meta name='version' content='20250318'/>
<meta name='author' content='Pavel vitsoft Šrubař'/>
<link rel='stylesheet' href='../euroasm.css' type='text/css'/>
<link rel='shortcut icon' href='../favicon.ico'/>
<title>stdcal32.htm macro library</title>
</head>
<body class='MACLIB' id='top'><div class='HEADMENU'><table>
<tr><td rowspan='2' title='&euro;ASM - assembler and linker'><img src='../favicon.ico' alt='EuroAssembler' />
<td><a href='../index.htm' title='Alphabetical index of all &euro;ASM elements, directives and instructions'>Index</a></td>
<td><a href='../eadoc/' class='EADOC' title='Documentation of EuroAssembler'>Manual</a></td>
<td><a href='https://euroassembler.eu/download/' title='History &amp; download of the latest and previous versions'>Download</a></td>
<td><a href='../easource/' class='EASOURCE' title='Source files of EuroAssembler itself'>Source</a></td>
<td><a href='../maclib/' class='MACLIB' title='Macro libraries shipped with &euro;ASM'>Macros</a></td>
<td rowspan='2' title='Find the searched token in any text file on this site'>
<form method='post' action='../search.php' enctype='multipart/form-data' accept-charset='utf-8'>
<input type='text' id='q' placeholder='Searched word(s)' name='q' value=''/>
<br/><label title='Check the box to find the expression even if it is surrounded by other letters | digits.'>
<input type='checkbox' name='EW'/><small>Embedded word</small></label>
<br/><label title='Check the box for case-insensitive search.'>
<input type='checkbox' name='CI'/><small>Case ins.</small></label>
<input type='submit' title='Search for the specified word|expression in all site files.' name='find' value='Search'/>
</form></td></tr><tr>
<td><a href='../sitemap.htm' title='List of directories and files on this site'>Sitemap</a></td>
<td><a href='../eadoc/links.htm' class='EADOC' title='References and external links to resources used in EuroAssembler developement'>Links</a></td>
<td><a href='https://euroassembler.eu/forum/' title='Discussion forum concerning EuroAssembler'>Forum</a></td>
<td><a href='../eatests/' class='EATESTS' title='Program snippets for testing the function of &euro;ASM'>Tests</a></td>
<td><a href='../objlib/' class='OBJLIB' title='Skeletons and sample objects and projects shipped with &euro;ASM'>Projects</a></td>
</tr></table></div>
<!--Contents above the marker {!==/HEADMENU==} was generated by "generate.php".-->
<!--/HEADMENU-->
<h1>stdcal32.htm
<br/><i>Enumeration</i>
<br/><a href="#pcStdCall32">%StdCall32</a>
<br/><i>Macros</i>
<br/><a href="#ClearLocalVar">ClearLocalVar</a>
<br/><a href="#EndProcedure">EndProcedure</a>
<br/><a href="#Invoke">Invoke</a>
<br/><a href="#LocalVar">LocalVar</a>
<br/><a href="#Procedure">Procedure</a>
</h1>
<p>This file can be included to <strong>32bit programs</strong> written in EuroAssembler.
<!---->The library contains <strong>OS-independent</strong> macroinstructions <code>Procedure, EndProcedure, Invoke
</code> which extend generic pseudoinstruction <code>PROC, ENDPROC, CALL</code>.</p>
<p>Macroinstructions <code>Procedure</code> and <code>EndProcedure</code> hide the prologue and epilogue of
<dfn>standard call</dfn> <a class="EXTL" href="../eadoc/links.htm#CallingConv">calling convention
</a>, where the arguments are pushed backwards and they are removed by the called procedure.</p>
<p>All GP registers are calee-saved by the Procedure. Result value of the invokation can be returned
<!---->from procedure by copying the value to stack-variables such as <code>%ReturnEAX</code>, which is  defined by
<a href="#pcStdCall32">%StdCall32</a> as <code>EBP+28</code>.</p>
<p>  Macroinstructions in this library comunicate at assembly time through the preprocessing %variables
<code>%LvSize_<em>ProcName</em></code> (total size of all local stack-variables) and
<code>%ArgC_<em>ProcName</em></code> (number of procedure parameters).
<!---->Individualization of global %variable names allows to nest procedure definitions in one another.</p>
<br class="CLEAR"/><pre>
stdcal32 HEAD
</pre>
<dl id="pcStdCall32"><dt><a href="#top">&uarr; %StdCall32</a></dt>
<dd><p>Implementation of standard call convention in &euro;ASM
<!---->uses formal %names for accessing
<!---->Procedure parameters, local stack-memory variables and
<!---->all eight general-purpose registers saved on stack.</p>
<p>The following example shows stack-frame created by invoking Procedure with the name
<em>MyFn</em> which has three parameters and uses two local stack variables
<!---->named LocV1 and LocV2 with sizes 4 and 8. Prologue of <code>MyFn Procedure Param1, Param2, Param3
</code> will assign &quot;global&quot; %variables
<code>%ArgC_MyFn %SETA 3</code> and <code>%LvSize_MyFn %SETA 4+8
</code>, they can be used in macros <a href="#LocalVar">LocalVar</a>,
<a href="#ClearLocalVar">ClearLocalVar</a> and by epilogue in
<code>EndProcedure MyFn</code> during <code> Invoke MyFn, Param1, Param2, Param3</code>.
</dd>
<dd class="PRE">
<!---->MyFn Procedure Param1, Param2, Param3
<!---->LocV1 LocalVar        ; Reserve local stack variable with default size 4.
<!---->LocV2 LocalVar Size=8 ; Reserve another variable.
<!---->      ; MyFn body can use formal names Param1, Param2, Param3, LocV1, LocV2
<!---->      ;   to access its parameters and local stack variables by prefixing
<!---->      ;   the formal name with <kbd>%</kbd>, for instance
<!---->      MOV EAX,[%Param1]
<!---->      MOV [%LocV1],EAX
<!---->      ; Macro EndProcedure discards local variables, restores all GPR and returns below Invoke, removing the pushed arguments.
<!---->     EndProcedure MyFn
</dd>
<dd class="PRE">                       <abbr>ESP after the step.</abbr>
<!---->                        <abbr>&#x2502;</abbr>
<!----> Prologue in 8 steps    <abbr>&#x2502;</abbr> Stack frame       Epilogue in 3 steps
<!---->                        <abbr>&#x2502;</abbr>&lt;&#x2500;&#x2500;4 bytes&#x2500;&gt;
<!---->                      0.&gt;&#x250C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2510;&lt;12.continue below Invoke
<!---->1.PUSH Param3            &#x2502; %Param3  &#x2502;
<!---->                      1.&gt;&#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;
<!---->2.PUSH Param2            &#x2502; %Param2  &#x2502;
<!---->                      2.&gt;&#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;
<!---->3.PUSH Param1            &#x2502; %Param1  &#x2502;
<!---->                      3.&gt;&#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;
<!---->4.CALL Function          &#x2502; return   &#x2502;    12.RET 3*4
<!---->                      4.&gt;&#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;&lt;11.
<!---->5.PUSHAD                 &#x2502;%ReturnEAX&#x2502;
<!---->                         &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;
<!---->                         &#x2502;%ReturnECX&#x2502;
<!---->                         &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;
<!---->                         &#x2502;%ReturnEDX&#x2502;
<!---->                         &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;
<!---->                         &#x2502;%ReturnEBX&#x2502;
<!---->                         &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;
<!---->                         &#x2502;%ReturnESP&#x2502;
<!---->                         &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;
<!---->                         &#x2502;%ReturnEBP&#x2502;
<!---->                         &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;
<!---->                         &#x2502;%ReturnESI&#x2502;
<!---->                         &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;
<!---->6.MOV EBP,ESP            &#x2502;%ReturnEDI&#x2502;     11.POPAD
<!---->                    5.6.&gt;&#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;&lt;10.
<!---->7.SUB ESP,4              &#x2502; %LocV1   &#x2502;
<!---->                      7.&gt;&#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;
<!---->                         &#x2502;          &#x2502;
<!---->                         &#x2502;          &#x2502;
<!---->8.SUB ESP,8              &#x2502; %LocV2   &#x2502;     10.MOV ESP,EBP
<!---->                      8.&gt;&#x2514;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2518;&lt;9.
<!---->
<!---->                      9.Function body
</dd></dl>
<pre>
; Formal names assignment:
%Param8    %SET EBP+64
%Param7    %SET EBP+60
%Param6    %SET EBP+56
%Param5    %SET EBP+52
%Param4    %SET EBP+48
%Param3    %SET EBP+44
%Param2    %SET EBP+40
%Param1    %SET EBP+36
%ReturnEAX %SET EBP+28
%ReturnECX %SET EBP+24
%ReturnEDX %SET EBP+20
%ReturnEBX %SET EBP+16
%ReturnESP %SET EBP+12
%ReturnEBP %SET EBP+08
%ReturnESI %SET EBP+04
%ReturnEDI %SET EBP+00
</pre>

 <dl id="Procedure"><dt><a href="#top">&uarr; Procedure</a> Operand1, Operand2,,,</dt>
<dd>This macro declares 32bit StdCall-procedure prolog which, unlike ordinary pseudoinstruction
<!---->PROC, accepts ordinal operands.
<br/>Macro operands will be assigned to preprocessing %variables
<!---->using the operand formal name prefixed with a percent sign.</dd>
<dt>Input</dt><dd>Label of <b>Procedure</b> statement is mandatory,
<!----> it gives the procedure an invokable name.
<br/><b>Operand*</b> is argument passed to the procedure. It can be anything pushable as DWORD.
<!---->Number of operands is not limited.</dd>
<dt>Output</dt><dd>Macroinstruction will define global symbol, assign formal operands to %variables
<!---->and emit machine instructions <code>PUSHAD</code> and
<code>MOV EBP,ESP</code> as the procedure prolog.</dd>
<dt>Example</dt><dd class="PRE">Move Procedure Source,Destination,Size
<!---->    MOV ESI,[%Source]
<!---->    MOV EDI,[%Destination]
<!---->    MOV ECX,[%Size]
<!---->    REP MOVSB
<!---->  EndProcedure Move
</dd><dd>Macro Procedure in the previous example will assign
<div class="PRE">%ArgC_Move   %SETA 3     ; This %variable propagates to macro EndProcedure and tells how many parameters should be discarded.
<!---->%LvSize_Move %SETA 0     ; This %variable propagates to macros LocalVar and ClearLocalVar, if they're used in Procedure body.
<!---->%Source      %SET EBP+36 ; These are formal %variables of all operands.
<!---->%Destination %SET EBP+40
<!---->%Size        %SET EBP+44</div>
</dd></dl><pre>
Procedure %MACRO Operands ; Prologue of standard calling convention procedure.
LblCheck    %IF "%:" === ""
              %ERROR ID=5921, 'Macro "Procedure" requires a label.'
              %EXITMACRO Procedure
            %ENDIF LblCheck
%%ArgC_%:   %SETX %#
%%LvSize_%: %SETX 0
ArgNr       %FOR 1..%#, STEP= +1
%%%*{%ArgNr}  %SETX EBP+(32+%ArgNr*4)
            %ENDFOR ArgNr
%:::        PROC %=*, NESTINGCHECK=OFF
            PUSHAD
            MOV EBP,ESP
         %ENDMACRO Procedure
</pre>

<dl id="LocalVar"><dt><a href="#top">&uarr; LocalVar</a> Size=4</dt>
<dd>reserves and declares local memory variable with the given Size allocated on machine stack.</dd>
<dt>Example</dt>
<dd class="PRE">ProcName: Procedure Arg1,Arg2,Arg3
<!---->  BlockSize LocalVar         ; %BlockSize is now assigned with <code>EBP-4</code>
<!---->  Block     LocalVar Size=1K ; %Block is now <code>EBP-1028</code>.
<!---->            ClearLocalVar    ; Fill Block and BlockSize with 0.
<!---->            MOV [%BlockSize],1K, DATA=DWORD
<!---->            LEA EDI,[%Block]
<!---->             ...
<!---->          EndProcedure ProcName</dd>
<dt>Input</dt><dd>Plain identifier must be defined as a label of
<b>LocalVar</b> statement. It does not need to be unique in the program
<!---->because it does not declare assembly symbol. The name will be
<!----> prefixed with <kbd>%</kbd> and used as preprocessing %variable
<!---->for addressing parameters withing the procedure body.
<br/><b>Size=</b>4 specifies how many bytes should be reserved for the local variable.
<!---->It is rounded up to DWORD internally.</dd>
<dt>Output</dt><dd>Macro will define a preprocessing %variable with
<!---->the name which was defined as the label but it is now prefixed with percent sign.
<!---->Then it will emit machine instruction <code>SUB ESP,%Size</code>
<!---->to reserve room on the machine stack.
<br/>Macro <dfn>LocalVar</dfn> also maintains the &quot;global&quot; variable
<!---->with dynamic name <code>%LvSize_<em>ProcedureName</em></code> which was initialized in macro <code>Procedure</code>.</dd></dl>
<pre>
LocalVar     %MACRO Size=4
LblCheck        %IF "%:" === ""
                  %ERROR ID=5922, 'Macro "LocalVar" requires a label.'
                  %EXITMACRO LocalVar
                %ENDIF LblCheck
SizeCheck       %IF %#
                  %ERROR ID=5923, 'Macro "LocalVar" does not expect ordinal parameters.'
                  %EXITMACRO LocalVar
                %ENDIF SizeCheck
%:              %COMMENT                          ; This makes the label of macro invocation void,
                %ENDCOMMENT %:                    ;  so it does not declare a symbol.
%ThisLvSize     %SETA (%Size + 3) & ~3            ; Round up the required size to DWORD.
%GlbLvSize      %SET2 %%LvSize_%^PROC+%ThisLvSize ; Accumulate total size of all LocalVar.
%%LvSize_%^PROC %SETX %GlbLvSize                  ; Update the "global" variable.
                SUB ESP, %ThisLvSize              ; Allocate room on stack.
%%%:            %SETX EBP-(%GlbLvSize)            ; Assign formal %name to the id specified with LocalVar label.
             %ENDMACRO LocalVar
</pre>

<dl id="ClearLocalVar">
<dt><a href="#top">&uarr; ClearLocalVar</a></dt>
<dd>This macro zeroes all variables on stack previously declared with
<a href="#LocalVar">LocalVar</a>. ClearLocalVar should be expanded
<!---->right after LocalVar declarations, before any stack operations are made.
<blockquote>We could as well decide to initialize each local variable individually,
<!---->in this case the macro ClearLocalVar will not be used in the Procedure body at all.
</blockquote></dd>
<dt>Input</dt><dd>Macro does not use explicit parameters.
<!---->Pointer to the cleared memory is specified with
<code>ESP</code>, cleared size is specified with &quot;global&quot; variable
<code>%LvSize_<em>CurrentProcName</em></code>.</dd>
<dt>Output</dt><dd><b>EAX=ECX=</b>0,
<br/><b>EDI</b>= ESP + %LvSize_<em>CurrentProcName</em></dd></dl><pre>
ClearLocalVar %MACRO
%GlbLvSize %SET2 %%LvSize_%^PROC
           %IF %GlbLvSize
             MOV EDI,ESP
             MOV ECX,(%GlbLvSize) / 4
             XOR EAX,EAX
             REP STOSD
           %ENDIF
    %ENDMACRO ClearLocalVar
</pre>

<dl id="EndProcedure">
<dt><a href="#top">&uarr; EndProcedure</a> ProcName</dt>
<dd><p>Macro <dfn>EndProcedure</dfn> terminates context of the previously opened
<a href="#Procedure">Procedure
</a>. This epilogue of StdCall convention will discard local variables defined with
<a href="#LocalVar">LocalVar</a> (using machine instruction
<code>MOV ESP,EBP</code>), restore all GP registers (using
<code>POPAD</code>) and then return to the parent code
<!---->which the Procedure was Invoked from (using <code>RET 4*%ArgC_<em>ProcName</em></code>).
<br/>Operands pushed on stack in the <b>Invoke</b> statement
<!----> will be discarded here by this <b>EndProcedure</b> macro.
<br/>All registers are preserved throughout the procedure invocation
<!---->unless the procedure changed their stored value
<!---->on the stack frame (writing to <code>[%ReturnEAX]</code> for instance).
<br/>CPU flags are not preserved, <b>EndProcedure</b> returns
<!---->with the same flag values which were set at the
<b>EndProcedure</b> entry.</p>
<blockquote> Programmer should never use explicit machine instruction <code>RET</code>
 <!----> to return from the block defined with <code>Procedure .. EndProcedure
</code>.  If premature return is required, jump to the label of <code>EndProcedure
</code> statement instead.</blockquote>
</dd>
<dt>Input</dt><dd>
<b>ProcName</b> This macroinstruction requires exactly one operand
<!---->which is identical with the label of previous corresponding
<code>Procedure</code> statement.</dd>
<dt>Output</dt><dd>Stack frame is released, current process returns below
<code>Invoke</code> statement.</dd></dl><pre>
EndProcedure %MACRO ProcName
OpCheck    %IF "%ProcName" === ""
             %ERROR ID=5924, 'Macro "EndProcedure" requires one operand.'
             %EXITMACRO EndProcedure
           %ENDIF OpCheck
%NameStrip %SET %ProcName
           %WHILE "%NameStrip[%&]" === ":"
             %NameStrip %SET %NameStrip[1..%&-1] ; Get rid of trailing colons.
           %ENDWHILE
%ArgC      %SET2 %%ArgC_%NameStrip
NestCheck  %IF "%ArgC" === ""
             %ERROR ID=5925, '"%ProcName Procedure" statement missing.'
             %EXITMACRO EndProcedure
           %ENDIF NestCheck
           MOV ESP,EBP
           POPAD
           RET 4 * (%ArgC)
           ENDP %ProcName, NESTINGCHECK=OFF ; Terminate the namespace.
        %ENDMACRO EndProcedure
</pre>

<dl id="Invoke"><dt><a href="#top">&uarr; Invoke</a> ProcName, Arg1, Arg2, ...</dt>
<dd><dfn>Invoke</dfn> is a replacement of standard CALL instruction which can pass parameters
<!----> to the Procedure. Arguments are pushed on stack as DWORDs,
<!----> starting from the last. The procedure is then called
<!----> and it is responsible for removing pushed arguments from stack.
<br/>It's necessary to Invoke a procedure with exactly the same number
<!---->of arguments which were declared by the <a href="#Procedure">Procedure</a> macro.</dd>
<dt>Input</dt><dd><b>ProcName</b> The first operand is the name of invoked procedure.
<br/><b>Arg*</b> is a list of Procedure arguments.</dd>
<dt>Output</dt><dd>The returned registers and flags depend on the
<!---->invoked Procedure. By default all registers are preserved unless
<!---->they return some value.</dd>
</dl><pre>
Invoke %MACRO ProcName, Arguments
ArgCheck %IF "%ProcName" === ""
           %ERROR ID=5926, 'Macro "Invoke" requires the name of called Procedure.'
           %EXITMACRO Invoke
         %ENDIF ArgCheck
ArgNr    %FOR %#..2, STEP= -1
           PUSHD %*{%ArgNr}
         %ENDFOR ArgNr
         CALL %ProcName
       %ENDMACRO Invoke
</pre><pre>
  ENDHEAD stdcal32
</pre><!--TAILMENU-->
<!--Contents below the marker {!==TAILMENU==} was generated by "generate.php".-->
<br class='CLEAR'/><a id='bottom' href='#top'>&#x25B2;Back to the top&#x25B2;</a>
</body></html>
