<!doctype html><html lang='en'><head>
<meta http-equiv='Content-Type' content='text/html; charset=utf-8'/>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=2.0, user-scalable=yes'>
<meta name='robots' content='ALL,FOLLOW'/>
<meta name='description' content='memory32.htm macro library'/>
<meta name='version' content='20250318'/>
<meta name='author' content='Pavel vitsoft Šrubař'/>
<link rel='stylesheet' href='../euroasm.css' type='text/css'/>
<link rel='shortcut icon' href='../favicon.ico'/>
<title>memory32.htm macro library</title>
</head>
<body class='MACLIB' id='top'><div class='HEADMENU'><table>
<tr><td rowspan='2' title='&euro;ASM - assembler and linker'><img src='../favicon.ico' alt='EuroAssembler' />
<td><a href='../index.htm' title='Alphabetical index of all &euro;ASM elements, directives and instructions'>Index</a></td>
<td><a href='../eadoc/' class='EADOC' title='Documentation of EuroAssembler'>Manual</a></td>
<td><a href='https://euroassembler.eu/download/' title='History &amp; download of the latest and previous versions'>Download</a></td>
<td><a href='../easource/' class='EASOURCE' title='Source files of EuroAssembler itself'>Source</a></td>
<td><a href='../maclib/' class='MACLIB' title='Macro libraries shipped with &euro;ASM'>Macros</a></td>
<td rowspan='2' title='Find the searched token in any text file on this site'>
<form method='post' action='../search.php' enctype='multipart/form-data' accept-charset='utf-8'>
<input type='text' id='q' placeholder='Searched word(s)' name='q' value=''/>
<br/><label title='Check the box to find the expression even if it is surrounded by other letters | digits.'>
<input type='checkbox' name='EW'/><small>Embedded word</small></label>
<br/><label title='Check the box for case-insensitive search.'>
<input type='checkbox' name='CI'/><small>Case ins.</small></label>
<input type='submit' title='Search for the specified word|expression in all site files.' name='find' value='Search'/>
</form></td></tr><tr>
<td><a href='../sitemap.htm' title='List of directories and files on this site'>Sitemap</a></td>
<td><a href='../eadoc/links.htm' class='EADOC' title='References and external links to resources used in EuroAssembler developement'>Links</a></td>
<td><a href='https://euroassembler.eu/forum/' title='Discussion forum concerning EuroAssembler'>Forum</a></td>
<td><a href='../eatests/' class='EATESTS' title='Program snippets for testing the function of &euro;ASM'>Tests</a></td>
<td><a href='../objlib/' class='OBJLIB' title='Skeletons and sample objects and projects shipped with &euro;ASM'>Projects</a></td>
</tr></table></div>
<!--Contents above the marker {!==/HEADMENU==} was generated by "generate.php".-->
<!--/HEADMENU-->
<h1>memory32.htm
<br/><i>Classes</i>
<br/><a href="#BUFFER">BUFFER</a>
<br/><a href="#LIST">LIST</a>
<br/><a href="#POOL">POOL</a>
<br/><a href="#STACK">STACK</a>
<br/><a href="#STREAM">STREAM</a>
<br/><i>Macros</i>
<br/><a href="#BufferClear">BufferClear</a>
<br/><a href="#BufferCreate">BufferCreate</a>
<br/><a href="#BufferDecrement">BufferDecrement</a>
<br/><a href="#BufferNew">BufferNew</a>
<br/><a href="#BufferResize">BufferResize</a>
<br/><a href="#BufferRetrieve">BufferRetrieve</a>
<br/><a href="#BufferStore">BufferStore</a>
<br/><a href="#BufferStoredo">BufferStore$</a>
<br/><a href="#BufferStoreByte">BufferStoreByte</a>
<br/><a href="#BufferStoreDword">BufferStoreDword</a>
<br/><a href="#BufferStoreQword">BufferStoreQword</a>
<br/><a href="#BufferStorePascalString">BufferStorePascalString</a>
<br/><a href="#BufferStoreWord">BufferStoreWord</a>
<br/><a href="#ListCreate">ListCreate</a>
<br/><a href="#ListGetFirst">ListGetFirst</a>
<br/><a href="#ListGetLast">ListGetLast</a>
<br/><a href="#ListGetNext">ListGetNext</a>
<br/><a href="#ListGetPrev">ListGetPrev</a>
<br/><a href="#ListInsert">ListInsert</a>
<br/><a href="#ListNew">ListNew</a>
<br/><a href="#ListRemove">ListRemove</a>
<br/><a href="#ListStore">ListStore</a>
<br/><a href="#PoolCreate">PoolCreate</a>
<br/><a href="#PoolDestroy">PoolDestroy</a>
<br/><a href="#PoolGetSize">PoolGetSIze</a>
<br/><a href="#PoolNew">PoolNew</a>
<br/><a href="#PoolStore">PoolStore</a>
<br/><a href="#StackClear">StackClear</a>
<br/><a href="#StackCreate">StackCreate</a>
<br/><a href="#StackPeekLast">StackPeekLast</a>
<br/><a href="#StackPeekPrev">StackPeekPrev</a>
<br/><a href="#StackPop">StackPop</a>
<br/><a href="#StackPush">StackPush</a>
<br/><a href="#StreamClear">StreamClear</a>
<br/><a href="#StreamCreate">StreamCreate</a>
<br/><a href="#StreamDump">StreamDump</a>
<br/><a href="#StreamGetLines">StreamGetLines</a>
<br/><a href="#StreamGetSize">StreamGetSize</a>
<br/><a href="#StreamReadByte">StreamReadByte</a>
<br/><a href="#StreamReadLn">StreamReadLn</a>
<br/><a href="#StreamReset">StreamReset</a>
<br/><a href="#StreamRetrieve">StreamRetrieve</a>
<br/><a href="#StreamStore">StreamStore</a>
<br/><a href="#StreamStoreByte">StreamStoreByte</a>
<br/><a href="#StreamStoredo">StreamStore$</a>
<br/><a href="#StreamStoreDword">StreamStoreDword</a>
<br/><a href="#StreamStoreLn">StreamStoreLn</a>
<br/><a href="#StreamStoreWord">StreamStoreWord</a>
</h1>
<p>This file can be included to <b>32bit</b> programs written in Euro Assembler.
<!---->It contains <b>OS-independent</b> macros for dynamic memory management.
<br/>The file <dfn>memory32.htm</dfn> defines memory allocation class POOL (similar to system heap functions),
<!---->and its derivations BUFFER, LIST, STACK, STREAM. See also
<a class="EXT" href="../easource/#MemoryManagement">Memory management</a>.</p>
<p>Derived methods Buffer*, List*, Stack*, Stream* allocate their memory
<!---->from the object Pool, and the Pool allocation and deallocation depends on macroinstructions
<dfn>MemAlloc and MemFree</dfn> which are defined in
<a class="EXT" href="winapi.htm#MemAlloc">winapi</a> or <a class="EXT" href="linapi.htm#MemAlloc">linapi</a>.</p>
<dl><dd class="PRE">  Memory management dependency
<!----> &#x250C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2510;
<!----> &#x2502;Buffer&#x2502; List &#x2502;Stack &#x2502;Stream&#x2502;
<!----> &#x2514;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2518;
<!---->              &darr;
<!----> &#x250C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2510;
<!----> &#x2502;          Pool             &#x2502;
<!----> &#x2514;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2518;
<!---->              &darr;
<!----> &#x250C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2510;
<!----> &#x2502;          Sys              &#x2502;
<!----> &#x2514;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2518;
<!---->              &darr;
<!----> &#x250C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2510;
<!----> &#x2502;          OS               &#x2502;
<!----> &#x2514;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2518;
</dd></dl>
<p>All macros in this library return carry flag set if some error occurs,
<!---->which usually signalizes lack of system memory or bad parameter.
<!---->Returned values are not valid when CF=1.</p>
<p>Keyword parameter <em>ErrorHandler=</em> of macro <a href="#PoolCreate">PoolCreate
</a> allows to specify a callback procedure which will be invoked on allocation error.
<!---->Allocation exceptions then can be treated by <em>ErrorHandler</em> (for instance by aborting the program gracefully),
<!---->so the derived methods don't need to catch errors.</p>
<br class="CLEAR"/>
<pre>
memory32 HEAD                          ; Library interface.
</pre>
<dl id="POOL"><dt><a href="#top">&uarr; POOL</a></dt>
<dd><p>Object POOL allocates virtual memory from operating system in big blocks
<!---->(their size is multiple of virtual-memory granularity). Block are not continuous
<!---->in addressing space, they are bound in a unidirectional list. Each pool block
<!---->allocated from OS has the block size and the pointer to previous block in 2 DWORDs
<!---->at its bottom. The POOL structure itself is created in the very first pool block.</p>
<p>Amount of continuos memory requested by PoolNew, BufferStore*, StreamStore* etc.
<!---->is not limited. Whenever there is no enough free memory in the last pool block,
<!---->PoolNew or PoolStore will request an additional empty pool block from OS,
<!---->with size of the requested memory rounded up to allocation granularity.</p>
<p>Allocated memory block cannot be returned to OS individually. The whole list of pool blocks
<!---->will be freed at once by PoolDestroy.</p></dd>
<dd class="PRE">
<!---->     <abbr>After PoolCreate.</abbr>
<!---->
<!---->        &#x250C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2510;    &#x2510;
<!---->        &#x2502;         &#x2502;    &#x2502;
<!---->        &#x2502;         &#x2502;    &#x2502;
<!---->        &#x2502;         &#x2502;    &#x2502;
<!---->        &#x2502;         &#x2502;    &#x2502;
<!---->        &#x2502;         &#x2502;    &#x2502;
<!---->        &#x2502;         &#x2502;    &#x2502;
<!---->    &#x250C;   &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;&lt;&#x2500;&#x2510; &#x2502;
<!---->    &#x2502;   &#x2502;.Ptr     &#x251C;&#x2500;&#x2500;&#x2518; &#x2502;
<!---->    &#x2502;   &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;    &#x2502;
<!---->    &#x2502; &#x250C;&#x2500;&#x2524;.Last    &#x2502;    &#x2502;
<!---->POOL&#x2502; &#x2502; &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;  &#x250C;&#x2500;&#x2524;
<!---->    &#x2502; &#x2502; &#x2502;.ErrH    &#x2502;  &#x2502; &#x2502;
<!---->    &#x2502; &#x2502; &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;  &#x2502; &#x2502;
<!---->    &#x2502; &#x2502; &#x2502;.Gran=64K&#x2502;  &#x2502; &#x2502;
<!---->    &#x2514; &#x2502; &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;  &#x2502; &#x2502;
<!---->      &#x2502; &#x2502;Prev=0   &#x2502;  &#x2502; &#x2502;
<!---->      &#x2502; &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;  &#x2502; &#x2502;
<!---->      &#x2502; &#x2502;Size=64K &#x2502;&lt;&#x2500;&#x2518; &#x2502;
<!---->      &#x2514;&gt;&#x2514;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2518;    &#x2518;
<!---->
<!---->
<!----> <abbr>After many PoolNew allocations.</abbr>       &#x250C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2510;    &#x2510;
<!----> <abbr>The last block was increased.</abbr>         &#x2502;         &#x2502;    &#x2502;
<!---->                                       &#x2502;         &#x2502;    &#x2502;
<!---->                                       &#x2502;         &#x2502;    &#x2502;
<!---->                   &#x250C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&gt;&#x2502;         &#x2502;    &#x2502;
<!---->                   &#x2502;                   &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;    &#x2502;
<!---->                   &#x2502;                   &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;    &#x2502;
<!---->                   &#x2502;                   &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;    &#x2502;
<!---->                   &#x2502;                   &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;    &#x2502;
<!---->                   &#x2502;                   &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;    &#x2502;
<!---->                   &#x2502;                   &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;    &#x2502;
<!---->                   &#x2502;                   &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;    &#x2502;
<!---->                   &#x2502;                   &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;    &#x2502;
<!---->                   &#x2502;                   &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;    &#x2502;
<!---->       &#x250C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2510; &#x2502;   &#x250C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2510;     &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;  &#x250C;&#x2500;&#x2524;
<!---->       &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502; &#x2502;   &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;     &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;  &#x2502; &#x2502;
<!---->       &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502; &#x2502;   &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;     &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;  &#x2502; &#x2502;
<!---->       &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502; &#x2502;   &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;     &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;  &#x2502; &#x2502;
<!---->       &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502; &#x2502;   &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;     &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;  &#x2502; &#x2502;
<!---->       &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502; &#x2502;   &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;     &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;  &#x2502; &#x2502;
<!---->       &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502; &#x2502;   &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;     &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;  &#x2502; &#x2502;
<!---->    &#x250C;  &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524; &#x2502;   &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;     &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;  &#x2502; &#x2502;
<!---->    &#x2502;  &#x2502;.Ptr     &#x251C;&#x2500;&#x2518;   &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;     &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;  &#x2502; &#x2502;
<!---->    &#x2502;  &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;     &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;     &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;  &#x2502; &#x2502;
<!---->    &#x2502;  &#x2502;.Last    &#x251C;&#x2500;&#x2500;&#x2500;&#x2510; &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;     &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;  &#x2502; &#x2502;
<!---->POOL&#x2502;  &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;   &#x2502; &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;     &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;  &#x2502; &#x2502;
<!---->    &#x2502;  &#x2502;.ErrH    &#x2502;   &#x2502; &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;     &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;  &#x2502; &#x2502;
<!---->    &#x2502;  &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;   &#x2502; &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;     &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;  &#x2502; &#x2502;
<!---->    &#x2502;  &#x2502;.Gran=64K&#x2502;   &#x2502; &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;     &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;  &#x2502; &#x2502;
<!---->    &#x2514;  &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;   &#x2502; &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;     &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;  &#x2502; &#x2502;
<!---->       &#x2502;Prev=0   &#x2502; &#x250C;&#x2500;&#x253C;&#x2500;&#x2524; Prev    &#x2502; &#x250C;&#x2500;&#x2500;&#x2500;&#x2524; Prev    &#x2502;  &#x2502; &#x2502;
<!---->       &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524; &#x2502; &#x2502; &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524; &#x2502;   &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;  &#x2502; &#x2502;
<!---->       &#x2502;Size=64K &#x2502; &#x2502; &#x2502; &#x2502; Size=64K&#x2502; &#x2502;   &#x2502;Size=128K&#x2502;&lt;&#x2500;&#x2518; &#x2502;
<!---->       &#x2514;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2518;&lt;&#x2518; &#x2502; &#x2514;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2518;&lt;&#x2518; &#x250C;&gt;&#x2514;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2518;    &#x2518;
<!---->                     &#x2502;               &#x2502;
<!---->                     &#x2514;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2518;
</dd></dl><pre>
POOL STRUC
 .Gran      D D ; Granularity of memory allocation in bytes (64 KB).
 .ErrH      D D ; Address of error handler callback procedure. Ignored when 0.
 .Last      D D ; Pointer to the last pool block allocated from OS.
 .Ptr       D D ; Pointer to the unoccupied memory in the last pool block.
 ENDSTRUC POOL
 </pre>

<dl id="PoolCreate"><dt><a href="#POOL">&uarr; PoolCreate</a> Size=64K, ErrorHandler=0</dt>
<dd><p>will allocate one block from OS virtual memory and create the POOL structure near its bottom.
<br/>This is the first pool block, other blocks may be allocated later on demand.</p></dd>
<dt>Input</dt><dd><b>Size=</b>64K is the default size of memory blocks
<!---->which will be automatically allocated from OS whenever the current block is full.
<br/><b>ErrorHandler=</b>0 is a pointer to the callback procedure which is called
<!---->when some POOL method detects an error. The procedure gets no input and it may
<!---->change any register. This parameter is ignored when ErrorHandler=0 (default value).</dd>
<dt>Output</dt><dd><b>CF</b>=0, <b>EAX=</b>pointer to the just created POOL structure (pool handle).</dd>
<dt>Error</dt><dd><b>CF=</b>1, <b>EAX=</b>0, <b>ErrorHandler</b> is called before return from PoolCreate
<!---->(if it is nonzero).</dd>
<dt>Depends on</dt><dd> macros <a class="EXT" href="winapi.htm#MemAlloc">winapi#MemAlloc</a> or
<a class="EXT" href="linapi.htm#MemAlloc">linapi#MemAlloc</a>.</dd>
</dl><pre>
PoolCreate %MACRO Size=64K, ErrorHandler=0
    PUSHD %ErrorHandler, %Size
    CALL PoolCreate@RT:
PoolCreate@RT:  PROC1
    PUSHAD
      XOR EAX,EAX
      MOV [ESP+7*4],EAX  ; Initialize %ReturnEAX for the case of error.
      MOV ECX,[ESP+9*4]  ; %Size.
      MOV ESI,64K        ; Granularity, fixed at 64 KB.
      MOV EDX,ESI
      ; ESI is granularity (64KB), ECX is requested 1st block size, EDX is the final Alloc size.
 .10: CMP ECX,EDX
      JBE .20:
      ADD EDX,ESI
      JMP .10:
 .20: MemAlloc EDX
 .30: MOV ECX,[ESP+10*4]  ; Offset of %ErrorHandler.
      JNZ .50:            ; If MemAlloc worked OK, continue.
      STC
      JECXZ .90:          ; If no ErrorHandler specified.
      CALL ECX
      STC
      JMP .90:            ; Abort.
 .50: MOV EDI,EAX         ; Address of the allocated memory block.
      MOV EAX,EDX         ; Size of the allocated block.
      STOSD               ; Store the size of this pool block as the first DWORD at its bottom.
      SUB EAX,EAX
      STOSD               ; Pointer to the Prev block is zero.
      MOV EBX,EDI         ; Where the POOL structure will be created.
      MOV [ESP+7*4],EDI   ; %ReturnEAX will point to the POOL structure.
      SUB EDI,8           ; EDI now points to the first and only pool block.
      LEA EAX,[EBX+SIZE# POOL] ; EAX now points to the vacant memory space.
      MOV [EBX+POOL.Gran],64K
      MOV [EBX+POOL.ErrH],ECX
      MOV [EBX+POOL.Last],EDI
      MOV [EBX+POOL.Ptr], EAX
 .90:POPAD
     RET 2*4
  ENDPROC1 PoolCreate@RT:
 %ENDMACRO PoolCreate
</pre>

<dl id="PoolDestroy"><dt><a href="#POOL">&uarr; PoolDestroy</a>  aPool</dt>
<dd>will free all pool blocks allocated from operating system.</dd>
<dt>Input</dt><dd><b>aPool</b> is a pointer to <a href="#POOL">POOL</a> structure
<!---->which was returned from PoolCreate.
<dt>Output</dt><dd><b>CF=</b>0, <b>EAX</b>=total amount of just released memory in bytes.</dd>
<dt>Error</dt><dd><b>CF=</b>1 if deallocation failed.
<br/><b>EAX=</b>total amount of just released memory until deallocation failed.</dd>
<dt>Depends on</dt><dd> macros <a class="EXT" href="../winapi.htm#MemFree">winapi#MemFree</a> or
<a class="EXT" href="../linapi.htm#MemFree">linapi#MemFree</a>.</dd></dl><pre>
PoolDestroy %MACRO aPool
      PUSHD %aPool
      CALL PoolDestroy@RT:
PoolDestroy@RT:  PROC1
      PUSHAD
       MOV EBX,[ESP+9*4] ; Pointer to the <a href="#POOL">POOL</a> structure.
       SUB ECX,ECX       ; ECX is a counter of total freed memory of this pool.
       TEST EBX
       STC
       JZ .90:           ; Abort if bad aPool was provided.
       MOV ESI,[EBX+POOL.Last] ; Begin deallocation with the last block.
.10:   TEST ESI          ; VA of the pool block which is being deallocated.
       JZ .90:           ; If there are no more pool blocks on the list.
       MOV EAX,[ESI+0]   ; Brutto size of the block.
       MOV EDI,[ESI+4]   ; Pointer to the previous block in the list.
       ADD ECX,EAX       ; Total released pool size.
       MemFree ESI,EAX   ; Ask OS to free the memory block addressed with ESI.
       JC .Error:
       MOV ESI,EDI       ; Try the previous block.
       JMP .10:
.Error:STC
.90:   MOV [ESP+7*4],ECX ; Total amount of freed memory in %ReturnEAX.
      POPAD
      RET 4
  ENDPROC1 PoolDestroy@RT
%ENDMACRO PoolDestroy
</pre>

<dl id="PoolGetSize"><dt><a href="#POOL">&uarr; PoolGetSize</a> aPool</dt>
<dd>returns total allocated size of all pool blocks.</dd>
<dt>Input</dt><dd><b>aPool</b> is a pointer to <a href="#POOL">POOL</a> structure
<!---->which was returned from <a href="#PoolCreate">PoolCreate</a>.</dd>
<dt>Output</dt><dd><b>ECX=</b> total comitted size of all pool blocks.</dd>
<dt>Error</dt><dd>-</dd>
</dl><pre>
PoolGetSize %MACRO aPool
      PUSH EBX,ESI
        MOV EBX,%aPool
        SUB ECX,ECX
        MOV ESI,[EBX+POOL.Last]
PoolGetSizeA%.:
        TEST ESI
        JZ PoolGetSizeZ%.:
        ADD ECX,[ESI+0]  ; Brutto size of the block.
        MOV ESI,[ESI+4]  ; Pointer to the previous block in the list.
        JMP PoolGetSizeA%.:
PoolGetSizeZ%.:
      POP ESI,EBX
  %ENDMACRO PoolGetSize
</pre>

<dl id="PoolNew"><dt><a href="#POOL">&uarr; PoolNew</a> aPool, DataSize, Align=DWORD, ZeroTerminate=No, Zeroed=No</dt>
<dd>will reserve a piece of memory (DataSize bytes long) from aPool. Contents of the reserved memory is undefined.
<br/>This macro <dfn>PoolNew</dfn> requires another macro MemAlloc be defined before, which provides the interaction with OS.</dd>
<dt>Input</dt><dd><b>aPool</b> is a pointer to <a href="#POOL">POOL</a> structure
<!---->which was returned from <a href="#PoolCreate">PoolCreate</a>
<br><b>DataSize</b> is requested size in bytes.
<br><b>Align=</b> may specify BYTE/UNICHAR/WORD/DWORD/QWORD/OWORD
<!---->or shortcuts B/U/W/D/Q/O (case insensitive)
<!---->as requested alignment of the allocated memory.
<br/><b>ZeroTerminate=No</b> Boolean parameter. If Yes, the requested DataSize will be incremented by 1,
<!---->making room for zero-byte terminating. This is used by <a href="#PoolStore">PoolStore</a>.
<br/><b>Zeroed=No</b> Boolean parameter. If Yes, the entire DataSize will be filled with zeroes (0x00).
</dd>
<dt>Output</dt><dd><b>CF=</b>0
<br/><b>EAX</b>=pointer to the allocated memory in pool block of memory.</dd>
<dt>Error</dt><dd><b>CF=</b>1 if MemAlloc failed. Handler <code>POOL.ErrH</code> was called.
<br/><b>EAX=</b>0</dd>
<dt>Depends on</dt><dd><a class="EXT" href="winapi.htm#MemAlloc">winapi#MemAlloc</a> or
<a class="EXT" href="linapi.htm#MemAlloc">linapi#MemAlloc</a>.</dd></dl><pre>
PoolNew %MACRO aPool, DataSize, Align=DWORD, ZeroTerminate=No, Zeroed=No
        %PoolNewFlags %SETA 0
        %IF %ZeroTerminate
          %PoolNewFlags %SETA 0x40
        %ENDIF
        %IF %Zeroed
          %PoolNewFlags %SETA 0x20
        %ENDIF
        %PoolNewFlags %SETA %PoolNewFlags | "%Align[1]" == "O" & 15
        %PoolNewFlags %SETA %PoolNewFlags | "%Align[1]" == "Q" & 7
        %PoolNewFlags %SETA %PoolNewFlags | "%Align[1]" == "D" & 3
        %PoolNewFlags %SETA %PoolNewFlags | "%Align[1]" == "W" & 1
        %PoolNewFlags %SETA %PoolNewFlags | "%Align[1]" == "U" & 1
        PUSHD %PoolNewFlags, %DataSize, %aPool
        CALL PoolNew@RT:
PoolNew@RT:  PROC1
     PUSHAD
      MOV EBX,[ESP+9*4]  ; %aPool.
      XOR EBP,EBP
      MOV [ESP+7*4],EBP  ; %ReturnEAX in case of error.
      TEST EBX
      STC
      JZ .90:            ; Error if no pool provided.
.10:  MOV ECX,[ESP+10*4] ; %DataSize.
      MOV EDX,[ESP+11*4] ; %PoolNewFlags.
      BTR EDX,6          ; ZeroTerminate?
      ADC ECX,2*4        ; Increment if ZeroTerminated=Yes and then add 8 bytes for two bottom DWORDs.
      MOV EDI,[EBX+POOL.Ptr]
      BTR EDX,5          ; %Zeroed?
      SBB EBP,0
      ADD EDI,EDX        ; Apply the alignment. EDX=0,1,3,7,15.
      NOT EDX
      AND EDI,EDX        ; EDI is now aligned pointer to the new area.
      LEA EDX,[EDI+ECX]  ; EDX is now pointer to the end of requested area.
      MOV ESI,[EBX+POOL.Last] ; Pointer to the current pool block with our area.
      ADD ESI,[ESI+0]    ; Add pool block size. ESI now points to the top of the last pool block.
      CMP EDX,ESI
      JA .30:            ; Skip if the new area does not fit into remaining space in the current pool block.
      MOV [EBX+POOL.Ptr],EDX ; Update pointer to the free space in the last pool block.
      JMP .80:           ; Almost done. EDI is the aligned memory pointer to allocated memory.
.30:  ; <b>Not enough free space</b> is left in this pool block. Allocate a new pool block.
      ; EBX=^POOL, ECX=DataSize.
      MOV EDX,[EBX-2*4]  ; Default block size is in DWORD below the POOL pointed to with EBX.
.40:  CMP ECX,EDX
      JBE .50:           ; Continue when the requested size ECX is below the future pool block size EDX.
      ADD EDX,[EBX+POOL.Gran] ; Otherwise this particular pool block must be enlarged.
      JMP .40:
.50:  MemAlloc EDX
      MOV EDI,EAX
      JNZ .70:           ; If allocation succeeded.
      MOV ECX,[EBX+POOL.ErrH] ; Allocation error happened.
      JECXZ .60:
      CALL ECX
.60:  STC
      JMP .90:
.70:  MOV ECX,[EBX+POOL.Last]
      MOV [EBX+POOL.Last],EDI
      MOV EAX,EDX
      STOSD               ; Store the size of the new pool block.
      MOV EAX,ECX
      STOSD               ; Store the pointer to its previous pool block.
      MOV [EBX+POOL.Ptr],EDI
      JMP .10:            ; This time the reservation attempt will not fail.
 .80: MOV [ESP+7*4],EDI   ; %ReturnEAX.
      TEST EBP            ; %Zeroed?
      JZ .90:
      MOV ECX,[ESP+10*4]  ; %DataSize.
      XOR EAX,EAX
      REP STOSB
 .90:POPAD
     RET 3*4
   ENDPROC1 PoolNew@RT
 %ENDMACRO PoolNew
</pre>

<dl id="PoolStore"><dt><a href="#POOL">&uarr; PoolStore</a> aPool, DataPtr, DataSize, Align=BYTE, ZeroTerminate=No</dt>
<dd>This inline macro <dfn>PoolStore</dfn> will reserve DataSize bytes of memory on pool and copy the Data there.</dd>
<dt>Input</dt><dd><b>aPool</b> is a pointer to <a href="#POOL">POOL</a> structure
<!---->which was returned from PoolCreate.
<br><b>DataPtr</b> points to the data which should be stored on pool.
<br><b>DataSize</b> is the size of data in bytes.
<br><b>Align=</b> may specify BYTE/UNICHAR/WORD/DWORD/QWORD/OWORD
<!---->or shortcuts B/U/W/D/Q/O (case insensitive)
<!---->as alignment of the stored data.
<br><b>ZeroTerminate=</b>No.  If Yes, one NULL character is stored after the data on aPool.</dd>
<dt>Output</dt><dd><b>CF=</b>0
<br/><b>EAX</b>=pointer to the just stored data in pool block.</dd>
<dt>Error</dt><dd><b>CF=</b>1 if VirtualAlloc() failed. Handler <code>POOL.ErrH</code> was called.
<br/><b>EAX=</b>0</dd>
<dt>Depends on</dt><dd><a href="#PoolNew">PoolNew</a></dd></dl><pre>
PoolStore %MACRO aPool, DataPtr, DataSize, Align=BYTE, ZeroTerminate=No
            PUSH %DataSize, %DataPtr, %aPool
            PUSH ECX,ESI,EDI
              MOV EAX,[ESP+3*4] ; %aPool.
              MOV ESI,[ESP+4*4] ; %DataPtr.
              MOV ECX,[ESP+5*4] ; %DataSize.
              PoolNew EAX,ECX,Align=%Align,ZeroTerminate=%ZeroTerminate
:             JC PoolStoreError%.:
              MOV EDI,EAX
              REP MOVSB
              %IF %ZeroTerminate
                MOV [EDI],CL
              %ENDIF
PoolStoreError%.:
            POP EDI,ESI,ECX
            LEA ESP,[ESP+3*4] ; Discard 3 pushed arguments, keep CF.
         %ENDMACRO PoolStore
</pre>


<dl id="BUFFER"><dt><a href="#top">&uarr; BUFFER</a></dt>
<dd><p>Object BUFFER is an unformated storage for objects (strings) of arbitrary size.</p>
<p>Items with fixed or variable size can be stored to the buffer one after another
<!---->and the entire buffer content is always available as a continuous block.</p>
<p>The initial Size specified at BUFFER creation should be large enough to accomodate
<!---->all expected data. Whenever the total buffer size tries to exceed the allocated size specified
<!---->at buffer creation, data area is reallocated with doubled size,
<!---->the old buffer contents is copied to the new position and the original buffer space is abandoned.
<!---->The BUFFER structure itself always stays in its original position.</p>
<p>Buffer can be destroyed only when the hosting pool is destroyed
<!---->but it can be cleared and reused.</p></dd>
<dd class="PRE">   <abbr>Not yet exhausted buffer</abbr>
<!---->  &#x250C;&#x2500;&#x2500;&gt;&#x250C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2510;&#x2510;
<!---->  &#x2502;   &#x2502;       &#x2502;&#x2502;
<!---->  &#x2502;&#x250C;&#x2500;&gt;&#x2502;       &#x2502;&#x2502;
<!---->  &#x2502;&#x2502;  &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;&#x2502;
<!---->  &#x2502;&#x2502;  &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;&#x2502;Size
<!---->  &#x2502;&#x2502;  &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;&#x2502;
<!---->  &#x2502;&#x2502;  &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;&#x2502;
<!---->  &#x2502;&#x2502;  &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;&#x2502;
<!---->  &#x2502;&#x2502;&#x250C;&gt;&#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;&#x2518;
<!---->  &#x2502;&#x2502;&#x2514;&#x2500;&#x2502;.Bottom&#x2502;
<!---->  &#x2502;&#x2502;  &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;
<!---->  &#x2502;&#x2514;&#x2500;&#x2500;&#x2502;.Ptr   &#x2502;
<!---->  &#x2502;   &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;
<!---->  &#x2514;&#x2500;&#x2500;&#x2500;&#x2502;.Top   &#x2502;
<!---->      &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;
<!---->      &#x2502;.Pool  &#x2502;
<!---->      &#x2514;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2518;
<!---->
<!---->   <abbr>Reallocated buffer with doubled Size</abbr>
<!---->                    &#x250C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&gt;&#x250C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2510;&#x2510;
<!---->                    &#x2502;         &#x2502;       &#x2502;&#x2502;
<!---->                    &#x2502;         &#x2502;       &#x2502;&#x2502;
<!---->                    &#x2502;         &#x2502;       &#x2502;&#x2502;
<!---->                    &#x2502;         &#x2502;       &#x2502;&#x2502;
<!---->                    &#x2502;         &#x2502;       &#x2502;&#x2502;
<!---->                    &#x2502;  &#x250C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&gt;&#x2502;       &#x2502;&#x2502;
<!---->                    &#x2502;  &#x2502;      &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;&#x2502;
<!---->      &#x250C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2510;&#x2510;    &#x2502;  &#x2502;      &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;&#x2502;2*Size
<!---->      &#x2502;       &#x2502;&#x2502;    &#x2502;  &#x2502;      &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;&#x2502;
<!---->      &#x2502;       &#x2502;&#x2502;    &#x2502;  &#x2502;      &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;&#x2502;
<!---->      &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;&#x2502;    &#x2502;  &#x2502;      &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;&#x2502;
<!---->      &#x2502;&#x2591;waste&#x2591;&#x2502;&#x2502;Size&#x2502;  &#x2502;      &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;&#x2502;
<!---->      &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;&#x2502;    &#x2502;  &#x2502;      &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;&#x2502;
<!---->      &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;&#x2502;    &#x2502;  &#x2502;      &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;&#x2502;
<!---->      &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;&#x2502;    &#x2502;  &#x2502;      &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;&#x2502;
<!---->      &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;&#x2518;    &#x2502;  &#x2502; &#x250C;&#x2500;&#x2500;&#x2500;&gt;&#x2514;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2518;&#x2518;
<!---->      &#x2502;.Bottom&#x2502;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x253C;&#x2500;&#x2500;&#x253C;&#x2500;&#x2518;
<!---->      &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;     &#x2502;  &#x2502;
<!---->      &#x2502;.Ptr   &#x2502;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x253C;&#x2500;&#x2500;&#x2518;
<!---->      &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;     &#x2502;
<!---->      &#x2502;.Top   &#x2502;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2518;
<!---->      &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;
<!---->      &#x2502;.Pool  &#x2502;
<!---->      &#x2514;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2518;
</dd></dl><pre>
BUFFER STRUC
 .Pool   D D ; Pool handle obtained from <a href="#PoolCreate">PoolCreate</a>.
 .Top    D D ; Pointer to the end of allocated buffer space.
 .Ptr    D D ; Ptr to the next free position in buffer.
 .Bottom D D ; Ptr to the beginning of buffer data.
 ENDSTRUC BUFFER
</pre>

<dl id="BufferCreate"><dt><a href="#BUFFER">&uarr; BufferCreate</a> aPool, Size=16K</dt>
<dd>will allocate an empty (cleared) buffer on the pool specified
<!---->with the first parameter. Buffer memory is DWORD aligned.</dd>
<dt>Input</dt><dd><b>aPool</b> is a pointer to POOL structure
<!---->which was returned from <a href="#PoolCreate">PoolCreate</a>.
<br><b>Size=</b> is the initial size of the <a href="#BUFFER">BUFFER</a> plus payload data.
<br/>When underestimated, it will be automatically increased if necessary
<!---->but this wastes memory a little.</dd>
<dt>Output</dt><dd><b>CF</b>=0, <b>EAX</b>=pointer to the <a href="#BUFFER">BUFFER</a> (buffer handle).
<dt>Error</dt><dd><b>CF</b>=1, <b>EAX</b>=0
</dd>
<dt>Depends on</dt><dd><a href="#PoolNew">PoolNew</a></dd>
</dl><pre>
BufferCreate %MACRO aPool, Size=16K
      PUSHD %Size, %aPool
      CALL BufferCreate@RT:
BufferCreate@RT: PROC1
     PUSHAD
      MOV EAX,1K         ; Minimal acceptable buffer size.
      MOV ECX,[ESP+10*4] ; %Size.
      MOV EDX,[ESP+ 9*4] ; %aPool.
      CMP ECX,EAX
      JAE .20:
      XCHG EAX,ECX
.20:  PoolNew EDX,ECX, Align=DWORD
      MOV [ESP+7*4],EAX  ; %ReturnEAX.
      JC .90:
      MOV EBX,EAX
      MOV [EBX+BUFFER.Pool],EDX
      LEA EAX,[EBX+SIZE#BUFFER]
      MOV [EBX+BUFFER.Ptr],EAX
      MOV [EBX+BUFFER.Bottom],EAX
      ADD ECX,EBX        ; Also set CF=0.
      MOV [EBX+BUFFER.Top],ECX
.90: POPAD
     RET 2*4
   ENDPROC1 BufferCreate@RT:
 %ENDMACRO BufferCreate
</pre>

<dl id="BufferClear"><dt><a href="#BUFFER">&uarr; BufferClear</a> aBuffer</dt>
<dd>marks the buffer as empty. It does not overwrite the old data.</dd>
<dt>Input</dt><dd><b>aBuffer</b> is a pointer to BUFFER structure
<!---->which was returned from <a href="#BufferCreate">BufferCreate</a>.</dd>
<dt>Output</dt><dd> aBuffer was marked as empty.
<dt>Error</dt><dd>-</dd></dl><pre>
BufferClear %MACRO aBuffer
      PUSH ECX
        MOV ECX,%aBuffer
        JECXZ BufferClear%.: ; If bad aBuffer was provided, skip.
       PUSHD [ECX+BUFFER.Bottom]
       POPD  [ECX+BUFFER.Ptr]
      BufferClear%.:
      POP ECX
 %ENDMACRO BufferClear
</pre>

<dl id="BufferNew"><dt><a href="#BUFFER">&uarr; BufferNew</a> aBuffer, DataSize, Zeroed=No</dt>
<dd>will allocate DataSize bytes on aBuffer and return pointer to the allocated memory.</dd>
<dt>Input</dt><dd><b>aBuffer</b> is a pointer to BUFFER structure
<!---->which was returned from <a href="#BufferCreate">BufferCreate</a>.
<br><b>DataSize</b> is the requested allocation size.
<br/><b>Zeroed=No</b>.  Zeroed=Yes will clear the just allocated memory.
</dd>
<dt>Output</dt><dd><b>CF</b>=0, <b>EAX=</b>pointer to the just allocated space on aBuffer.
<dt>Error</dt><dd><b>CF</b>=1 <b>EAX=</b>0
</dd>
<dt>Depends on</dt><dd><a href="#PoolNew">PoolNew</a></dd>
</dl><pre>
BufferNew %MACRO aBuffer, DataSize, Zeroed=No
     %IF %Zeroed
       PUSHD -1
     %ELSE
       PUSHD 0
     %ENDIF
     PUSHD %DataSize, %aBuffer
     CALL BufferNew@RT:
BufferNew@RT: PROC1
     PUSHAD
      SUB EAX,EAX
      MOV EBX,[ESP+9*4]    ; %aBuffer.
      MOV [ESP+7*4],EAX    ; For the case of error.
      TEST EBX
      STC
      JZ .90:              ; If bad buffer provided.
 .10: MOV ECX,[ESP+10*4]   ; %DataSize.
      MOV EAX,[EBX+BUFFER.Ptr]
      MOV [ESP+7*4],EAX    ; %ReturnEAX.
      TEST EAX
      JNZ .20:
      ; Buffer not initialized or other error. Abort.
      MOV ECX,[EBX+BUFFER.Pool]
      JECXZ .Err:
      MOV ECX,[ECX+POOL.ErrH]
      JECXZ .Err:
      CALL ECX              ; Call error handler.
.Err: STC
      JMP .90:              ; Abort.
 .20: ADD EAX,ECX           ; EAX is now the top of wanna-be-allocated area.
      CMP EAX,[EBX+BUFFER.Top]
      JBE .70:              ; If the amount of free space on buffer is sufficient.
      ; <b>Buffer is too small.</b> Allocate new space with doubled (or more) size.
      MOV EAX,[EBX+BUFFER.Top]
      SUB EAX,[EBX+BUFFER.Bottom]
      MOV EDX,EAX           ; Old buffer size.
      CMP EAX,ECX
      JAE .30:              ; If doubled size is sufficient.
      MOV EAX,ECX
 .30: ADD EDX,EAX           ; Add the old buffer's size.
      PoolNew [EBX+BUFFER.Pool],EDX, Align=DWORD
      JC .90:
      MOV EDI,EAX
      MOV ESI,[EBX+BUFFER.Bottom]
      MOV [EBX+BUFFER.Bottom],EAX
      ADD EAX,EDX
      MOV [EBX+BUFFER.Top],EAX
      MOV ECX,[EBX+BUFFER.Ptr]
      SUB ECX,ESI
      REP MOVSB              ; Copy the old buffer's contents.
      MOV [EBX+BUFFER.Ptr],EDI
      JMP .10:               ; Try again. This time it will succeed.
 .70: MOV EDI,[EBX+BUFFER.Ptr]
      MOV [EBX+BUFFER.Ptr],EAX
      TESTB [ESP+11*4],1     ; Zeroed?
      JZ .90:
      SUB EAX,EDI
      MOV ECX,EAX
      XOR EAX,EAX
      REP STOSB
 .90:POPAD
     RET 3*4
   ENDPROC1 BufferNew@RT:
 %ENDMACRO BufferNew
</pre>

<dl id="BufferStore"><dt><a href="#BUFFER">&uarr; BufferStore</a> aBuffer, DataPtr, DataSize</dt>
<dd>will allocate DataSize bytes and copy the data specified with DataPtr,DataSize.</dd>
<dt>Input</dt><dd><b>aBuffer</b> is a pointer to BUFFER structure
<!---->which was returned from <a href="#BufferCreate">BufferCreate</a>.
<br><b>DataPtr</b> is a pointer to data to be stored on the buffer.
<br><b>DataSize</b> is the requested data size in bytes.</dd>
<dt>Output</dt><dd><b>CF</b>=0, data are stored to buffer.
<dt>Error</dt><dd><b>CF</b>=1
</dd>
<dt>Depends on</dt><dd><a href="#BufferNew">BufferNew</a></dd>
</dl><pre>
BufferStore %MACRO aBuffer, DataPtr, DataSize
     PUSHD %DataSize, %DataPtr, %aBuffer
     CALL BufferStore@RT:
BufferStore@RT: PROC1
     PUSHAD
      MOV EDX,[ESP+9*4]  ; aBuffer.
      MOV ECX,[ESP+11*4] ; DataSize.
      TEST EDX
      STC
      JZ .90:
      BufferNew EDX,ECX
      JC .90:
      MOV EDI,EAX
      MOV ESI,[ESP+10*4] ; DataPtr.
      REP MOVSB
 .90:POPAD
     RET 3*4
    ENDPROC1 BufferStore@RT:
 %ENDMACRO BufferStore
</pre>

<dl id="BufferStoreByte"><dt><a href="#BUFFER">&uarr; BufferStoreByte</a> aBuffer, Value</dt>
<dd>will allocate 1 byte and copy the BYTE value to aBuffer.</dd>
<dt>Input</dt><dd><b>aBuffer</b> is a pointer to BUFFER structure
<!---->which was returned from <a href="#BufferCreate">BufferCreate</a>.
<br><b>Value</b> is an immediate 8bit value or a 32bit register/memory with the value in LSB.</dd>
<dt>Output</dt><dd><b>CF</b>=0, Byte Value was stored to aBuffer.
<dt>Error</dt><dd><b>CF</b>=1
<dt>Depends on</dt><dd><a href="#BufferNew">BufferNew</a></dd>
</dl><pre>
BufferStoreByte %MACRO aBuffer, Value
     PUSHD %Value, %aBuffer
     CALL BufferStoreByte@RT:
BufferStoreByte@RT: PROC1
     PUSHAD
      MOV EDX,[ESP+9*4]  ; aBuffer.
      MOV EBX,[ESP+10*4] ; Value.
      BufferNew EDX,1
      JC .90:
      MOV [EAX],BL       ; Store the BYTE value.
 .90:POPAD
     RET 2*4
     ENDPROC1 BufferStoreByte@RT:
 %ENDMACRO BufferStoreByte
</pre>

<dl id="BufferStoreWord"><dt><a href="#BUFFER">&uarr; BufferStoreWord</a> aBuffer, Value</dt>
<dd>will allocate 2 bytes and copy the WORD value to aBuffer.</dd>
<dt>Input</dt><dd><b>aBuffer</b> is a pointer to BUFFER structure
<!---->which was returned from <a href="#BufferCreate">BufferCreate</a>.
<br><b>Value</b> is an immediate 16bit value or a 32bit register/memory with the value in the lower word.</dd>
<dt>Output</dt><dd><b>CF</b>=0, word value was stored to buffer.
<dt>Error</dt><dd><b>CF</b>=1</dd>
<dt>Depends on</dt><dd><a href="#BufferNew">BufferNew</a></dd>
</dl><pre>
BufferStoreWord %MACRO aBuffer, Value
     PUSHD %Value, %aBuffer
     CALL BufferStoreWord@RT
BufferStoreWord@RT: PROC1
     PUSHAD
      MOV EDX,[ESP+9*4]  ; aBuffer.
      MOV EBX,[ESP+10*4] ; Value.
      BufferNew EDX,2
      JC .90:
      MOV [EAX],BX ; Store the WORD value.
 .90:POPAD
     RET 2*4
    ENDPROC1 BufferStoreWord@RT:
 %ENDMACRO BufferStoreWord
</pre>

<dl id="BufferStoreDword"><dt><a href="#BUFFER">&uarr; BufferStoreDword</a> aBuffer, Value</dt>
<dd>will allocate 4 bytes and copy the DWORD Value to aBuffer.</dd>
<dt>Input</dt><dd><b>aBuffer</b> is a pointer to BUFFER structure
<!---->which was returned from <a href="#BufferCreate">BufferCreate</a>.
<br><b>Value</b> is a 32bit register/memory or immediate value to be stored on the buffer.</dd>
<dt>Output</dt><dd><b>CF</b>=0, Dword value was stored to buffer.
<dt>Error</dt><dd><b>CF</b>=1</dd>
<dt>Depends on</dt><dd><a href="#BufferNew">BufferNew</a></dd>
</dl><pre>
BufferStoreDword %MACRO aBuffer, Value
     PUSHD %Value, %aBuffer
     CALL BufferStoreDword@RT:
BufferStoreDword@RT: PROC1
     PUSHAD
      MOV EDX,[ESP+9*4]  ; aBuffer.
      MOV EBX,[ESP+10*4] ; Value.
      BufferNew EDX,4
      JC .90:
      MOV [EAX],EBX ; Store the DWORD value.
 .90:POPAD
     RET 2*4
    ENDPROC1 BufferStoreDword@RT:
 %ENDMACRO BufferStoreDword
</pre>

<dl id="BufferStoreQword"><dt><a href="#BUFFER">&uarr; BufferStoreQword</a> aBuffer, Value</dt>
<dd>will allocate 8 bytes, sign-extend the Value to QWORD and store it to aBuffer.</dd>
<dt>Input</dt><dd><b>aBuffer</b> is a pointer to BUFFER structure
<!---->which was returned from <a href="#BufferCreate">BufferCreate</a>.
<br><b>Value</b> is a 32bit register/memory or immediate value to be sign-extended and stored on the buffer.</dd>
<dt>Output</dt><dd><b>CF</b>=0, Qword value was stored to buffer.
<dt>Error</dt><dd><b>CF</b>=1</dd>
<dt>Depends on</dt><dd><a href="#BufferNew">BufferNew</a></dd>
</dl><pre>
BufferStoreQword %MACRO aBuffer, Value
     PUSHD %Value, %aBuffer
     CALL BufferStoreQword@RT:
BufferStoreQword@RT: PROC1
     PUSHAD
      MOV ECX,[ESP+9*4]  ; aBuffer.
      BufferNew ECX,8
      JC .90:
      MOV EDI,EAX
      MOV EAX,[ESP+10*4] ; Value.
      CDQ
      STOSD
      XCHG EDX,EAX
      STOSD
 .90:POPAD
     RET 2*4
    ENDPROC1 BufferStoreQword@RT:
 %ENDMACRO BufferStoreQword
</pre>



<dl id="BufferStoredo"><dt><a href="#BUFFER">&uarr; BufferStore$</a> aBuffer, StringPtr</dt>
<dd>Macro <dfn>BufferStore$</dfn> will store the zero-terminated string of bytes to aBuffer.
<br/>The terminating NUL byte is not stored.</dd>
<dt>Input</dt><dd><b>aBuffer</b> is a pointer to BUFFER structure
<!---->as returned from <a href="#BufferCreate">BufferCreate</a>.
<br><b>StringPtr</b> is a pointer to the first byte of the ASCIIZ string.
</dd>
<dt>Output</dt><dd><b>CF</b>=0, data are stored to buffer.
<dt>Error</dt><dd><b>CF</b>=1 when aBuffer=0.
</dd>
<dt>Depends on</dt><dd><a href="#BufferNew">BufferNew</a></dd>
</dl><pre>
BufferStore$ %MACRO aBuffer, StringPtr
     PUSHD %StringPtr, %aBuffer
     CALL BufferStore$@RT:
BufferStore$@RT: PROC1
     PUSHAD
      MOV EDX,[ESP+9*4]  ; aBuffer.
      MOV EDI,[ESP+10*4] ; StringPtr.
      TEST EDX
      MOV ESI,EDI
      STC
      JZ .90:            ; Bad buffer.
      XOR ECX,ECX
      XOR EAX,EAX
      NOT ECX
      REPNE SCASB        ; Find zero terminator.
      NOT ECX
      DEC ECX            ; ESI,ECX is now the netto string.
      JZ .90:
      BufferNew EDX,ECX
      JC .90:
      MOV EDI,EAX        ; Pointer to allocated room on buffer.
      REP MOVSB          ; Store string.
 .90:POPAD
     RET 2*4
   ENDPROC1 BufferStore$@RT:
 %ENDMACRO BufferStore$
</pre>

<dl id="BufferStorePascalString"><dt><a href="#BUFFER">&uarr; BufferStorePascalString</a> aBuffer, StringPtr, Size=-1</dt>
<dd>Macro <dfn>BufferStorePascalString</dfn> will store the string
<!---->to aBuffer, prefixed with one usigned byte integer which contains string size (0..255).
<br/>Size of the string is either explicitly specified or zero-termination is assumed.
<br/>If the string netto size exceeds 254 bytes, only 255 is stored and the macro returns CF=1.</dd>
<dt>Input</dt><dd><b>aBuffer</b> is a pointer to BUFFER structure
<!---->as returned from <a href="#BufferCreate">BufferCreate</a>.
<br><b>StringPtr</b> is a pointer to the first byte of the string.
<br><b>Size= -1</b> specifies the maximal string size. If the string is terminated with 0 byte,
<!---->only its real size is used. The terminating zero is not stored as a part of the string.</dd>
<dt>Output</dt><dd><b>CF</b>=0, data are stored to buffer.
<dt>Error</dt><dd><b>CF</b>=1 when string size exceeded 255 bytes or wrong aBuffer.
</dd>
<dt>Depends on</dt><dd><a href="#BufferNew">BufferNew</a></dd>
</dl><pre>
BufferStorePascalString %MACRO aBuffer, StringPtr, Size=-1
     PUSHD %Size, %StringPtr, %aBuffer
     CALL BufferStorePascalString@RT:
BufferStorePascalString@RT: PROC1
     PUSHAD
      MOV EDX,[ESP+9*4]  ; aBuffer.
      MOV EDI,[ESP+10*4] ; StringPtr.
      MOV ECX,[ESP+11*4] ; Size.
      TEST EDX
      MOV ESI,EDI
      STC
      JZ .90:            ; Bad buffer.
      JECXZ .20:
      SUB EAX,EAX
      REPNE SCASB        ; Find zero terminator within specified %Size.
      JNE .20:
      DEC EDI            ; Skip the terminating zero.
 .20: MOV EBX,255
      SUB EDI,ESI
      CMP EDI,EBX
      MOV ECX,EDI
      JBE .40:
      MOV ECX,EBX        ; Saturate netto size ECX to max. 0..255 characters.
 .40: LEA EDI,[ECX+1]
      BufferNew EDX,EDI
      JC .90:
      MOV EDI,EAX        ; Allocated room on buffer.
      MOV EAX,ECX
      DEC EBX            ; 254.
      STOSB              ; Store netto string size.
      CMP EBX,ECX        ; Set CF when ECX was saturated to 255.
      REP MOVSB          ; Store string.
 .90:POPAD
     RET 3*4
   ENDPROC1 BufferStorePascalString@RT:
 %ENDMACRO BufferStorePascalString
</pre>

<dl id="BufferDecrement"><dt><a href="#BUFFER">&uarr; BufferDecrement</a> aBuffer, Size=1</dt>
<dd>omits the %Size byte(s) last stored on aBuffer.</dd>
<dt>Input</dt><dd><b>aBuffer</b> is a pointer to <a href="#BUFFER">BUFFER</a> structure
<!---->which was returned from <a href="#BufferCreate">BufferCreate</a>.
<br/><b>Size</b>=1 is number of bytes to omit (immediate number or GPR other than EAX,ECX).</dd>
<dt>Output</dt><dd><b>CF</b>=0 buffer contents was decremented.
<dt>Error</dt><dd><b>CF</b>=1 (bad buffer)
</dd></dl><pre>
BufferDecrement %MACRO aBuffer, Size=1
     PUSH EAX,ECX
      MOV ECX,%aBuffer
      STC
      JECXZ BufferDecrementC%.:
      MOV EAX,[ECX+BUFFER.Ptr]
      SUB EAX,%Size
      CMP EAX,[ECX+BUFFER.Ptr]
      JBE BufferDecrementA%.:
      MOV EAX,[ECX+BUFFER.Ptr] ; If %Size was negative - ignore.
   BufferDecrementA%.:
      CMP EAX,[ECX+BUFFER.Bottom]
      JAE BufferDecrementB%.:
      MOV EAX,[ECX+BUFFER.Bottom] ; If %Size was greater than buffer contents.
   BufferDecrementB%.:
      MOV [ECX+BUFFER.Ptr],EAX
      CLC
   BufferDecrementC%.:
     POP ECX,EAX
  %ENDMACRO BufferDecrement
</pre>

<dl id="BufferResize"><dt><a href="#BUFFER">&uarr; BufferResize</a> aBuffer, Bytes, Stuff=0</dt>
<dd><p>moves the buffer pointer by %Bytes value forward or backward.
<!---->This will virtually change the size of data in aBuffer.</p>
<p>Macro does nothing when %Bytes=0. If %Bytes is negative, the data block
<!---->returned with subsequent <a href="#BufferRetrieve">BufferRetrieve</a> will be
<!---->shrinked. If %Bytes is positive, returned data block will be expanded.
<!---->The enlarged portion of data contents will be filled with %Stuff bytes.
<p>If the negative %Bytes number is larger than current data contents
<!---->available in %aBuffer, buffer pointer is reset to bottom, which is
<!---->equivalent to <a href="#BufferClear">BufferClear</a>.</p>
<p>If the buffer data enlarged with positive %Bytes is greater than
<!---->the size allocated at <a href="#BufferCreate">BufferCreate</a>,
<!---->%aBuffer will be reallocated to this enlarged new size doubled,
<!---->and old data contents will be copied from previous position to the new reallocated memory.</p>
</dd>
<dt>Input</dt><dd><b>aBuffer</b> is a pointer to <a href="#BUFFER">BUFFER</a> structure
<!---->which was returned from <a href="#BufferCreate">BufferCreate</a>.
<br/><b>Bytes</b> is immediate or 32bit GPR with number of bytes to virtually resize the buffer contents.
<br/><b>Stuff=0</b> is immediate byte or 32bit GPR which defines in its LSB what data byte will be used in case of enlarging.
</dd>
<dt>Output</dt><dd><b>CF</b>=0 Buffer pointer moved, allocation enlarged if necessary.</dd>
<dt>Error</dt><dd><b>CF</b>=1 (bad buffer or overflow)</dd>
<dt>Depends on</dt><dd><a href="#BufferStoreByte">BufferStoreByte</a></dd>
</dl><pre>
BufferResize %MACRO aBuffer, Bytes, Stuff=0
     PUSHD %Stuff, %Bytes, %aBuffer
     CALL BufferResize@RT:
BufferResize@RT: PROC1
     PUSHAD
      MOV EBX,[ESP+9*4]               ; %aBuffer.
      MOV EDX,[ESP+10*4]              ; %Bytes. It may be negative.
      TEST EBX
      STC
      JZ .90:                         ; Error: invalid buffer.
      TEST EDX
      JG .40:
      MOV EAX,[EBX+BUFFER.Ptr]        ; Shrink the buffer by -EDX bytes.
      MOV ESI,[EBX+BUFFER.Bottom]
      ADD EAX,EDX                     ; Reposition the new Ptr in EAX.
      CMP EAX,ESI
      JNB .10:
      MOV EAX,ESI                     ; Saturate if the new Ptr is below bottom.
.10:  MOV [EBX+BUFFER.Ptr],EAX
      JMP .80:
.40:  MOV EAX,[ESP+11*4]              ; Expand by EDX bytes of Stuff in EDI.
.50:  BufferStoreByte EBX,EAX
      JC .90:                         ; Abort on error.
      DEC EDX
      JNZ .50:
.80:  CLC
.90: POPAD
     RET 3*4
    ENDP1 BufferResize@RT:
 %ENDMACRO BufferResize
</pre>

<dl id="BufferRetrieve"><dt><a href="#BUFFER">&uarr; BufferRetrieve</a> aBuffer</dt>
<dd>will return pointer and size of all data currently stored in the buffer.</dd>
<dt>Input</dt><dd><b>aBuffer</b> is a pointer to BUFFER structure
<!---->which was returned from <a href="#BufferCreate">BufferCreate</a>. Macro returns ECX=ESI=0,CF=1 when aBuffer is NULL.</dd>
<dt>Output</dt><dd><b>CF</b>=0
<br/><b>ESI</b>=Ptr to the stored data (BUFFER.Bottom)
<br/><b>ECX</b>=Size of stored data (BUFFER.Ptr - BUFFER.Bottom)
<br/><b>ZF</b>=1 when ECX=0 (buffer exists and is empty).</dd>
<dt>Error</dt><dd><b>CF=1,ECX=ESI=0</b> (uncreated buffer)
</dd>
<dt>Example</dt><dd class="PRE"><!---->    BufferRetrieve EBX ; EBX is pointer to a buffer, or 0.
<!---->    JNA .NoData:       ; Jump when the buffer is empty (ECX=0,ZF=1) or hasn't been created (CF=1).
</dd></dl><pre>
BufferRetrieve %MACRO aBuffer
      %IF "%aBuffer" !== "ECX"
        MOV ECX,%aBuffer
      %ENDIF
      STC
      MOV ESI,ECX
      JECXZ BufferRetrieve%.:          ; Return CF on uncreated buffer.
      MOV ESI,[ECX+BUFFER.Bottom]
      MOV ECX,[ECX+BUFFER.Ptr]
      SUB ECX,ESI
    BufferRetrieve%.:
  %ENDMACRO BufferRetrieve
</pre>

<dl id="LIST"><dt><a href="#top">&uarr; LIST</a></dt>
<dd><p>Object LIST is FIFO/LIFO bidirectional storage for items
<!---->(leaves) of the same size. Leaves are DWORD aligned. Below the payload data of every leaf
<!---->are pointers to the next and previous leaf data.</p>
<p>Leaves are appended to the list with ListNew or ListStore methods
<!---->and the list can be searched sequentially with ListGetNext or ListGetPrev.</p>
<p>The LIST structure is created in pool memory with <a href="#ListCreate">ListCreate
</a>, it can be destroyed only when the hosting pool is destroyed.</p></dd>
<dt>Example</dt><dd class="PRE"> ; Walking the previously created MyList backwards:
<!---->    ListGetLast [MyList]
<!---->    JZ .NoMore:
<!----> .N:CALL ProcessLeafAtEAX
<!---->    ListGetPrev EAX
<!---->    JNZ .N:
<!----> .NoMore:</dd>
<dd class="PRE">
<!---->                     1st       2nd       3rd
<!---->             &#x250C;     &#x250C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2510;    &#x250C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2510;    &#x250C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2510;
<!---->             &#x2502;     &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;    &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;    &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;
<!---->    &#x250C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2510; &#x2502;     &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;    &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;    &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;
<!---->    &#x2502;.Count&#x2502; &#x2502;     &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;    &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;    &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;
<!---->    &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524; &#x2502;     &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;    &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;    &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;
<!---->    &#x2502;.Size &#x2502;&#x2500;&#x2524;     &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;    &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;    &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;
<!---->    &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524; &#x2502;     &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;    &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;    &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;
<!---->    &#x2502;.Pool &#x2502; &#x2502;     &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;    &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;    &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;
<!---->    &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524; &#x2514; &#x250C;&gt; 0&#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;&lt;&#x2510;&#x250C;&gt;&#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;&lt;&#x2510;&#x250C;&gt;&#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;&lt;&#x2510;
<!---->    &#x2502;.Last &#x2502;&#x2500;&#x2510; &#x2502;   &#x2502;  0 &#x2502; &#x2514;&#x253C;&#x2500;&#x2502;Prev&#x2502; &#x2514;&#x253C;&#x2500;&#x2502;Prev&#x2502; &#x2502;
<!---->    &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524; &#x2502; &#x2502; -4&#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;  &#x2502; &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;  &#x2502; &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524; &#x2502;
<!---->    &#x2502;.First&#x2502;&#x2500;&#x253C;&#x2500;&#x2518;   &#x2502;Next&#x2502;&#x2500;&#x2500;&#x2518; &#x2502;Next&#x2502;&#x2500;&#x2500;&#x2518; &#x2502;  0 &#x2502; &#x2502;
<!---->    &#x2514;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2518; &#x2502;   -8&#x2514;&#x2500;&#x2500;&#x2500;&#x2500;&#x2518;    &#x2514;&#x2500;&#x2500;&#x2500;&#x2500;&#x2518;    &#x2514;&#x2500;&#x2500;&#x2500;&#x2500;&#x2518; &#x2502;
<!---->             &#x2514;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2518;
</dd></dl><pre>
LIST STRUC
 .First D D ; Pointer to the first stored leaf.
 .Last  D D ; Pointer to the last stored leaf.
 .Pool  D D ; Pool handle obtained from <a href="#PoolCreate">PoolCreate</a>.
 .Size  D D ; Data item netto size.
 .Count D D ; Number of stored items.
 ENDSTRUC LIST
</pre>

<dl id="ListCreate"><dt><a href="#LIST">&uarr; ListCreate</a> aPool, Size</dt>
<dd>will allocate an empty LIST structure on the pool specified
<!---->with the first parameter.</dd>
<dt>Input</dt><dd><b>aPool</b> is a pointer to a <a href="#POOL">POOL</a> structure
<!---->which was returned from <a href="#PoolCreate">PoolCreate</a>.
<br><b>Size=</b> is the size of data items which will be stored on the list later.</dd>
<dt>Output</dt><dd><b>CF</b>=0, <b>EAX</b>=pointer to the LIST structure (list handle).
<dt>Error</dt><dd><b>CF</b>=1, <b>EAX</b> undefined (Pool error)</dd>
<dt>Depends on</dt><dd><a href="#PoolNew">PoolNew</a></dd></dl><pre>
ListCreate %MACRO aPool, Size
        PUSHD %Size, %aPool
        CALL ListCreate@RT:
ListCreate@RT: PROC1
        PUSHAD
         MOV EDX,[ESP+9*4]             ; %aPool.
         MOV ECX,[ESP+10*4]            ; %Size.
         PoolNew EDX, SIZE#LIST, Align=DWORD, Zeroed=Yes
         MOV [ESP+7*4],EAX             ; %ReturnEAX.
         JC .90:
         MOV [EAX+LIST.Pool],EDX
         MOV [EAX+LIST.Size],ECX
  .90:  POPAD
        RET 2*4
  ENDPROC1 ListCreate@RT:
 %ENDMACRO ListCreate
</pre>

<dl id="ListNew"><dt><a href="#LIST">&uarr; ListNew</a> aList, Zeroed=No</dt>
<dd>will allocate an empty space for one leaf (plus two pointers) and append it on the list.</dd>
<dt>Input</dt><dd><b>aList</b> is a pointer to LIST structure
<!---->which was returned from <a href="#ListCreate">ListCreate</a>.
<br><b>Zeroed=No</b> Zeroed=Yes will clear the just allocated memory.
<dt>Output</dt><dd><b>CF</b>=0, <b>EAX</b>=pointer to the allocated space (LIST.Size bytes).
<dt>Error</dt><dd><b>CF</b>=1, <b>EAX</b>=0 (Pool error)
</dd></dl><pre>
ListNew %MACRO aList, Zeroed=No
        %IF %Zeroed
          PUSHD -1
        %ELSE
          PUSHD 0
        %ENDIF
        PUSHD %aList
        CALL ListNew@RT:
ListNew@RT: PROC1
        PUSHAD
         MOV EBX,[ESP+9*4]  ; %aList.
         MOV [ESP+7*4],EBX  ; %ReturnEAX.
         TEST EBX
         STC
         JZ .90: ; Bad object.
         MOV ECX,[EBX+LIST.Size]
         ADD ECX,8          ; Additional room for two pointers.
         PoolNew [EBX+LIST.Pool],ECX, Align=DWORD
         MOV [ESP+7*4],EAX  ; %ReturnEAX.
         JC .90:
         MOV EDI,EAX
         MOV ESI,[EBX+LIST.Last]
         SUB EAX,EAX
         STOSD              ; Pointer Next.
         MOV EAX,ESI        ; LIST.Last may be 0 if this is the first leaf.
         STOSD              ; Pointer Prev.
         TEST EAX
         JZ .30:            ; If this leaf EDI is the first.
         MOV [ESI-8],EDI    ; EDI is pointer to this new leaf.
    .30: MOV [EBX+LIST.Last],EDI
         CMPD [EBX+LIST.First],0
         JNE .80:
         MOV [EBX+LIST.First],EDI
    .80: MOV [ESP+7*4],EDI  ; %ReturnEAX.
         INCD [EBX+LIST.Count]
         XOR EAX,EAX
         CMP EAX,[ESP+10*4] ; %Zeroed.
         JE .90:            ; If Zeroed=No.
         MOV ECX,[EBX+LIST.Size]
         REP STOSB          ; Clear the leaf payload area.
         CLC
    .90:POPAD
        RET 2*4
  ENDPROC1 ListNew@RT:
 %ENDMACRO ListNew
</pre>

<dl id="ListStore"><dt><a href="#LIST">&uarr; ListStore</a> aList, DataPtr</dt>
<dd>will allocate an empty space for one leaf, append it on the list
<!---->and copy the Data to this space.</dd>
<dt>Input</dt><dd><b>aList</b> is a pointer to LIST structure
<!---->which was returned from <a href="#ListCreate">ListCreate</a>.
<br><b>DataPtr</b> is pointer to the data to be stored on list.
<!---->Size of the data was specified in ListCreate.
<dt>Output</dt><dd><b>CF</b>=0, <b>EAX</b>=pointer to the stored data on the list.
<dt>Error</dt><dd><b>CF</b>=1, <b>EAX</b>=0
<dt>Depends on</dt><dd><a href="#ListNew">ListNew</a>
</dd></dl><pre>
ListStore %MACRO aList, DataPtr
        PUSHD %DataPtr, %aList
        CALL ListStore@RT:
ListStore@RT: PROC1
       PUSHAD
        MOV EBX,[ESP+9*4]  ; %aList.
        MOV ESI,[ESP+10*4] ; %DataPtr.
        SUB EAX,EAX
        TEST EBX
        STC
        JZ .90:
        ListNew EBX, Zeroed=No
        JC .90:
        MOV EDI,EAX
        MOV ECX,[EBX+LIST.Size]
        REP MOVSB
   .90: MOV [ESP+7*4],EAX  ; %ReturnEAX.
       POPAD
       RET 2*4
  ENDPROC1 ListStore@RT:
 %ENDMACRO ListStore
</pre>

<dl id="ListInsert"><dt><a href="#LIST">&uarr; ListInsert</a> aList, PrevLeaf, DataPtr</dt>
<dd>will insert a new leaf right behind PrevLeaf on the List, update links
<!---->and copy the Data to this space.</dd>
<dt>Input</dt><dd><b>aList</b> is a pointer to LIST structure
<!---->which was returned from ListCreate.
<br/><b>PrevLeaf</b> is pointer to an existing leaf. When it is 0, data will be stored to the 1st position
<br/>on the list then (same as ListStore).
<br><b>DataPtr</b> is pointer to the data to be stored on list. It may be 0,
<!---->an empty list is inserted in this case. Size of the data was specified in <a href="#ListCreate">ListCreate</a>.
<dt>Output</dt><dd><b>CF</b>=0, <b>EAX</b>=pointer to the stored data (LIST.Size bytes).
<dt>Error</dt><dd><b>CF</b>=1, <b>EAX</b>=0
</dd></dl><pre>
ListInsert %MACRO aList, PrevLeaf, DataPtr
       PUSHD %DataPtr, %PrevLeaf, %aList
       CALL ListInsert@RT:
ListInsert@RT: PROC1
      PUSHAD
       MOV EBX,[ESP+9*4]  ; %aList.
       MOV ESI,[ESP+10*4] ; %PrevLeaf.
       XOR EAX,EAX
       MOV [ESP+7*4],EAX  ; %ReturnEAX.
       TEST EBX
       STC
       JZ .90:
       MOV ECX,[EBX+LIST.Size]
       ADD ECX,8          ; Additional room for two pointers.
       PoolNew [EBX+LIST.Pool],ECX,Align=DWORD
       JC .90:
       INCD [EBX+LIST.Count]
       MOV EDI,EAX
       TEST ESI
       JNZ .30:
       MOV EAX,[EBX+LIST.First]
       MOV EDX,EAX
       STOSD              ; Next.
       MOV EAX,ESI
       STOSD              ; Prev.
       MOV [EBX+LIST.First],EDI
       JMP .40:
.30:   MOV EAX,[ESI-8]    ; Next.
       MOV EDX,EAX
       STOSD              ; Next.
       MOV EAX,ESI
       STOSD              ; Prev.
       MOV [ESI-8],EDI
 .40:  MOV [ESP+7*4],EDI  ; %ReturnEAX.
       TEST EDX
       JZ .50:
       MOV [EDX-4],EDI    ; Prev.
 .50:  JNZ .60:
       MOV [EBX+LIST.Last],EDI
 .60:  SUB ECX,8
       MOV ESI,[ESP+11*4] ; %DataPtr.
       TEST ESI
       JNZ .80:
       XOR EAX,EAX
       REP STOSB
       JMP .90:
 .80:  REP MOVSB
 .90: POPAD
      RET 3*4.
 ENDPROC1 ListInsert@RT:
%ENDMACRO ListInsert
</pre>

<dl id="ListRemove"><dt><a href="#LIST">&uarr; ListRemove</a> aList, LeafPtr</dt>
<dd>removes one leaf from the list. The old data stays on pool but links
<!---->are updated and the removed leaf is skipped.</dd>
<dt>Input</dt><dd><b>aList</b> is a pointer to LIST structure
<!---->which was returned from <a href="#ListCreate">ListCreate</a>.
<br><b>LeafPtr</b> is pointer to the leaf data which is to be removed.
<dt>Output</dt><dd><b>ZF</b>=1 if the list is now empty </dd>
<dt>Error</dt><dd>-</dd></dl><pre>
ListRemove %MACRO aList, LeafPtr
        PUSHD %LeafPtr, %aList
        CALL ListRemove@RT:
ListRemove@RT: PROC1
      PUSHAD
       MOV EBX,[ESP+9*4]  ; %aList.
       MOV EDX,[ESP+10*4] ; %LeafPtr.
       TEST EBX
       JZ .90:
       TEST EDX
       JZ .90:
       MOV ESI,[EDX-4]    ; Prev.
       MOV EDI,[EDX-8]    ; Next.
       TEST ESI
       JZ .30:
       MOV [ESI-8],EDI    ; Next.
       TEST EDI
       JZ .50:
 .20:  MOV [EDI-4],ESI    ; Prev.
       JMP .80:
 .30:  MOV [EBX+LIST.First],EDI ; The first leaf was removed.
       TEST EDI
       JNZ .20:
 .50:  MOV [EBX+LIST.Last],ESI ; The last leaf was removed.
 .80:  DECD [EBX+LIST.Count]
 .90: POPAD
      RET 2*4
  ENDPROC1 ListRemove@RT:
 %ENDMACRO ListRemove
</pre>

<dl id="ListGetFirst"><dt><a href="#LIST">&uarr; ListGetFirst</a> aList</dt>
<dd>will return pointer to the data which was stored as the first leaf.</dd>
<dt>Input</dt><dd><b>aList</b> is a pointer to LIST structure
<!---->which was returned from <a href="#ListCreate">ListCreate</a>.</dd>
<dt>Output</dt><dd><b>ZF</b>=0, <b>EAX</b>=pointer to the first leaf of stored data.</dd>
<dt>Error</dt><dd><b>ZF</b>=1, <b>EAX</b>=0 if the list is empty.</dd></dl><pre>
ListGetFirst %MACRO aList
       PUSH ECX
        MOV ECX,%aList
        SUB EAX,EAX
        JECXZ ListGetFirst%.:
        MOV EAX,[ECX+LIST.First]
        ListGetFirst%.:
        TEST EAX
       POP ECX
  %ENDMACRO ListGetFirst
</pre>

<dl id="ListGetNext"><dt><a href="#LIST">&uarr; ListGetNext</a> LeafPtr</dt>
<dd>will return pointer to the leaf which was stored right after
<!---->the leaf specified with the first parameter.</dd>
<dt>Input</dt><dd><b>LeafPtr</b> is a pointer to data
<!---->which was returned from ListGetFirst/Next/Last/Prev.</dd>
<dt>Output</dt><dd><b>ZF</b>=0, <b>EAX</b>=pointer to the following leaf of stored data.
<br><b>ZF</b>=1 <b>EAX</b>=0 if there are no more leaves on list (LeafPtr was the last).
</dd></dl><pre>
ListGetNext %MACRO LeafPtr
       PUSH ECX
        MOV ECX,%LeafPtr
        SUB EAX,EAX
        JECXZ ListGetNext%.:
        MOV EAX,[ECX-8]
        ListGetNext%.:
        TEST EAX
       POP ECX
  %ENDMACRO ListGetNext
</pre>

<dl id="ListGetLast"><dt><a href="#LIST">&uarr; ListGetLast</a> aList</dt>
<dd>will return pointer to the data which was stored as the last leaf.</dd>
<dt>Input</dt><dd><b>aList</b> is a pointer to LIST structure
<!---->which was returned from <a href="#ListCreate">ListCreate</a>.</dd>
<dt>Output</dt><dd><b>ZF</b>=0, <b>EAX</b>=pointer to the last leaf of stored data.</dd>
<dt>Error</dt><dd><b>ZF</b>=1, <b>EAX</b>=0 if the list is empty.</dd></dl><pre>
ListGetLast %MACRO aList
       PUSH ECX
        MOV ECX,%aList
        SUB EAX,EAX
        JECXZ ListGetLast%.:
        MOV EAX,[ECX+LIST.Last]
        ListGetLast%.:
        TEST EAX
       POP ECX
   %ENDMACRO ListGetLast
</pre>

<dl id="ListGetPrev"><dt><a href="#LIST">&uarr; ListGetPrev</a> LeafPtr</dt>
<dd>will return pointer to the leaf which was stored right before
<!---->the leaf specified with the 1st parameter.</dd>
<dt>Input</dt><dd><b>LeafPtr</b> is a pointer to data
<!---->which was returned from ListGetFirst/Next/Last/Prev.</dd>
<dt>Output</dt><dd><b>ZF</b>=0, <b>EAX</b>=poiubter to the previous leaf of stored data.
<br/><b>ZF</b>=1, <b>EAX</b>=0 if there are no more leaves on list (LeafPtr was the first).
</dd></dl><pre>
ListGetPrev %MACRO LeafPtr
       PUSH ECX
        MOV ECX,%LeafPtr
        SUB EAX,EAX
        JECXZ ListGetPrev%.:
        MOV EAX,[ECX-4]
        ListGetPrev%.:
        TEST EAX
       POP ECX
  %ENDMACRO ListGetPrev
</pre>

<dl id="STACK"><dt><a href="#top">&uarr; STACK</a></dt>
<dd><p>Object STACK is LIFO storage for items of the same size.
<!---->Stacked items are DWORD aligned and stored continuously
<!---->in one pool block. Stack grows upward, STACK.Ptr is increased
<!---->with StackPush and decreased with StackPop.</p>
<p>Whenever the initial stack depth specified in StackCreate is not big enough,
<!---->which may happen in <a href="#StackPush">StackPush</a>,
<!---->the stack is reallocated with doubled size, old content
<!---->is copied to the new location and abandoned.
<!---->The STACK structure itself stays in its original position.</p>
<p>Stack contents can be erased with <a href="#StackClear">StackClear</a>.</p>
<blockquote>The STACK object should not be confused with machine stack adressed with SS:ESP.</blockquote></dd>
<dt>Example</dt><dd class="PRE">
<!---->  INCLUDE1 "winapi.htm", "memory32.htm" ; PoolCreate requires the macro MemAlloc from "winapi.htm" or "linapi.htm".
<!---->MyObject STRUC       ; Define object which will be using the stack.
<!----> .Member1 DD DWORD
<!----> .Member2 DD DWORD
<!---->  ENDSTRUC MyObject
<!---->MyPool  DD 0
<!---->MyStack DD 0
<!---->[.text]
<!---->   PoolCreate Size=16K ; Create a pool (or reuse previously created one).
<!---->   MOV [MyPool],EAX
<!---->   JC .Error:
<!---->   StackCreate EAX, SIZE# MyObject, Depth=5
<!---->   MOV [MyStack],EAX
<!---->   JC .Error:
<!---->   ; MyStack can be used now (StackPush, StackPeekLast, StackPop etc).
<!---->   PoolDestroy [MyPool] ; Return pool memory to OS at the end of program.</dd>
<dd class="PRE">          Depth=5
<!---->         &#x250C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2510;<&#x2500;&#x2500;&#x2510;
<!---->         &#x2502;       &#x2502;   &#x2502;
<!---->         &#x2502;       &#x2502;   &#x2502;
<!---->         &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;   &#x2502;
<!---->         &#x2502;       &#x2502;   &#x2502;
<!---->         &#x2502;       &#x2502;   &#x2502;
<!---->         &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;<&#x2500;&#x2510;&#x2502;
<!---->         &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;  &#x2502;&#x2502;
<!---->         &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;  &#x2502;&#x2502;
<!---->         &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;  &#x2502;&#x2502;
<!---->         &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;  &#x2502;&#x2502;
<!---->         &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;  &#x2502;&#x2502;
<!---->        &#x250C;&#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;  &#x2502;&#x2502;
<!---->        &#x2502;&#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;  &#x2502;&#x2502;
<!---->       &#x250C;&#x2524;&#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;  &#x2502;&#x2502;
<!---->       &#x2502;&#x2514;&#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;<&#x2510;&#x2502;&#x2502;
<!---->       &#x2502; &#x2502;.Bottom&#x2502;&#x2500;&#x2518;&#x2502;&#x2502;
<!---->       &#x2502; &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;  &#x2502;&#x2502;
<!---->       &#x2502; &#x2502;.Ptr   &#x2502;&#x2500;&#x2500;&#x2518;&#x2502;
<!---->       &#x2502; &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;   &#x2502;
<!---->       &#x2502; &#x2502;.Top   &#x2502;&#x2500;&#x2500;&#x2500;&#x2518;
<!---->       &#x2502; &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;
<!---->       &#x2514;&#x2500;&#x2502;.Size  &#x2502;
<!---->         &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;
<!---->         &#x2502;.Pool  &#x2502;
<!---->         &#x2514;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2518;
</dd></dl><pre>
STACK STRUC
 .Pool   D D ; Pool handle obtained from PoolCreate.
 .Size   D D ; Size of one stacked item.
 .Top    D D ; Pointer to the end of allocated space.
 .Ptr    D D ; Pointer to the free space on STACK.
 .Bottom D D ; Pointer to the oldest pushed item.
 ENDSTRUC STACK
</pre>

<dl id="StackCreate"><dt><a href="#STACK">&uarr; StackCreate</a> aPool, Size, Depth=16</dt>
<dd>will allocate an empty STACK on the pool specified
<!---->with the first parameter.</dd>
<dt>Input</dt><dd><b>aPool</b> is a pointer to a <a href="#POOL">POOL</a> structure
<!---->which was returned from <a href="#PoolCreate">PoolCreate</a>.
<br><b>Size</b> is the size of each data object which will be pushed on the stack later.
<br><b>Depth=</b>16 is the estimated maximal number of pushed objects.
<br/>Underestimated depth will be increased automatically if necessary
<!---->but this will waste the memory a little.</dd>
<dt>Output</dt><dd><b>CF</b>=0 <b>EAX</b>=pointer to the STACK (Stack handle).</dd>
<dt>Error</dt><dd><b>CF=1</b>, EAX=0 if pool allocation failed.</dd></dl><pre>
StackCreate %MACRO aPool, Size, Depth=16
      PUSHD %Depth, %Size, %aPool
      CALL StackCreate@RT:
StackCreate@RT: PROC1
     PUSHAD
      MOV EAX,[ESP+10*4] ; %Size.
      MOV ESI,[ESP+9*4]  ; %aPool.
      MOV ECX,EAX
      MULD [ESP+11*4]    ; %Depth.
      MOV EBX,EAX
      ADD EAX,SIZE#STACK
      PoolNew ESI,EAX,Align=DWORD
      MOV [ESP+7*4],EAX  ; %ReturnEAX.
      JC .90:
      MOV [EAX+STACK.Pool],ESI
      MOV [EAX+STACK.Size],ECX
      LEA EDI,[EAX+SIZE#STACK]
      MOV [EAX+STACK.Bottom],EDI
      MOV [EAX+STACK.Ptr],EDI
      ADD EDI,EBX
      MOV [EAX+STACK.Top],EDI
 .90:POPAD
     RET 3*4
  ENDPROC1 StackCreate@RT:
 %ENDMACRO StackCreate
</pre>

<dl id="StackClear"><dt><a href="#STACK">&uarr; StackClear</a> aStack</dt>
<dd>will empty the stack. Old data are not erased and the stack memory remains allocated.</dd>
<dt>Input</dt><dd><b>aStack</b> is a pointer to STACK structure
<!---->which was returned from <a href="#StackCreate">StackCreate</a>.
<dt>Output</dt><dd>-</dd>
<dt>Error</dt><dd>-</dd></dl><pre>
StackClear %MACRO aStack
      PUSHD EBX, %aStack
      POP EBX
      PUSHD [EBX+STACK.Bottom]
      POPD  [EBX+STACK.Ptr], EBX
   %ENDMACRO StackClear
</pre>

<dl id="StackPush"><dt><a href="#STACK">&uarr; StackPush</a> aStack, DataPtr</dt>
<dd>will copy the data on stack and increase STACK.Ptr.</dd>
<dt>Input</dt><dd><b>aStack</b> is a pointer to STACK structure
<!---->which was returned from <a href="#StackCreate">StackCreate</a>.
<br><b>DataPtr</b> is pointer to the data to be pushed.
<!---->DataPtr may be 0; zeroes will be pushed on the Stack in this case.
<!---->Data size was specified in <a href="#StackCreate">StackCreate</a>.</dd>
<dt>Output</dt><dd><b>CF</b>=0, <b>EAX</b>=pointer to the just pushed data item on stack,
<!---->i.e. STACK.Ptr before this macro was invoked.</dd>
<dt>Error</dt><dd><b>CF</b>=1 (Pool error)</dd></dl><pre>
StackPush %MACRO aStack, DataPtr
     PUSHD %DataPtr, %aStack
     CALL StackPush@RT:
StackPush@RT: PROC1
     PUSHAD
      MOV EBX,[ESP+9*4]                ; %aStack
      TEST EBX
      STC
      JZ .90:
 .10: MOV EDI,[EBX+STACK.Ptr]
      CMP EDI,[EBX+STACK.Top]
      JB .50:
     ; <b>Not enough space on stack</b>.
      MOV EAX,[EBX+STACK.Top]
      MOV ESI,[EBX+STACK.Bottom]
      SUB EAX,ESI
      MOV ECX,EAX
      LEA EDX,[EAX+EAX]                ; Double the stack room.
      PoolNew [EBX+STACK.Pool],EDX, Align=DWORD
      JC .90:
      MOV EDI,EAX                      ; New room with doubled size (STACK.Bottom).
      MOV [EBX+STACK.Bottom],EAX
      ADD EDX,EAX                      ; New STACK.Top.
      REP MOVSB                        ; Copy old stack content.
      MOV [EBX+STACK.Ptr],EDI
      MOV [EBX+STACK.Top],EDX
 .50: ; <b>There is sufficient free space on stack now</b>.
      MOV ESI,[ESP+10*4]               ; %DataPtr.
      MOV ECX,[EBX+STACK.Size]
      MOV [ESP+7*4],EDI                ; STACK.Ptr before StackPush.
      TEST ESI
      JZ .70:                          ; Go to store zeroes when NULL data pointer was provided.
      REP MOVSB                        ; Otherwise copy the data.
      JMP .80:
 .70: SUB EAX,EAX
      REP STOSB
 .80: MOV [EBX+STACK.Ptr],EDI          ; Update the new incremented stack pointer.
      CLC
 .90:POPAD
     RET 2*4
  ENDPROC1 StackPush@RT:
 %ENDMACRO StackPush
</pre>

<dl id="StackPop"><dt><a href="#STACK">&uarr; StackPop</a> aStack</dt>
<dd>will decrease STACK.Ptr and return pointer to the popped data.</dd>
<dt>Input</dt><dd><b>aStack</b> is a pointer to STACK structure
<!---->which was returned from <a href="#StackCreate">StackCreate</a>.</dd>
<dt>Output</dt><dd><b>CF</b>=0, <b>EAX</b>=pointer to the just popped data item on stack,
<!---->i.e. STACK.Ptr after this macro was invoked.
<br>Although the data item is technically popped from the stack,
<!---->it is still available at the pointer returned in EAX until
<!---->another StackPush will overwrite it.</dd>
<dt>Error</dt><dd><b>CF</b>=1, <b>EAX=</b>undefined when he stack was empty.</dd></dl><pre>
StackPop %MACRO aStack
     PUSHD ECX,%aStack
      POP ECX
      STC
      JECXZ StackPop%.:                ; Bad parameter.
      MOV EAX,[ECX+STACK.Ptr]
      SUB EAX,[ECX+STACK.Size]
      CMP EAX,[ECX+STACK.Bottom]
      JC StackPop%.:                   ; If the stack is empty.
      MOV [ECX+STACK.Ptr],EAX
 StackPop%.:
     POP ECX
 %ENDMACRO StackPop
</pre>

<dl id="StackPeekLast"><dt><a href="#STACK">&uarr; StackPeekLast</a> aStack</dt>
<dd>will return pointer to the latest pushed data but, unlike StackPop,
<!---->it does not remove the data from stack. STACK.Ptr is unchanged.</dd>
<dt>Input</dt><dd><b>aStack</b> is a pointer to the STACK structure
<!---->which was returned from <a href="#StackCreate">StackCreate</a>.</dd>
<dt>Output</dt><dd><b>CF</b>=0, <b>EAX</b>=pointer to the last data object on stack.
<dt>Error</dt><dd><b>CF</b>=1, <b>EAX</b>=undefined. The stack was empty, nothing to peek at.
</dd></dl><pre>
StackPeekLast %MACRO aStack
      PUSH ECX
       SUB EAX,EAX
       MOV ECX,%aStack
       STC
       JECXZ StackPeekLast%.:
       MOV EAX,[ECX+STACK.Ptr]
       SUB EAX,[ECX+STACK.Size]
       CMP EAX,[ECX+STACK.Bottom]
      StackPeekLast%.:
      POP ECX
 %ENDMACRO StackPeekLast
</pre>

<dl id="StackPeekPrev"><dt><a href="#STACK">&uarr; StackPeekPrev</a> aStack, DataPtr</dt>
<dd>will return pointer to the data item predecessing the object
<!---->specified with DataPtr. STACK.Ptr is unchanged.</dd>
<dt>Input</dt><dd><b>aStack</b> is a pointer to STACK structure
<!---->which was returned from <a href="#StackCreate">StackCreate</a>.
<br><b>DataPtr</b> is pointer to data item returned from
<!---->invocation of StackPeekLast or StackPeekPrev.</dd>
<dt>Output</dt><dd><b>CF</b>=0, <b>EAX</b>=pointer to the previous data item on stack.
<dt>Error</dt><dd><b>CF</b>=1, <b>EAX=</b>undefined at the bottom of stack, nothing to peek at.
</dd></dl><pre>
StackPeekPrev %MACRO aStack, DataPtr
    PUSH ECX
     PUSHD %aStack
     POP ECX
     STC
     JECXZ StackPeekPrev%.:
     %IF "%DataPtr" == "ECX"
       MOV EAX,[ESP]
     %ELSE
       MOV EAX,%DataPtr
     %ENDIF
     SUB EAX,[ECX+STACK.Size]
     CMP EAX,[ECX+STACK.Bottom]
    StackPeekPrev%.:
   POP ECX
 %ENDMACRO StackPeekPrev
</pre>


<dl id="STREAM"><dt><a href="#top">&uarr; STREAM</a></dt>
<dd><p>Object STREAM is an unformated FIFO storage for items of unlimited size.
<!---->Unlike the BUFFER, data is not guaranteed to be stored continuously.
<!---->Memory blocks (containers for stored data) are allocated on demand with fixed size
<!---->and their every byte is used, thus the memory is exploited very efficiently.
<br/>The STREAM structure itself is appended below the first block,
<!---->all other continuation block have pointer to the next block appended below them.</p>
<p>Stream-store operations advance <code>STREAM.WritePtr</code>, stream-read operations advance
<code>STREAM.ReadPtr</code>. Stream should not be read by more threads concurently.</p>
<p>Typical usage of stream is collecting data with StreamStore* and then retrieving
<!---->all data at once.</p></dd>
<dd class="PRE">
<!---->   &#x250C;   &#x250C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2510;    &#x250C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2510;    &#x250C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2510;&lt;&#x2500;&#x2500;&#x2500;&#x2510;
<!---->   &#x2502;   &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;    &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;    &#x2502;          &#x2502;    &#x2502;
<!---->   &#x2502;   &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;    &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;    &#x2502;          &#x2502;    &#x2502;
<!---->   &#x2502;   &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;    &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;    &#x2502;          &#x2502;    &#x2502;
<!---->   &#x2502;   &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;    &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;    &#x2502;          &#x2502;&lt;&#x2500;&#x2510; &#x2502;
<!---->   &#x2502;   &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;    &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;    &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;  &#x2502; &#x2502;
<!---->  &#x250C;&#x2524;   &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;    &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;    &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;  &#x2502; &#x2502;
<!---->  &#x2502;&#x2502;   &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;    &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;    &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;  &#x2502; &#x2502;
<!---->  &#x2502;&#x2502;   &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;    &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;    &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;  &#x2502; &#x2502;
<!---->  &#x2502;&#x2502;   &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;    &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;    &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;  &#x2502; &#x2502;
<!---->  &#x2502;&#x2502;   &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;    &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;    &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;  &#x2502; &#x2502;
<!---->  &#x2502;&#x2502;   &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;    &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;    &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;  &#x2502; &#x2502;
<!---->  &#x2502;&#x2514; &#x250C;&gt;&#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524; &#x250C;&#x2500;&gt;&#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524; &#x250C;&#x2500;&gt;&#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;  &#x2502; &#x2502;
<!---->  &#x2502;  &#x2502; &#x2502;.Next     &#x2502;&#x2500;&#x2518;  &#x2502;.Next     &#x2502;&#x2500;&#x2518;  &#x2502;.Next=0   &#x2502;  &#x2502; &#x2502;
<!---->  &#x2502;  &#x2502; &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;    &#x2514;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2518;    &#x2514;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2518;  &#x2502; &#x2502;
<!---->  &#x2502;  &#x2502; &#x2502;.WritePtr &#x2502;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2518; &#x2502;
<!---->  &#x2502;  &#x2502; &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;                                    &#x2502;
<!---->  &#x2502;  &#x2514;&#x2500;&#x2502;.ReadPtr  &#x2502;                                    &#x2502;
<!---->  &#x2502;    &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;                                    &#x2502;
<!---->  &#x2502;    &#x2502;.Top      &#x2502;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2518;
<!---->  &#x2502;    &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;
<!---->  &#x2514;&#x2500;&#x2500;&#x2500;&#x2500;&#x2502;.BufSize  &#x2502;
<!---->       &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;
<!---->       &#x2502;.Pool     &#x2502;
<!---->       &#x2514;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2518;
</dd></dl><pre>
 STREAM STRUC
.Pool     D D ; Pool handle obtained from <a href="#PoolCreate">PoolCreate</a>.
.BufSize  D D ; Netto size of each block (without the linking pointer).
.Top      D D ; End of the last block.
.ReadPtr  D D ; Pointer to the unread data.
.WritePtr D D ; Pointer to the free position in the last block.
.Next     D D ; Pointer to the bottom of the next block. NULL if only 1 block is allocated.
ENDSTRUC STREAM
 </pre>

<dl id="StreamCreate"><dt><a href="#STREAM">&uarr; StreamCreate</a> Pool, BufSize=16K</dt>
<dd>will allocate stream object on the pool specified
<!---->with the first parameter.</dd>
<dt>Input</dt><dd><b>Pool</b> is a pointer to POOL structure
<!---->which was returned from <a href="#PoolCreate">PoolCreate</a>.
<br><b>BufSize=</b> is the requested netto size of each buffer.</dd>
<dt>Output</dt><dd><b>CF=</b>0 <b>EAX</b>=pointer to the stream instance.
<dt>Error</dt><dd><b>CF=</b>1 <b>EAX=</b>undefined on pool error.</dd>
<dt>Depends on</dt><dd><a href="#PoolNew">PoolNew</a></dd></dl><pre>
StreamCreate %MACRO Pool, BufSize=16K
      PUSHD %BufSize, %Pool
      CALL StreamCreate@RT:
StreamCreate@RT: PROC1
      PUSHAD
       MOV EBX,[ESP+9*4]               ; %Pool.
       MOV ECX,[ESP+10*4]              ; %BufSize.
       LEA EDX,[ECX+SIZE#STREAM]
       PoolNew EBX, EDX, Align=DWORD
       MOV [ESP+7*4],EAX               ; %ReturnEAX.
       JC .90:
       MOV [EAX+STREAM.Pool],EBX
       LEA EBX,[EAX+SIZE#STREAM]
       MOV [EAX+STREAM.BufSize],ECX
       MOV [EAX+STREAM.ReadPtr],EBX
       MOV [EAX+STREAM.WritePtr],EBX
       MOVD [EBX-4],0
       ADD EBX,ECX
       MOV [EAX+STREAM.Top],EBX
 .90: POPAD
      RET 2*4
  ENDPROC1 StreamCreate@RT:
 %ENDMACRO StreamCreate
</pre>


<dl id="StreamGetSize"><dt><a href="#STREAM">&uarr; StreamGetSize</a> Stream</dt>
<dd>returns the total amount of data written to the stream in bytes.</dd>
<dt>Input</dt><dd><b>Stream</b> ^STREAM obtained in StreamCreate.</dd>
<dt>Output</dt><dd><b>EAX=</b> total size of data in the stream.</dd></dl><pre>
StreamGetSize %MACRO Stream
      PUSHD %Stream
      CALL StreamGetSize@RT:
StreamGetSize@RT: PROC1
      PUSHAD
       SUB EAX,EAX
       MOV EBX,[ESP+9*4]               ; %Stream.
       MOV [ESP+7*4],EAX               ; Returned size.
       LEA ESI,[EBX+SIZE#STREAM]
       MOV EAX,[EBX+STREAM.WritePtr]
       MOV ECX,[EBX+STREAM.BufSize]
 .10:  CMP EAX,ESI
       JB .20:
       LEA EDI,[ESI+ECX]
       CMP EAX,EDI
       JNA .30:
 .20:  ADD [ESP+7*4],ECX               ; %ReturnEAX.
       MOV ESI,[ESI-4]
       JMP .10:
 .30:  SUB EAX,ESI
       ADD [ESP+7*4],EAX               ; %ReturnEAX.
 .90: POPAD
      RET 1*4
  ENDPROC1 StreamGetSize@RT:
 %ENDMACRO StreamGetSize
</pre>

<dl id="StreamReadByte"><dt><a href="#STREAM">&uarr; StreamReadByte</a> Stream</dt>
<dd>Macro <dfn>StreamReadByte</dfn> will retrieve one byte from the Stream at position STREAM.ReadPtr
<!---->and advance the position. The stream should be reset to start with the first byte.</dd>
<dt>Input</dt><dd><b>Stream</b> is pointer to the STREAM object obtained in <a href="#StreamCreate">StreamCreate</a>.</dd>
<dt>Output</dt><dd><b>CF=</b>0, <b>EAX=</b> a byte read from the stream is in AL.</dd>
<dt>End of data</dt><dd><b>CF=</b>1, EAX=undefined at the end of stream data.</dd>
<dt>See also</dt><dd><a href="#StreamReset">StreamReset</a></dd>
</dl><pre>
StreamReadByte %MACRO Stream
      PUSHD %Stream
      CALL StreamReadByte@RT:
StreamReadByte@RT: PROC1
      PUSHAD
        MOV EBX,[ESP+9*4]         ; %Stream.
        MOV EBP,[EBX+STREAM.BufSize]
        MOV EDX,[EBX+STREAM.Next] ; Pointer to the next block, or 0.
        LEA ESI,[EBX+SIZE#STREAM] ; Bottom of data in the first block.
        LEA ECX,[ESI+EBP]         ; Top of the first block.
.10:    ; If the .WritePtr is in the block ESI..ECX, decrement ECX to its value.
        CMP [EBX+STREAM.WritePtr],ESI
        JB .20:
        CMP [EBX+STREAM.WritePtr],ECX
        JAE .20:
        MOV ECX,[EBX+STREAM.WritePtr]
.20:    MOV EDI,[EBX+STREAM.ReadPtr]
        ; If the .ReadPtr is in the block ESI..ECX, read one byte from it.
        CMP EDI,ESI
        JB .50:                   ; Try the next block.
        CMP EDI,ECX               ; Check if STREAM.ReadPtr EDI belongs to this data block ESI..ECX.
        JA .50:                   ; Try the next block.
        JE .60:                   ; If .ReadPtr points to the top of block, move it to the bottom of the next block.
        XCHG ESI,EDI
        LODSB
        MOV [ESP+28],EAX          ; %ReturnEAX.
        MOV [EBX+STREAM.ReadPtr],ESI
        CLC
        JMP .90:
.50:    TEST EDX                  ; Is the next block allocated?
        STC
        JZ .90:
        MOV ESI,EDX               ; Bottom of data in the next block.
        JMP .70:
.60:    TEST EDX                  ; Is the next block allocated?
        STC
        JZ .90:
        MOV ESI,EDX               ; Bottom of data in the next block.
        MOV [EBX+STREAM.ReadPtr],ESI
.70:    MOV EDX,[EDX-4]           ; Pointer to the next block, or 0.
        LEA ECX,[ESI+EBP]
        JMP .10:
.90:  POPAD
      RET 1*4
  ENDPROC1 StreamReadByte@RT:
 %ENDMACRO StreamReadByte
</pre>


<dl id="StreamReadLn"><dt><a href="#STREAM">&uarr; StreamReadLn</a> Stream, LineBuffer</dt>
<dd>Macro <dfn>StreamReadLn</dfn> will retrieve one physical line (terminated with LineFeed
<kbd>0x10</kbd> from the Stream at position STREAM.ReadPtr and copy it to the LineBuffer.
<!---->The stream should be reset to start with the first line.
<br/>The last line stored in Stream doesn't have to be necessarily terminated with LF.</dd>
<dt>Input</dt><dd><b>Stream</b> is pointer to the STREAM object obtained in <a href="#StreamCreate">StreamCreate</a>.
<br/><b>LineBuffer</b> is pointer to the output <a href="#BUFFER">BUFFER
</a> where the line will be copied. It is allocated by the caller.</dd>
<dt>Output</dt><dd><b>CF=</b>0, one physical line from the stream is copied to LineBuffer, Stream.ReadPtr is advanced.</dd>
<dt>End of data</dt><dd><b>CF=</b>1, no more lines.</dd>
<dt>Example</dt><dd class="PRE">  MOV EBX,aStream
<!---->    BufferCreate aPool
<!---->    StreamReset EBX
<!---->Loop: StreamReadLn EBX,EAX
<!---->    JC End:
<!---->    BufferRetrieve EAX
<!---->    CALL ProcessTheLine:
<!---->    JMP Loop:
<!---->End:</dd>
<dt>See also</dt><dd><a href="#StreamReset">StreamReset</a></dd>
</dl><pre>
StreamReadLn %MACRO Stream, LineBuffer
      PUSHD %LineBuffer, %Stream
      CALL StreamReadLn@RT:
StreamReadLn@RT: PROC1
      PUSHAD
        MOV EBX,[ESP+9*4]              ; %Stream.
        MOV EBP,[EBX+STREAM.BufSize]
        MOV EDX,[EBX+STREAM.Next]      ; Pointer to the next block, or 0.
        LEA ESI,[EBX+SIZE#STREAM]      ; Bottom of data in the first block.
        LEA ECX,[ESI+EBP]              ; Top of the first block.
        MOV EAX,10                     ; AL=LF, AH=0. Nonzero AH signalizes incomplete line (not LF terminated).
.10:    ; Find the physical line starting at .ReadPtr in the block ESI..ECX.
        TEST AH,AH
        JZ .30:
        MOV [EBX+STREAM.ReadPtr],ESI   ; Bottom of the next block.
        XOR AH,AH
.30:    ; If the .WritePtr is in the block ESI..ECX, decrement ECX to its value.
        CMP [EBX+STREAM.WritePtr],ESI
        JB .40:
        CMP [EBX+STREAM.WritePtr],ECX
        JAE .40:
        MOV ECX,[EBX+STREAM.WritePtr]
.40:    ; If the .ReadPtr is in the block ESI..ECX, search for the LF.
        MOV EDI,[EBX+STREAM.ReadPtr]
        CMP EDI,ESI
        JB .50:                        ; Try the next block.
        CMP EDI,ECX                    ; Check if STREAM.ReadPtr EDI belongs to this data block ESI..ECX.
        JA .50:                        ; Try the next block.
        JE .60:                        ; .ReadPtr points to the top of block. Move it to the bottom of the next block.
        SUB ECX,EDI                    ; Max size of searched data in block EDI..ECX. At least 1.
        MOV ESI,EDI                    ; Remember the start of line.
        REPNE SCASB                    ; Search for the LF.
        MOV [EBX+STREAM.ReadPtr],EDI
        JE .80:                        ; If terminator LF found, we're almost done.
        OR AH,1                        ; The <b>line ESI..EDI is incomplete,</b> perhaps split between blocks.
        SUB EDI,ESI
        MOV ECX,[ESP+40]               ; %LineBuffer.
        BufferStore ECX,ESI,EDI        ; Store the first part of incomplete line.
        ; The line continues in the next block.
.50:    TEST AH
        JZ .55:
        TEST EDX                       ; Is the next block allocated?
        JZ .90:                        ; If not, the last line is incomplete, return it.
.55:    TEST EDX                       ; Is the next block allocated?
        STC
        JZ .90:                        ; If not and line not incomplete, signalize end of data.
        MOV ESI,EDX                    ; Bottom of data in the next block.
        JMP .70:
.60:    TEST EDX                       ; Is the next block allocated?
        STC
        JZ .90:
        MOV ESI,EDX                    ; Bottom of data in the next block.
        MOV [EBX+STREAM.ReadPtr],ESI
.70:    MOV EDX,[EDX-4]                ; Pointer to the next block, or 0.
        LEA ECX,[ESI+EBP]
        JMP .10:
.80:    SUB EDI,ESI
        MOV EDX,[ESP+10*4]             ; %LineBuffer.
        BufferStore EDX,ESI,EDI        ; Copy line ESI,EDI to the buffer EDX.
        CLC
 .90: POPAD
      RET 2*4
  ENDPROC1 StreamReadLn@RT:
 %ENDMACRO StreamReadLn
</pre>


<dl id="StreamGetLines"><dt><a href="#STREAM">&uarr; StreamGetLines</a> StreamPtr</dt>
<dd>returns the number of physical lines in the data in the stream. The stream should be reset first.
<br/>Physical line ends with LineFeed character (0x10). The last line in the stream may have LF omitted.</dd>
<dt>Input</dt><dd><b>StreamPtr</b> is pointer to the STREAM obtained in <a href="#StreamCreate">StreamCreate</a>.</dd>
<dt>Output</dt><dd><b>EAX=</b> total lines in the stream.</dd>
<dt>Depends on</dt><dd><a href="#StreamReadLn">StreamReadLn</a></dd>
</dl><pre>
StreamGetLines %MACRO StreamPtr
      SUB EAX,EAX
      DEC EAX
StreamGetLines%.:
      INC EAX
      StreamReadLn %StreamPtr, 0 ; The read lines won't be stored due to NULL buffer.
      JNC StreamGetLines%.:
 %ENDMACRO StreamGetLines
</pre>


<dl id="StreamReset"><dt><a href="#STREAM">&uarr; StreamReset</a> Stream</dt>
<dd>StreamReset moves the STREAM.ReadPtr to the beginning of data,
<!---->so the stream contents can be retrieved once again.</dd>
<dt>Input</dt><dd><b>Stream</b> is pointer to the STREAM obtained in StreamCreate.</dd>
<dt>Output</dt><dd> none.</dd></dl><pre>
StreamReset %MACRO Stream
      PUSH EAX,EBX
        MOV EBX,%Stream
        LEA EAX,[EBX+SIZE#STREAM]
        MOV [EBX+STREAM.ReadPtr],EAX
      POP EBX,EAX
 %ENDMACRO StreamReset
</pre>

<dl id="StreamClear"><dt><a href="#STREAM">&uarr; StreamClear</a> Stream</dt>
<dd>StreamClear discards the contents of a stream.
<!---->In fact it just moves the .WritePtr and .ReadPtr to the beginning of data.
<!---->Allocated buffers are not discarded, so their memory can be reused.</dd>
<dt>Input</dt><dd><b>Stream</b> is pointer to the STREAM obtained in <a href="#StreamCreate">StreamCreate</a>.</dd>
<dt>Output</dt><dd>-</dd>
<dt>Error</dt><dd>-</dd></dl><pre>
StreamClear %MACRO Stream
      PUSH EAX,EBX
        MOV EBX,%Stream
        LEA EAX,[EBX+SIZE#STREAM]
        MOV [EBX+STREAM.WritePtr],EAX
        MOV [EBX+STREAM.ReadPtr],EAX
        ADD EAX,[EBX+STREAM.BufSize]
        MOV [EBX+STREAM.Top],EAX
      POP EBX,EAX
 %ENDMACRO StreamClear
</pre>

<dl id="StreamDump"><dt><a href="#STREAM">&uarr; StreamDump</a> Stream, DumpProc</dt>
<dd>Macro <dfn>StreamDump</dfn> will copy the contens of the stream to callback procedure DumpProc.
<br/><dfn>DumpProc</dfn> is provided with pointer and size of one memory block,
<!---->it is expected to write the block to a file or to another stream or buffer.</dd>
<dt>Input</dt><dd><b>Stream</b> points to <a href="#STREAM">STREAM</a> obtained in
<a href="#StreamCreate">StreamCreate</a>.
<br/><b>DumpProc</b> is the entry point of callback procedure which will write
<!---->the memory block ESI,ECX.
<dl><dt>DumpProc input</dt><dd><b>ESI</b>= pointer to the data to be written.
<br/><b>ECX</b>= size of the data.
<br/><b>EBP</b>= EBP on StreamDump entry.
<br/><b>EBX</b>= pointer to the Stream. Other registers are undefined.</dd>
<dt>DumpProc output</dt><dd><b>CF</b>=0 to continue with the next block. All GPR may be destroyed in DumpProc.</dd>
<dt>DumpProc error</dt><dd><b>CF</b>=1 if error occured during writting the block. This will cancel further dumping.
</dd></dl></dd>
<dt>Output</dt><dd><b>-</b></dd>
<dt>See also</dt><dd><a href="#StreamRetrieve">StreamRetrieve</a></dd>
<dt>Example</dt><dd class="PRE">; Flush the stream contents to aFile:
<!---->   FileCreate aFile
<!---->   StreamDump aStream, aDumpProc
<!---->   FileClose aFile
<!---->aDumpProc PROC1
<!---->    FileWrite aFile,ESI,ECX
<!---->    RET
<!---->   ENDP1 aDumpProc
</dd></dl><pre>
StreamDump %MACRO Stream, DumpProc
      PUSHD %DumpProc, %Stream
      CALL StreamDump@RT:
StreamDump@RT: PROC1
      PUSHAD
       MOV EBX,[ESP+9*4]               ; %Stream.
       TEST EBX
       JZ .90:
       LEA ESI,[EBX+SIZE#STREAM]
       MOV EAX,[EBX+STREAM.WritePtr]
       TEST EAX
       JZ .90:
.20:   MOV ECX,[EBX+STREAM.BufSize]
       LEA EDX,[ESI+ECX]
       CMP EAX,EDX
       JNB .40:
       CMP EAX,ESI
       JNB .70:
.40:   PUSH EAX,EBX,ESI
        CALL [ESP+40+12]               ; %DumpProc, not the last block.
       POP ESI,EBX,EAX
       JC .90:
       MOV ESI,[ESI-4]
       TEST ESI
       JNZ .20:
       JMP .90:
.70:   MOV ECX,EAX
       SUB ECX,ESI
       JZ .90:
       CALL [ESP+10*4]                 ; DumpProc, the last block.
.90:  POPAD
      RET 8
  ENDPROC1 StreamDump@RT:
 %ENDMACRO StreamDump
</pre>

<dl id="StreamRetrieve"><dt><a href="#STREAM">&uarr; StreamRetrieve</a> Stream</dt>
<dd>Retrieving the stream returns pointer and size of one internal buffer.
<!---->The .ReadPtr is then advanced to the next buffer.
<br/>Repeated invocation of StreamRetrieve returns the next buffer.
<!---->Size of the last buffer may be smaller than .BufSize.</dd>
<dt>Input</dt><dd><b>Stream</b> is pointer to the STREAM obtained in <a href="#StreamCreate">StreamCreate</a>.</dd>
<dt>Output</dt><dd><b>ZF=</b>0, <b>ESI=</b> pointer to data in stream buffer.
<br/><b>ECX=</b> size of the data. In most cases ECX=STREAM.BufSize
<!---->but the last data buffer may be shorter.</dd>
<dt>On end of data</dt><dd> <b>ZF=</b>1, <b>ECX=</b>0 <b>ESI=</b>undefined</dd>
<dt>See also</dt><dd><a href="#StreamDump">StreamDump</a></dd></dl><pre>
StreamRetrieve %MACRO Stream
      PUSHD %Stream
      CALL StreamRetrieve@RT:
StreamRetrieve@RT: PROC1
      PUSHAD
       MOV EBX,[ESP+9*4] ; %Stream.
       MOV ECX,[EBX+STREAM.BufSize]
       MOV EAX,[EBX+STREAM.ReadPtr]
       MOV EDX,[EBX+STREAM.WritePtr]
       LEA ESI,[EBX+SIZE#STREAM]
       MOV [ESP+1*4],EAX ; %ReturnESI.
 .10:  LEA EDI,[ESI+ECX]
       CMP EDX,ESI
       JB .20:
       CMP EDX,EDI
       JNA .70:
 .20:  CMP EAX,ESI
       JB .30:
       CMP EAX,EDI
       JNA .50:
 .30:  MOV ESI,[ESI-4]
       TEST ESI
       JNZ .10:
       JMP .80:
 .50:  CMP EAX,EDI
       JNE .60:
       MOV ESI,[ESI-4]
       TEST ESI
       JZ .80:
       MOV [EBX+STREAM.ReadPtr],ESI
       MOV [ESP+1*4],ESI               ; %ReturnESI.
       JMP .10:
 .60:  MOV ECX,EDI
       SUB ECX,EAX
       JMP .90:
 .70:  CMP EAX,ESI
       JB .80:
       CMP EAX,EDI
       JA .80:
       MOV ECX,EDX
       SUB ECX,EAX
       JA .90:
 .80:  SUB ECX,ECX
 .90:  MOV [ESP+6*4],ECX               ; %ReturnECX.
       ADD [EBX+STREAM.ReadPtr],ECX
       TEST ECX
      POPAD
      RET 1*4
  ENDPROC1 StreamRetrieve@RT:
 %ENDMACRO StreamRetrieve
</pre>

<dl id="StreamStoreRT"><dt><a href="#STREAM">&uarr; StreamStoreRT</a></dt>
<dd> is a macro used internally by StreamStore*. It returns CF=0,EAX=written size or CF=1,EAX=0.
<br/>This macro also defines the subprocedure StreamStore$size@RT used in streaming ASCIIZ strings.
</dd></dl><pre>
StreamStoreRT %MACRO ; Common runtime proc for macros StreamStore, StreamStoreLn etc.
  StreamStore@RT: PROC1
     PUSHAD
      MOV EBX,[ESP+40] ; Stream.
      SUB EAX,EAX
      LEA ESI,[ESP+44] ; 1st data pair.
      MOV [ESP+28],EAX ; ReturnEAX.
 .10: LODSD ; DataPtr.
      MOV EBP,EAX
      TEST EAX
      JZ .90:
      LODSD ; DataSize.
      MOV EDX,EAX
      ADD [ESP+28],EAX ; Total written size.
      PUSH ESI
       ; EBP=DataPtr EDX=DataSize EBX=Stream
       MOV EDI,[EBX+STREAM.WritePtr]
       ; Start with the first block.
       LEA ESI,[EBX+SIZE#STREAM]
.15:   CMP EDI,ESI                ; Find the block pointed to with ESI, where EDI=WritePtr is in.
       JB  .20:
       MOV ECX,[EBX+STREAM.BufSize]
       ADD ECX,ESI
       CMP EDI,ECX
       JNA .30:
.20:   ; WritePtr is not in block ESI. Try the next one.
       MOV ESI,[ESI-4]
       TEST ESI
       JNZ .15:
       STC                        ; Inconsistent data. This should never happen.
       JMP .80:
.30:   ; EDI=WritePtr inside block ESI..ECX.
       SUB ECX,EDI                ; Remaining free room on the last buffer.
       XCHG ESI,EBP
.35: ; ESI=DataPtr EDI=WritePtr EBP=block EDX=requested data size ECX=remaining room.
       CMP EDX,ECX
       JA .40:
       MOV ECX,EDX
 .40:  SUB EDX,ECX
       REP MOVSB
       MOV [EBX+STREAM.WritePtr],EDI
       TEST EDX                   ; Data size not written yet.
       JZ .80:
       ; EDX=remaining nonstored datasize ESI=nonstored data EBX=Stream EBP=block.
       MOV EDI,[EBP-4]
       TEST EDI
       JZ .50:
       ; Next block EDI is already allocated, reuse it.
       MOV EBP,EDI
.45:   MOV [EBX+STREAM.WritePtr],EDI
       MOV ECX,[EBX+STREAM.BufSize]
       JMP .35:
.50: ; Block EBP was the last in chain. A new block needs to be allocated.
       MOV ECX,[EBX+STREAM.BufSize]
       ADD ECX,4
       PoolNew [EBX+STREAM.Pool],ECX
       JC .80:
       MOVD [EAX],0
       ADD EAX,4
       MOV [EBP-4],EAX            ; Link from the old block.
       MOV EBP,EAX
       MOV EDI,EAX
       JMP .45:
 .80: POP ESI
      JNC .10:
 .90:POPAD
     RET
StreamStore$size@RT:
     PUSH ECX,EDI
      SUB ECX,ECX
      SUB EAX,EAX
      DEC ECX
      MOV EDI,[ESP+12]            ; DataPtr
      REPNE SCASB
      SUB EAX,ECX
      SUB EAX,2
      MOV [ESP+16],EAX            ; DataSize
     POP EDI,ECX
     RET
  ENDPROC1 StreamStore@RT:
 %ENDMACRO StreamStoreRT
</pre>

<dl id="StreamStore"><dt><a href="#STREAM">&uarr; StreamStore</a> Stream, DataPtr1, DataSize1, DataPtr2, DataSize2,,,</dt>
<dd>This macro writes data to the stream. The data is specified with pointer and size.
<!---->More than one <em>pointer,size</em> pair can be specified in one invocation.</dd>
<dt>Input</dt><dd><b>Stream</b> ^STREAM obtained in StreamCreate.
<br/><b>DataPtr*</b> Pointer to data which will be copied to stream buffer.
<br/><b>DataSize*</b> Size of data in bytes.</dd>
<dt>Output</dt><dd><b>CF=</b>0, <b>EAX=</b> total written size.</dd>
<dt>Error</dt><dd> <b>CF=</b>1, <b>EAX=</b>0</dd></dl><pre>
StreamStore %MACRO Stream, DataPtr, DataSize
    %IF %# & 1 = 0
       ID=5971, 'Macro "StreamStore" expects odd number of arguments.'
      %EXITMACRO StreamStore
    %ENDIF
    PUSHD 0                            ; Mark the end of arguments.
    ArgNr %FOR %#..2,STEP=-2
      PUSHD %*{%ArgNr}, %*{%ArgNr-1}
    %ENDFOR ArgNr
    PUSHD %Stream
    PUSH ESP
     ADDD [ESP],4*(%#+1)
     CALL StreamStore@RT:
    POP ESP
    StreamStoreRT                      ; Declare the runtime procedure.
 %ENDMACRO StreamStore
</pre>

<dl id="StreamStoredo"><dt><a href="#STREAM">&uarr; StreamStore$</a> Stream, DataPtr1, DataPtr2, DataPtr3,,,</dt>
<dd>This macro writes data to the stream. The data is specified with pointer to
<!---->a zero-terminated byte string. The terminating zero is not stored to the stream.
<!---->More than one pointer can be specified in the invocation.</dd>
<dt>Input</dt><dd><b>Stream</b> Pointer to <a href="#STREAM">STREAM</a> obtained in <a href="#StreamCreate">StreamCreate</a>.
<br/><b>DataPtr*</b> Pointer(s) to ASCIIZ data which will be copied to stream buffer.
<dt>Output</dt><dd><b>CF=</b>0, <b>EAX=</b> total written size.</dd>
<dt>Error</dt><dd> <b>CF=</b>1, <b>EAX=</b>0</dd></dl><pre>
StreamStore$ %MACRO Stream, DataPtr
    PUSHD 0 ; Mark the end of arguments.
    ArgNr %FOR %#..2,STEP=-1
      PUSHD EAX, %*{%ArgNr} ;
      CALL StreamStore$size@RT:
    %ENDFOR ArgNr
    PUSHD %Stream
    PUSH ESP
     ADDD [ESP],8*(%#)
     CALL StreamStore@RT
    POP ESP
    StreamStoreRT                      ; Declare the runtime procedure.
 %ENDMACRO StreamStore$
</pre>

<dl id="StreamStoreLn"><dt><a href="#STREAM">&uarr; StreamStoreLn</a> Stream, DataPtr1, DataSize1, DataPtr2, DataSize2,,,</dt>
<dd>This macro writes data to the stream.
<!---->More than one <em>pointer/size</em> pair can be specified in one invocation.
<!---->After storing all data StreamStoreLn stores end-of-line characters CR+LF.</dd>
<dt>Input</dt><dd><b>Stream</b> ^STREAM obtained in StreamCreate.
<br/><b>DataPtr*</b> Pointer to data which will be copied to stream buffer.
<br/><b>DataSize*</b> Size of data in bytes.</dd>
<dt>Output</dt><dd><b>CF=</b>0, <b>EAX=</b> total written size including CR+LF.</dd>
<dt>Error</dt><dd> <b>CF=</b>1 <b>EAX=</b>0
</dd></dl><pre>
StreamStoreLn %MACRO Stream, DataPtr, DataSize
    %IF %# & 1 = 0
      %ERROR ID=5972, 'Macro "StreamStoreLn" expects odd number of arguments.'
      %EXITMACRO StreamStoreLn
    %ENDIF
    PUSHD 0x00000A0D                   ; EOL data.
    PUSHD 0                            ; Mark the end of arguments.
    PUSHD 2                            ; Size of EOL.
    PUSHD ESP                          ; Pointer to EOL.
    ADDD [ESP],8                       ; Adjust the pointer.
    ArgNr %FOR %#..2,STEP=-2
      PUSHD %*{%ArgNr}, %*{%ArgNr-1}
    %ENDFOR ArgNr
    PUSHD %Stream
    PUSH ESP
     ADDD [ESP],4*(%#+4)
     CALL StreamStore@RT:
    POP ESP
    StreamStoreRT                      ; Declare runtime procedure.
 %ENDMACRO StreamStoreLn
</pre>

<dl id="StreamStoreByte"><dt><a href="#STREAM">&uarr; StreamStoreByte</a> Stream, Data</dt>
<dd>This macro writes 1 bytes of data to the stream.</dd>
<dt>Input</dt><dd><b>Stream</b> ^STREAM obtained in StreamCreate.
<br/><b>Data</b> Byte memory variable or 8bit register.</dd>
<dt>Output</dt><dd><b>CF=</b>0, <b>EAX=</b>1</dd>
<dt>Error</dt><dd> <b>CF=</b>1, <b>EAX=</b>0
</dd></dl><pre>
StreamStoreByte %MACRO Stream, Data
    %IF "%Data" !== "AL"
      MOV AL,%Data
    %ENDIF
    PUSHD EAX
    PUSHD 0                            ; Mark the end of arguments.
    PUSHD 1                            ; Size of %Data.
    PUSHD ESP                          ; Pointer to %Data.
    ADDD [ESP],8                       ; Adjust the pointer.
    PUSHD %Stream
    PUSH ESP
     ADDD [ESP],20
     CALL StreamStore@RT:
    POP ESP
    StreamStoreRT                      ; Declare runtime procedure.
 %ENDMACRO StreamStoreByte
</pre>

<dl id="StreamStoreWord"><dt><a href="#STREAM">&uarr; StreamStoreWord</a> Stream, Data</dt>
<dd>This macro writes 2 bytes of data to the stream.</dd>
<dt>Input</dt><dd><b>Stream</b> ^STREAM obtained in StreamCreate.
<br/><b>Data</b> Word memory variable or 16bit register.</dd>
<dt>Output</dt><dd><b>CF=</b>0, <b>EAX=</b>2</dd>
<dt>Error</dt><dd> <b>CF=</b>1, <b>EAX=</b>0
</dd></dl><pre>
StreamStoreWord %MACRO Stream, Data
    %IF "%Data" !== "AX"
      MOV AX,%Data
    %ENDIF
    PUSHD EAX
    PUSHD 0                            ; Mark the end of arguments.
    PUSHD 2                            ; Size of %Data.
    PUSHD ESP                          ; Pointer to %Data.
    ADDD [ESP],8                       ; Adjust the pointer.
    PUSHD %Stream
    PUSH ESP
     ADDD [ESP],20
     CALL StreamStore@RT:
    POP ESP
    StreamStoreRT                      ; Declare runtime procedure.
 %ENDMACRO StreamStoreWord
</pre>

<dl id="StreamStoreDword"><dt><a href="#STREAM">&uarr; StreamStoreDword</a> Stream, Data</dt>
<dd>This macro writes 4 bytes of data to the stream.</dd>
<dt>Input</dt><dd><b>Stream</b> ^STREAM obtained in StreamCreate.
<br/><b>Data</b> Doubleword memory variable or 32bit register.</dd>
<dt>Output</dt><dd><b>CF=</b>0, <b>EAX=</b>4</dd>
<dt>Error</dt><dd> <b>CF=</b>1, <b>EAX=</b>0
<dt>Example</dt><dd> <code>StreamStoreDword aStream,EBX</code> store the contents of EBX.
<br/><code>StreamStore aStream,EBX,4</code> store 4 bytes of the memory addressed with EBX.
</dd></dl><pre>
StreamStoreDword %MACRO Stream, Data
    PUSHD %Data
    PUSHD 0                            ; Mark the end of arguments.
    PUSHD 4                            ; Size of %Data.
    PUSHD ESP                          ; Pointer to %Data.
    ADDD [ESP],8                       ; Adjust the pointer.
    PUSHD %Stream
    PUSH ESP
     ADDD [ESP],20
     CALL StreamStore@RT:
    POP ESP
    StreamStoreRT                      ; Declare runtime procedure.
 %ENDMACRO StreamStoreDword
</pre>

<pre>
 ENDHEAD memory32                      ; End of library interface.
</pre>
<!--TAILMENU-->
<!--Contents below the marker {!==TAILMENU==} was generated by "generate.php".-->
<br class='CLEAR'/><a id='bottom' href='#top'>&#x25B2;Back to the top&#x25B2;</a>
</body></html>
