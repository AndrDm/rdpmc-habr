<!doctype html><html lang='en'><head>
<meta http-equiv='Content-Type' content='text/html; charset=utf-8'/>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=2.0, user-scalable=yes'>
<meta name='robots' content='ALL,FOLLOW'/>
<meta name='description' content='stdcal64.htm macro library'/>
<meta name='version' content='20250318'/>
<meta name='author' content='Pavel vitsoft Šrubař'/>
<link rel='stylesheet' href='../euroasm.css' type='text/css'/>
<link rel='shortcut icon' href='../favicon.ico'/>
<title>stdcal64.htm macro library</title>
</head>
<body class='MACLIB' id='top'><div class='HEADMENU'><table>
<tr><td rowspan='2' title='&euro;ASM - assembler and linker'><img src='../favicon.ico' alt='EuroAssembler' />
<td><a href='../index.htm' title='Alphabetical index of all &euro;ASM elements, directives and instructions'>Index</a></td>
<td><a href='../eadoc/' class='EADOC' title='Documentation of EuroAssembler'>Manual</a></td>
<td><a href='https://euroassembler.eu/download/' title='History &amp; download of the latest and previous versions'>Download</a></td>
<td><a href='../easource/' class='EASOURCE' title='Source files of EuroAssembler itself'>Source</a></td>
<td><a href='../maclib/' class='MACLIB' title='Macro libraries shipped with &euro;ASM'>Macros</a></td>
<td rowspan='2' title='Find the searched token in any text file on this site'>
<form method='post' action='../search.php' enctype='multipart/form-data' accept-charset='utf-8'>
<input type='text' id='q' placeholder='Searched word(s)' name='q' value=''/>
<br/><label title='Check the box to find the expression even if it is surrounded by other letters | digits.'>
<input type='checkbox' name='EW'/><small>Embedded word</small></label>
<br/><label title='Check the box for case-insensitive search.'>
<input type='checkbox' name='CI'/><small>Case ins.</small></label>
<input type='submit' title='Search for the specified word|expression in all site files.' name='find' value='Search'/>
</form></td></tr><tr>
<td><a href='../sitemap.htm' title='List of directories and files on this site'>Sitemap</a></td>
<td><a href='../eadoc/links.htm' class='EADOC' title='References and external links to resources used in EuroAssembler developement'>Links</a></td>
<td><a href='https://euroassembler.eu/forum/' title='Discussion forum concerning EuroAssembler'>Forum</a></td>
<td><a href='../eatests/' class='EATESTS' title='Program snippets for testing the function of &euro;ASM'>Tests</a></td>
<td><a href='../objlib/' class='OBJLIB' title='Skeletons and sample objects and projects shipped with &euro;ASM'>Projects</a></td>
</tr></table></div>
<!--Contents above the marker {!==/HEADMENU==} was generated by "generate.php".-->
<!--/HEADMENU-->
<h1>stdcal64.htm
<br/><i>Enumeration</i>
<br/><a href="#pcStdCall64">%StdCall64</a>
<br/><i>Macros</i>
<br/><a href="#ClearLocalVar">ClearLocalVar</a>
<br/><a href="#EndProcedure">EndProcedure</a>
<br/><a href="#Invoke">Invoke</a>
<br/><a href="#LocalVar">LocalVar</a>
<br/><a href="#Procedure">Procedure</a>
<br/><a href="#Uses">Uses</a>
</h1>
<p>This file can be included to <strong>64bit programs</strong> written in EuroAssembler.
<!---->The library contains <strong>OS-independent</strong> macroinstructions <code>Procedure, EndProcedure, Invoke
</code> which extend generic pseudoinstructions <code>PROC, ENDPROC, CALL</code>.</p>
<p>Macroinstructions <code>Procedure</code> and <code>EndProcedure</code> hide the prologue and epilogue of
<dfn>standard call</dfn> <a class="EXTL" href="../eadoc/links.htm#CallingConv">calling convention
</a>, where the arguments are pushed backwards and they are removed by the called procedure.</p>
<blockquote>Although <a class="EXT" href="fastcall.htm">fastcall</a> or <a class="EXT" href="sysvcall.htm">System V
</a> convention are used almost exclusively in the realm of 64bit programming,
<!---->more effective macros from this library can be preferred for writing private procedures,
<!---->which are not supposed to be invoked from 3rd party programs or as OS callbacks.
<!---->StdCall does not bother with stack alignment or shadow space. It is the job of invoked private procedure
<!---->to align the stack at the moment whenever it's needed,
<!---->to allocate local stack variables with macros <code>LocalVar, ClearLocalVar</code> and
<!---->to save used registers with macro <code>Uses</code> on its own account.</blockquote>
<p>Macroinstructions in this library comunicate at assembly time through
<!---->the preprocessing %variables <code>%LvSize_<em>ProcName</em></code> (total size of all local stack-variables),
<code>%ArgC_<em>ProcName</em></code> (number of procedure parameters) and
<code>%Uses_<em>ProcName</em></code> (the list of used calee-saved registers).
<br/>Individualization of global %variable names allows to nest procedure definitions in one another.</p>
<p>Implementation of standard call convention in &euro;ASM
<!---->uses formal %names for accessing Procedure parameters and local stack-memory variables.
<br/>Unlike 32bit and 16bit version, returned value of registes is not available as stack variables,
<!---->because GPR are not automatically stored (there is no PUSHAQ in 64bit mode).</p>
<dl><dt>Example</dt><dd>The following example shows the stack frame created by invoking Procedure with the name
<em>MyFn</em> which has three parameters, uses only 3 registers RCX,RSI,RDI in its body,
<!---->and allocates two local stack variables named LocV1 and LocV2 with sizes 8 and 16.
<br/>Prologue of <code>MyFn Procedure Par1, Par2, Par2</code> will assign &quot;global&quot;
<!----> %variable <code>%ArgC_MyFn %SETA 3</code>,
<br/><code>Uses RCX,RSI,RDI</code> will assign <code>%Uses_MyFn %SET RDI,RSI,RCX</code>,
<br/>both macros <code>LocalVar</code> will assign <code>%LvSize_MyFn %SETA 8+16</code>.
</dd>
<dd class="PRE">MyFn Procedure Par1, Par2, Par3
<!---->       Uses RCX,RSI,RDI  ; Enumerate registers which should be preserved in MyProc invokation.
<!---->LocV1  LocalVar          ; Reserve local stack variable with default size 8.
<!---->LocV2  LocalVar Size=16  ; Reserve another variable.
<!---->       ; MyProc body can use formal names Par1, Par2, Par3, LocV1, LocV2
<!---->       ;   to access its parameters and local stack variables by prefixing
<!---->       ;   the formal name with <kbd>%</kbd>, for instance
<!---->       MOV RAX,[%Par1]
<!---->       MOV [%LocV1],RAX
<!---->       ; Macro EndProcedure discards local variables, restores used GPR
<!---->       ;  and returns below Invoke, removing the pushed arguments.
<!---->      EndProcedure MyFn</dd>
<dd><p>The following diagram shows the stack frame created by invoking MyProc defined in the example above.
<blockquote>Macros of standardcall convention will create and update the following &quot;global&quot; %variables at asm-time:
<br/><code>%ArgC_MyProc   %SETA 3</code> (number of arguments),
<br/><code>%Uses_MyProc   %SET RCX,RSI,RDI</code> (list of used callee-saved registers),
<br/><code>%LvSize_MyProc %SETA 8+16</code> (total size of local stack-variables),
<br/><code>%LocV1 %SET RBP-32</code> (1st local stack variable),
<br/><code>%LocV2 %SET RBP-48</code> (2nd local stack variable),
<br/><code>%Par1  %SET RBP+16</code> (1st parameter pushed on stack),
<br/><code>%Par2  %SET RBP+24</code> (2nd parameter pushed on stack),
<br/><code>%Par3  %SET RBP+32</code> (3rd parameter pushed on stack),
</blockquote></dd>
<dd class="PRE">                                  <abbr>RSP after the step.</abbr>
<!---->                                   <abbr>&#x2502;</abbr>&lt;&#x2500;8 bytes&#x2500;&gt;
<!---->            &#x250C;&#x2500;                     <abbr>&#x2502;</abbr>&#x250C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2510;&lt;17.                 &#x2500;&#x2510;
<!---->            &#x2502; 1. PUSH Par3         <abbr>&#x2502;</abbr>&#x2502; %Par3   &#x2502;                      &#x2502;
<!---->            &#x2502;                    1.&gt;&#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;                      &#x2502;
<!---->            &#x2502; 2. PUSH Par2          &#x2502; %Par2   &#x2502;                      &#x2502;
<!----> Invoke    &#x2500;&#x2524;                    2.&gt;&#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;                      &#x2502;
<!---->            &#x2502; 3. PUSH Par1          &#x2502; %Par1   &#x2502;                      &#x2502;
<!---->            &#x2502;                    3.&gt;&#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;                      &#x2502;
<!---->            &#x2514;&#x2500;4. CALL MyProc        &#x2502; return  &#x2502;    17. RET 3*8       &#x2502;
<!---->            &#x250C;&#x2500;                   4.&gt;&#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;&lt;16.                  &#x2502;
<!----> Procedure &#x2500;&#x2524; 5.PUSH RBP;MOV RBP,RSP&#x2502;  RBP    &#x2502;    16. POP RBP       &#x2502;
<!---->            &#x2514;&#x2500;                   5.&gt;&#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;&lt;15.                  &#x2502;
<!---->            &#x250C;&#x2500;6. PUSH RCX           &#x2502;  RCX    &#x2502;    15. POP RCX       &#x251C;&#x2500;EndProcedure
<!---->            &#x2502;                    6.&gt;&#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;&lt;14.                  &#x2502;
<!----> Uses      &#x2500;&#x2524; 7. PUSH RSI           &#x2502;  RSI    &#x2502;    14. POP RSI       &#x2502;
<!---->            &#x2502;                    7.&gt;&#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;&lt;13.                  &#x2502;
<!---->            &#x2514;&#x2500;8. PUSH RDI           &#x2502;  RDI    &#x2502;    13. POP RDI       &#x2502;
<!---->            &#x250C;&#x2500;                   8.&gt;&#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;&lt;12.                  &#x2502;
<!---->            &#x2502; 9. SUB RSP,8          &#x2502;  LocV1  &#x2502;    12. ADD RSP,8+16  &#x2502;
<!---->            &#x2502;                    9.&gt;&#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;                      &#x2502;
<!----> LocalVar  &#x2500;&#x2524;                       &#x2502;         &#x2502;                      &#x2502;
<!---->            &#x2502;                       &#x2502;  LocV2  &#x2502;                      &#x2502;
<!---->            &#x2502;10. SUB RSP,16         &#x2502;         &#x2502;                      &#x2502;
<!---->            &#x2514;&#x2500;                  10.&gt;&#x2514;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2518;&lt;11.                 &#x2500;&#x2518;
<!---->
<!---->                                11. MyProc body
</dd></dl>

<br class="CLEAR"/><pre>
stdcal64 HEAD
</pre>
<dl id="pcStdCall64"><dt><a href="#top">&uarr; %StdCall64</a></dt>
<dd>Argument values pushed on stack during <a href="#Invoke">Invoke
</a> are available inside the Procedure body as formal names or as
<strong>generic names</strong> defined here:</dd>
</dl><pre>
; Formal %names assignment:
%Par8  %SET RBP+72
%Par7  %SET RBP+64
%Par6  %SET RBP+56
%Par5  %SET RBP+48
%Par4  %SET RBP+40
%Par3  %SET RBP+32
%Par2  %SET RBP+24
%Par1  %SET RBP+16
</pre>

<dl id="Procedure"><dt><a href="#top">&uarr; Procedure</a> Operand1, Operand2,,,</dt>
<dd>This macro declares 64bit StandardCall procedure prolog which, unlike ordinary pseudoinstruction
<!---->PROC, accepts ordinal operands.
<br/>Macro operands will be assigned to preprocessing %variables
<!---->using the operand formal name prefixed with a percent sign.</dd>
<dt>Input</dt><dd>Label of <b>Procedure</b> statement is mandatory,
<!----> it gives the procedure an invokable name.
<br/><b>Operand*</b> is the list of formal names for arguments passed to the procedure.
<!---->Anything pushable as QWORD can be used as Procedure operand.
<!---->Number of operands is not limited.</dd>
<dt>Output</dt><dd>Macroinstruction will define global symbol, assign formal operands to %variables
<!---->and establish operand stack frame based on RBP.</dd>
<dt>Example</dt><dd class="PRE">Move Procedure Source,Destination,Size
<!---->    Uses RCX,RSI,RDI
<!---->    MOV RSI,[%Source]
<!---->    MOV RDI,[%Destination]
<!---->    MOV RCX,[%Size]
<!---->    REP MOVSB
<!---->  EndProcedure Move
</dd><dd>Macro Procedure in the previous example will assign</dd>
<dd class="PRE">%ArgC_Move   %SETA 3 ; This %variable propagates to macro EndProcedure and tells how many parameters should be discarded.
<!---->%Uses_Move   %SET        ; This %variable propagates to macro Uses and in EndProcedure it tells which registers should be restored.
<!---->%LvSize_Move %SETA 0     ; This %variable propagates to macros LocalVar and ClearLocalVar, if they're used in <code>Move Procedure</code>.
<!---->%Source      %SET RBP+16 ; These are formal %variables of all operands.
<!---->%Destination %SET RBP+24
<!---->%Size        %SET RBP+32
</dd></dl><pre>
Procedure %MACRO Operands ; Prologue of standard calling convention procedure.
LblCheck    %IF "%:" === ""
              %ERROR ID=5921, 'Macro "Procedure" requires a label.'
              %EXITMACRO Procedure
            %ENDIF LblCheck
%%ArgC_%:   %SETX %#
%%Uses_%:   %SETX
%%LvSize_%: %SETX 0
ArgNr       %FOR 1..%#, STEP=+1
%%%*{%ArgNr}  %SETX RBP+(8+%ArgNr*8)
            %ENDFOR ArgNr
%:::        PROC %=*, NESTINGCHECK=OFF
            PUSH RBP
            MOV RBP,RSP
          %ENDMACRO Procedure
</pre>

<dl id="Uses"><dt><a href="#top">&uarr; Uses</a> Register1, Register2,,,,</dt>
<dd><p>Macro <dfn>Uses</dfn> specifies which callee-save registers does the Procedure use,
<!---->so they are saved on stack here (and they will be restored in <a href="#EndProcedure">EndProcedure</a> epilogue).
<br/>In other words, all registers which we don't wan't to get clobbered by procedure invokation should be enumerated
<!---->as arguments of macro Uses.</p>
<p>Macro Uses should be expanded in 64bit mode only, right after the statement <a href="#Procedure">Procedure
</a> and before local stack variables are defined with <a href="#LocalVar">LocalVar
</a>, see the examples above.</p>
<p>Registers RBP, RSP should never be enumerated here, because they are saved and restored by
<code>Procedure</code> and <code>EndProcedure</code> automatically. Also register(s) which return the procedure result
<!---->should not appear on <code>Uses</code> list of arguments.</p>
<blockquote>Well behaved Procedure changes only those registers which return its result.
<!---->However, this rule may be not observed from performance reason. Fastcall convention,
<!---->which is also commonly used in 64bit programs, specifies that RCX,EDX,RSI,RDI,R8,R9,R10,R11
<!---->are scratch registers which may be clobbered by procedure invokation.
</blockquote>
</dd>
<dt>Input</dt><dd><b>Register*</b> is the list of 64bit general purpose registers.
<!---->If the procedure uses registers of other types, it should save/restore them by its own.</dd>
<dt>Output</dt><dd>Macro will push all enumerated registers on stack
<!---->and assign their list to a &quot;global&quot; %variable <code>%Uses_<em>ProcName</em>
</code> in reversed order. This %variable will be used by EndProcedure for restoration of callee-save registers.</dd>
</dl><pre>
Uses        %MACRO Register1,Register2,,,
              %IF "%^PROC" === ""
                %ERROR ID=5926,'Macro "Uses" can only be used within Procedure..EndProcedure block.'
              %ENDIF
%Uses         %SET2 %%Uses_%^PROC
reg           %FOR %*
                %IF REGTYPE# %reg = 'Q'
                  PUSHQ %reg
%Uses             %SET %reg,%Uses
                %ELSE
                  %ERROR ID=5927,'Macro "Uses" does not support operand "%reg".'
                %ENDIF
              %ENDFOR reg
%%Uses_%^PROC %SETX %Uses
            %ENDMACRO Uses
</pre>


<dl id="LocalVar"><dt><a href="#top">&uarr; LocalVar</a> Size=8</dt>
<dd>reserves and declares local memory variable with the given Size allocated on machine stack.</dd>
<dt>Input</dt><dd>Plain identifier must be defined as a label of
<b>LocalVar</b> statement. It does not need to be unique in the program
<!---->because it does not declare assembly symbol. The name will be
<!----> prefixed with <kbd>%</kbd> and used as preprocessing %variable
<!---->for addressing parameters withing the procedure body.
<br/><b>Size=</b>8 specifies how many bytes should be reserved for the local variable.
<!---->It is rounded up to QWORD internally.</dd>
<dt>Output</dt><dd>Macro will define a preprocessing %variable with
<!---->the name which was defined as the label but it is now prefixed with percent sign.
<!---->Then it will emit machine instruction <code>SUB RSP,%Size</code>
<!---->to reserve room on the machine stack.
<br/>Macro LocalVar also maintains the &quot;global&quot; variable
<code>%LvSize_<em>ProcName</em></code> which was initialized in macro <code>Procedure</code>.</dd></dl>
<pre>
LocalVar %MACRO Size=8
LblCheck        %IF "%:" === ""
                  %ERROR ID=5922, 'Macro "LocalVar" requires a label.'
                  %EXITMACRO LocalVar
                %ENDIF LblCheck
SizeCheck       %IF %#
                  %ERROR ID=5923, 'Macro "LocalVar" does not expect ordinal parameters.'
                  %EXITMACRO LocalVar
                %ENDIF SizeCheck
%:              %COMMENT                          ; This makes the label of macro invocation void,
                %ENDCOMMENT %:                    ;  so it does not declare a symbol.
%ThisLvSize     %SETA (%Size + 7) & ~7            ; Round up the required size to QWORD.
%GlbLvSize      %SET2 %%LvSize_%^PROC+%ThisLvSize ; Accumulate total size of all LocalVar.
%%LvSize_%^PROC %SETX %GlbLvSize                  ; Update the "global" variable.
                SUB RSP, %ThisLvSize              ; Allocate room on stack.
%ThisUses       %SET2 %%Uses_%^PROC               ; List of registers enumerated by Uses.
%ThisLen        %SETL %ThisUses                   ; Number of registers pushed by Uses.
%%%:            %SETX RBP-8*%ThisLen-(%GlbLvSize) ; Assign formal %name to the id specified with LocalVar label.
            %ENDMACRO LocalVar
</pre>

<dl id="ClearLocalVar">
<dt><a href="#top">&uarr; ClearLocalVar</a></dt>
<dd>This macro zeroes all variables on stack previously declared with
<a href="#LocalVar">LocalVar</a>. ClearLocalVar should be expanded
<!---->right after LocalVar declarations, before any stack operations are made.
<blockquote>We could as well decide to initialize each local variable individually,
<!---->in this case the macro ClearLocalVar will not be used in the Procedure body at all.
</blockquote></dd>
<dt>Input</dt><dd>Macro does not use explicit parameters.
<!---->Pointer to the cleared memory is specified with
<code>RSP</code>, cleared size is specified with &quot;global&quot; variable
<code>%LvSize_<em>CurrentProcName</em></code>.</dd>
<dt>Output</dt><dd><b>RAX=RCX=</b>0,
<br/><b>RDI</b>= RSP + %LvSize_<em>CurrentProcName</em></dd></dl><pre>
ClearLocalVar %MACRO
%GlbLvSize %SET2 %%LvSize_%^PROC
           %IF %GlbLvSize
             MOV RDI,RSP
             MOV RCX,(%GlbLvSize) / 8
             XOR RAX,RAX
             REP STOSQ
           %ENDIF
         %ENDMACRO ClearLocalVar
</pre>

<dl id="EndProcedure">
<dt><a href="#top">&uarr; EndProcedure</a> ProcName</dt>
<dd><p>Macro <dfn>EndProcedure</dfn> terminates context of the previously opened
<a href="#Procedure">Procedure
</a>. This epilogue of StdCall convention will discard local variables defined with
<a href="#LocalVar">LocalVar</a> (using machine instruction
<code>MOV RSP,RBP</code>, restore used GP registers declared with macro
<a href="#Uses">Uses</a> and then return to the parent code
<!---->which the Procedure was Invoked from (using <code>RET 8*%ArgC_<em>ProcName</em></code>).
<br/>Operands pushed on stack in the <b>Invoke</b> statement
<!----> will be discarded here by this <b>EndProcedure</b> macro.
<br/>Registers not saved by <b>Uses</b> and CPU flags are not preserved, <b>EndProcedure</b> returns
<!---->with the same flag values which were set at the
<b>EndProcedure</b> entry.</p>
<blockquote> Programmer should never use explicit machine instruction <code>RET</code>
 <!----> to return from the block defined with <code>Procedure .. EndProcedure
</code>.  If premature return is required, jump to the label of <code>EndProcedure
</code> statement instead.</blockquote>
</dd>
<dt>Input</dt><dd>
<b>ProcName</b> This macroinstruction requires exactly one operand
<!---->which is identical with the label of previous corresponding
<code>Procedure</code> statement.</dd>
<dt>Output</dt><dd>Stack frame is released, current process returns below
<code>Invoke</code> statement.</dd></dl><pre>
EndProcedure %MACRO ProcName
OpCheck    %IF "%ProcName" === ""
             %ERROR ID=5924, 'Macro "EndProcedure" requires one operand.'
             %EXITMACRO EndProcedure
           %ENDIF OpCheck
%NameStrip %SET %ProcName
           %WHILE "%NameStrip[%&]" == ":" ; Get rid of trailing colon(s).
             %NameStrip %SET %NameStrip[1..%&-1]
           %ENDWHILE
%ArgC      %SET2 %%ArgC_%NameStrip
NestCheck  %IF "%ArgC" === ""
             %ERROR ID=5925, '"%ProcName Procedure" statement missing.'
             %EXITMACRO EndProcedure
           %ENDIF NestCheck
%GlbLvSize %SET2 %%LvSize_%NameStrip
           ADD RSP,%GlbLvSize
%Uses      %SET2 %%Uses_%NameStrip
           %IF "%Uses" !=== ""
             POP %Uses
           %ENDIF
           POP RBP
           RET 8 * (%ArgC)
           ENDP %ProcName, NESTINGCHECK=OFF
         %ENDMACRO EndProcedure
</pre>

<dl id="Invoke"><dt><a href="#top">&uarr; Invoke</a> ProcName, Arg1, Arg2, ...</dt>
<dd><dfn>Invoke</dfn> is a replacement of standard CALL instruction which can pass parameters
<!----> to the Procedure. Arguments are pushed on stack as QWORDs,
<!----> starting from the last. The procedure is then called
<!----> and it is responsible for removing pushed arguments from stack.
<br/>It is necessary to Invoke a procedure with exactly the same number
<!---->of arguments which were declared by the <a href="#Procedure">Procedure</a> macro.
<br/>If any argument represents a 64bit pointer or SIMD register, it should be loaded
<!---->to a temporary register and this register used as Invoke's argument, for instance</dd>
<dd class="PRE"> LEA RDX,[SomePointer]
<!----> MOVQ RCX,XMM1
<!----> Invoke MyStdcallProc, RDX, RCX
</dd>
<dt>Input</dt><dd><b>ProcName</b> The first operand is the name of invoked procedure.
<br/><b>Arg*</b> is a list of Procedure arguments. It can be anything pushable as QWORD.
</dd>
<dt>Output</dt><dd>The returned registers and flags depend on the
<!---->invoked Procedure.</dd>
</dl><pre>
Invoke %MACRO ProcName, Arguments
ArgCheck %IF "%ProcName" === ""
           %ERROR ID=5926, 'Macro "Invoke" requires the name of called Procedure.'
           %EXITMACRO Invoke
         %ENDIF ArgCheck
ArgNr    %FOR %#..2, STEP= -1
           PUSHQ %*{%ArgNr}
         %ENDFOR ArgNr
         CALL %ProcName
       %ENDMACRO Invoke
</pre><pre>
  ENDHEAD stdcal64
</pre><!--TAILMENU-->
<!--Contents below the marker {!==TAILMENU==} was generated by "generate.php".-->
<br class='CLEAR'/><a id='bottom' href='#top'>&#x25B2;Back to the top&#x25B2;</a>
</body></html>
